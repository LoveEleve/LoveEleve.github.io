谈到并发，我们通常会想到锁，因为通常来说并发的代码是存在安全问题，而锁则可以解决并发安全问题。

这里的并发泛指多个线程能够访问共享数据(不一定需要同时访问才存在并发安全性,这意味着并发安全问题并不是多核才存在的，单核依旧存在并发安全问题)

那么为什么需要并发呢? 其核心目的就是为了提高CPU利用率，当一个线程因为某些原因(比如I/O操作)而需要阻塞等待时，CPU可以切换到另外一个线程执行,避免CPU在做无效的等待，也正是因为这样,线程安全问题就出现了。

因为虽然在高级语言中只是一行代码，比如 i++，但是其所对应的CPU指令可能为多条，比如对于i++就分为3条，假设i所在的内存地址为A，从内存A处中取i的值到寄存器中，对寄存器中的值自增，将寄存器中的值写回到内存地址A处。但是CPU执行指令的单位却是单条的(CPU执行的最小单位是指令)

那么多个线程并发执行i++会出现什么问题呢？&#x20;

注意不是线程阻塞CPU才会调度到其他线程，具体的调度策略由OS决定,所以线程调度是没有规律的

![](images/HEPMbkSeQor62dx0gtac9EXUnbh.png)



只要Thread-B在Thread-A没有将寄存器中的值写回内存前，Thread-B拿到的就是内存中的旧值 0，不管两个线程如何交叉调度，最终在内存中的结果则是为1，而不是2。

这里其实会更为复杂一些,因为CPU内部还有Cache，通常是先写Cache，而不是直写Memory。所以这里还涉及到缓存一致性的问题

为什么要说上面这些呢？和高级语言中的锁有什么关系呢？

CPU执行指令是原子性的，是不可打断的，但是CPU执行一个操作则无法保证原子性，比如对i自增这一个操作（这一个操作通常会产生三条指令：read-modify-write）， CPU为了提高自己的效率引入了并发，但是这又同时带来了并发安全问题，如果CPU自己不给出一个解决办法(硬件)层面，那么在软件层面又如何解决呢？因为代码最终还是运行在硬件之上的啊。

&#x20;这就引入了lock prefix（lock 前缀）

看上面的图，出现安全问题其实是因为Thread-A在访问i所在的内存以及后续操作时，Thread-B也同时访问了i所在的内存，如果有一种机制，能够保证Thread-A在访问i所在内存时，其他线程无法访问i所在内存的机制，那么这个问题就能解决了(当然没有这么简单,比如现代CPU通常都有Cache,Cache的引入也会带来一系列的问题)

```plain&#x20;text
// 以下内容摘取之Intel开发手册，第三卷第九章
// lock前缀指令提供了锁内存总线的能力(访问内存需要通过内存总线)
// 下面这段话的含义大致为：The 32-bit IA-32 processors 支持在系统内存上的原子操作，这些操作通常用来管理共享数据结构 - 
//  -- 可能会被两个或者多个处理器同时修改这些数据结构相同的字段或者标识
The 32-bit IA-32 processors support locked atomic operations on locations in system memory. These operations
are typically used to manage shared data structures (such as semaphores, segment descriptors, system segments,
or page tables) in which two or more processors may try simultaneously to modify the same field or flag.

·Bus locking, using the LOCK# signal and the LOCK instruction prefix

two or more processors 那么对于单个处理器呢？
 --> 其实这个问题可以引入协程的概念,因为单核无法真正的并行,只能通过调度来切换执行。
     如果使用锁来保证原子性,比如有两个线程:Thread-A和Thread-B。
     Thread-A获取了锁,然后调度到Thread—B,同样Thread-B尝试获取锁，
     但是由于Thread-A没有释放锁,那么这次调度其实是完全没有意义的。
     只有Thread-A执行完特定的逻辑并且释放锁后,此时Thread-B的调度才是有意义的
     所以在单核上有一种更为高效的保证原子性的方法:关中断(因为线程调度是依赖时钟中断的)
     在线程没有执行完之前,不会调度到其他线程
 --> 但是在多处理器中,关中断不再生效
```

所以总结一下：硬件层面提供的单操作的原子性 是 软件层面实现多操作原子性的基石。 不管是内核还是其他软件，最终都要依赖这个原则
