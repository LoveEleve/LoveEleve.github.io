前面提到过： 硬件层面提供的单操作的原子性 是 软件层面实现多操作原子性的基石,但是如何正确的使用硬件层面提供的单操作的原子性来保证线程安全是一件很复杂的事情,因为不同的需求场景,可能需要利用单操作的原子性来实现不同的功能(比如有些时候可能希望互斥,而有的时候又希望只限制执行体(线程/进程)的个数(比如信号量))。

如果所有的功能都由开发者来实现,一个是程序的健壮性不是很好，并且也很浪费业务开发的时间。所以为了减轻开发者的负担,提出了管程的概念。

管程包含了两个部分：共享的**数据**和操作共享数据的函数(方法)。 管程保证了在同一个时刻最多只能有一个操作者能够进入到管程的保护区域(临界区),也即互斥性。

由于管程已经保证了访问共享数据的互斥性，所以开发者只需要调用管程提供的函数即可,并不需要利用底层的原语来自己实现同步机制,大大降低了开发者的负担。

对象的特征：状态,数据和行为(方法),正是这样,管程通常用于面向对象编程中，比如Java,而我们平时所直接使用的锁对象,就是管程的一种实现方式

除了共享数据和操作共享数据的方法外,还需要有什么呢？

管程保证了在同一个时刻最多只能有一个操作者能够进入到管程所保护的临界区，但是对于进入到临界区的操作者,我们无法预知他的执行过程(包括结果和所耗时长),那么在这段时间内,其他想要进入到管程中的操作者自然会被拒绝。那么它们应该怎么办呢？

1.不断重试： 由于无法预估进入到管程中的操作者执行的时间，所以这种傻等的方式性能是最不稳定的，可能运气好,不用等多久就能进入到管程中,但是如果运气差,则操作者将会一直重试，这可能会导致CPU飙高 2.阻塞等待： 当操作者无法进入到管程中,那么直接选择阻塞等待，不会尝试重试。但是这也会有一个问题,就恰恰运气不好，在阻塞后,前一个操作者立即离开了管程,那么又要苏醒,再次尝试(频繁的上下文切换也会导致CPU飙高)

从这两点可以得出以下结论：

1. 不应该采用单纯的不断重试，或者直接阻塞，而是一种折中的方式，也即在进入到管程中失败后，先重试一段时间后，如果还是不成功，那么才选择阻塞(这里有个点,就是重试的次数应该如何选择呢？)
2. 如果最终要阻塞，那么操作者应该去哪里等待呢？又被谁唤醒呢？这里又可以引入两个概念
3. 队列：非数据结构中的队列,这里泛指容器-存储进入管程失败的操作者的数据结构
4. 条件：当条件不满足时去队列等待，当条件满足时，被造成条件满足的操作者给唤醒(通俗点：释放锁的线程应该负责唤醒因为获取锁失败而阻塞的线程)

总结一下：管程是一种高层次的抽象,它利用其他同步原语实现了一套可以直接被开发者所使用的接口，使得开发者无需关心底层的细节。

