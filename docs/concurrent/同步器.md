<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY0NmMzMmM1MDZjNGQzN2Q4MWNhOWRjYWYyMDI2NjJfTlJOWVAzNk13Z1RZMVJBU0ZiMEJZY080b2VpN05QaEhfVG9rZW46T0NzeWJRQThKb0xRQ1J4ZkI2aGNsZzJVblhnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

juc中的同步器

## Semaphore
### 介绍
通常将该类翻译为信号量，用于控制同时访问特定资源的线程数量「**限流**」(当信号量为1时,和互斥锁的作用一样)。当信号量存在多个时,它只是用于限制线程数,对线程的操作不关心(也即不关心线程是执行读操作还是写操作)。

### 类关系图
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFkNTg2YjRhY2RkMGEyZjI3NWQyZmU2ZmI4YWQxMjFfOE9LS3p3Z2pPRFJsMmV3RDE2SVh6OXZYcExzcnd3S0hfVG9rZW46VXdVNmI0Uk1Kb2NGc3B4RjBFMWNaaTlLbkdnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 源码解析
讲述核心方法

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU3MWM3MzZjNjQwMmJjM2Q4YTcyYzk1ZTM0YzY1NzZfNlVQMzRMMFR3YkNVQjZCWVA2Q3JhM0ZGVkF6dHhva2NfVG9rZW46VzY2VGJyNXRWb3VjalZ4Z2dWcWNHZWs4bjVkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



**构造函数：** 初始状态如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I4YzYxMzZiNTIyYjZjOTU3MGZmNWYwNmMzOTczZTlfa1o2cUpxZlFNUlBha1dBTDM2VklFRDVGZDhqZXVQOEZfVG9rZW46RVFUc2JuS0N5bzk2VTB4YVFZNGN2cVlLblFmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
// 需要传入一个许可证数量(最终会赋值给AQS中的state)
// 并且默认是非公平模式
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}
```

**acquire(int arg)源码解析：** 该方法的作用是获取一个许可证,获取成功则返回,否则阻塞直到有一个可用的许可证或者被中断

```plain
// 委托给sync
public void acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

// 来到aqs中的方法,并且可以看到Semaphore的内部实现是共享获取
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted()) // 如果已经被中断,那么抛出异常
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0) // 如果尝试获取许可证失败(由子类实现许可证的获取),那么进入到入队操作
        doAcquireSharedInterruptibly(arg);
}
// 非公平实现
final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}

// 公平实现
 protected int tryAcquireShared(int acquires) {
        for (;;) {
            if (hasQueuedPredecessors())
                return -1;
            int available = getState();
            int remaining = available - acquires;
            if (remaining < 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }
}
```

1.公平与非公平的区别在于：如果同步队列中已经存在等待的线程了,那么公平直接进入到入队的流程。而非公平并不会考虑在此之前是否有线程已经在等待了,而是会直接去竞争「这样的做法虽然会有较高的吞吐量，但是可能会造成线程饥饿」（这一点在讲AQS的时候已经说过了）

接着看入队的流程:该入队流程就是AQS的共享模式的入队(在这里不再赘述)

```plain
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

release(int arg)源码解析： 该方法的作用是释放一个许可证

```plain
public final boolean release(int arg) {
    if (tryRelease(arg)) { // 由子类实现,如果释放成功,那么唤醒,在AQS中讲述过对应的逻辑了,不再赘述
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

总结一下：Semaphore的实现很简单，它并不关心线程的读写操作,而是限制线程的数量，相当于ReentrantLock的升级版（但是锁强调的是**互斥**，而信号量强调的是**限流**）

## CountDownLatch
### 介绍
核心机制是一个计数器,允许一个或者多个线程等待，直到其他线程中执行的一组操作完成。 该计数器在初始化时被设置为count值 1.当线程调用await()时会阻塞当前线程,直到对应的count值为0 2.而count值的减少则是通过其他线程调用countDown()来完成的

类比：小县城做的大巴 以前我从家里座大巴车(不是那种公交车)去学校上学时,大巴车是按人数发车的,比如大巴车需要车上有10个人才会发车,在这里count = 10，司机会调用await()阻塞，因为count不为0，每上来一个乘客就调用一次countDown()来减少count的值，当满10人时(也即count = 0)的时,司机才会出发。

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2YwMzdkNzkzODVlMGEwMTQwODdjMDkxMDk2NWIxNTZfQXl6NExCc3RBbEx6a0tXS0pwNEFXZ3JDdlJRMmlaaWxfVG9rZW46UndLOWJ0Skl3b1U4bHN4NEQwS2N0TmoxblljXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

示例图

### 类关系图
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y0YTI0ZjQyMTc3ZDNlMDk5YzlmMmU3MTg0OTJkYWJfZmxZb3E5WVFJTWdqR1BVTExXVXUybDlzOHd6b0VldEdfVG9rZW46WnUzTmJnREZ0b0gxdkp4SXBscWNiZWdnbldjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 源码解析
讲述核心方法

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg2OWViMjlhZGExNWM0YWM1YzdhYzU4MTM0NGNkOTJfa2RpRzhRQnk1bGlYOExlZkdZblVSQXl6YVZRNWJ6RWRfVG9rZW46UFV2RGIyYlFnb2Mza3J4ZW5TUmNIcGRXbjJ0XzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



构造函数： 初始状态如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NzExZGY5ZWVlNGE4ZTc5NzA0ZTkzOTc3MWZhNzNjMjFfVUU2ZWZ6R3NMMU9YeUxncExIQW5ya2hrMzM0NzV1SVpfVG9rZW46V2dkYmJVQTVab2FlYXp4aHJUbGNFc2JibktoXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
public CountDownLatch(int count) {
   if (count < 0) throw new IllegalArgumentException("count < 0");
   this.sync = new Sync(count);
}
```

**await()源码解析：** 该方法的效果为:如果count不为0,那么阻塞等待直到count=0后被唤醒 该方法的源码实现很简单

```plain
public void await() throws InterruptedException {
   sync.acquireSharedInterruptibly(1);
}

public final void acquireSharedInterruptibly(int arg)
       throws InterruptedException {
   if (Thread.interrupted())
       throw new InterruptedException();
   if (tryAcquireShared(arg) < 0) // 如果该方法返回 -1,则进入到入队流程(阻塞)
       doAcquireSharedInterruptibly(arg); // 入队,AQS的入队流程,不再赘述
}

protected int tryAcquireShared(int acquires) {
  return (getState() == 0) ? 1 : -1;
}
```

countDown()源码解析: 该方法的效果为:如果count不为0,那么将其减1,如果减1后为0,那么唤醒因为调用await()而阻塞的线程 **如果count已经为0,那么调用该方法不会产生任何效果**

```plain
public void countDown() {
 sync.releaseShared(1);
}

public final boolean releaseShared(int arg) {
 if (tryReleaseShared(arg)) { // 调用子类的实现,若为true(count从非0 -> 0),则进入到唤醒逻辑
     doReleaseShared(); // 唤醒
     return true;
 }
 return false;
}

 protected boolean tryReleaseShared(int releases) {
     // Decrement count; signal when transition to zero
     for (;;) {
         int c = getState(); // 获取state的值
         if (c == 0) // 如果已经为0了,那么返回false,不需要唤醒,可以看到如果count已经为0,那么该方法不会产生任何效果
             return false;
         int nextc = c-1; //否则递减并且通过CAS更新值
         if (compareAndSetState(c, nextc))
             return nextc == 0; //返回更新后的count是否为0,如果为0则返回true,否则返回false
     }
 }
}
```

到这里CountDownLatch就介绍完毕了，代码逻辑和原理也都很简单。介绍几个适用场景： 1.主线程等待所有子线程完成任务后再继续执行下去 2.模拟并发测试：让多个线程在某个时刻同时开始执行,用来模拟高并发场景(**不太严谨**,因为唤醒是从队列头部开始的)

## CyclicBarrier
### 介绍：
循环屏障，允许多个线程**互相等待**,直到所有线程都到达一个共同的屏障点后,这些线程才会继续执行。 核心思想是：一组线程需要相互等待,直到整个组都准备好了后,再一起执行下一个步骤。 其与CountDownLatch在语义上的区别： CountDownLatch:一个/多个线程等待其他线程完成一组事件 CyclicBarrier:线程相互等待,到达屏障后一起继续往下执行 除此之外还有一个核心的区别就是：Cyclic「循环」,CountDownLatch是一次性的

核心原理如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDEyN2MxZGM2ZjA2MzczOGJiOGQ1YTIwZWNiMWUyZDRfakNBTVR2QW1qUkFPZUtoSk91WThKZzFCNWhBRHB3Y2tfVG9rZW46SWIzNmJYWko1b09wVnF4VTNhUGMzV0VPbnFkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 类关系图
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjcwOTNiMjJiODNkODAyZTEyYWZkNGQ4YmQyM2EzYWVfTjRERGNvdHIxeDBSZmdlNFhoNGkwTmxwNmVpNk5YdVFfVG9rZW46S3UwNWJCZTFJb0M1NGZ4d3hXM2NKT3pXbnFlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 源码解析
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTU0YTVjZDQ3MThkZTgwYmEzYTYzNWI0NzljZTk2NzVfU3Jjb05XQkhIcHRLd2FCWjNCaGlzMUJCUzZnY3U0dnNfVG9rZW46WlFXbmJFQUtyb00wRlh4c3BIc2N1NmQ0bk9nXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



**构造函数：** 初始状态如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZmYjAwODZlMWM0NmQzNDNjODIzNTBhMTUxZTkyNGFfUDFUeGlKQnBCUG50UWk1SlpFMlhqMmgxWVNxblhDdDlfVG9rZW46QWJhSGJ0TE5Gb3dJbXJ4c1NuWWNNaXhtbmNnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException(); // 要等待的线程数不能<= 0
        this.parties = parties; // 屏障要等待的线程数
        this.count = parties; // 保留parties,用于重复利用,因为上面的parties在每一个线程到的时候都需要递减
        this.barrierCommand = barrierAction; // 执行函数,当最后一个线程到达时执行的
}
```

**await():** 等待所有参与者都在此屏障上调用await

```plain
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}

// doWait()：核心方法
```

doWait()为核心方法,下面进行分析: 方法的大致原理：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM1MDNiM2U1YWYzNzYwNzE4Y2MxYWE5NTUzYmYyZWZfZ3Rsbm5URzRPa3FuS2FTWkNVRm1RS29NWVZ5dTB3a0pfVG9rZW46VHV3RGJxdDMxb0p2ZVV4eHRwWmNkdFdrbnZkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private int dowait(boolean timed, long nanos){
    final ReentrantLock lock = this.lock;
    lock.lock();
    // 上锁,也即下面的代码是单线程执行的
    // .... 代被破坏
    // .... 当前线程已经被中断
    int index = --count;
    if (index == 0){.....} // # 1 如果当前线程是屏障所要等待的最后一个线程,那么它应该负责唤醒其他阻塞的线程
    // # 2 否则当前线程不是最后一个线程,那么应该去阻塞
}
```

下面先看下当线程不是最后一个线程时的阻塞操作:目前只看阻塞操作,关于异常处理和其他处理后面再介绍, 此时的状态如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU0ZjAzOWQyNDBkNmEyZDUzYWEzZmEwNjRiNzk0MGNfb3J3V1VWRE9IanZ0dktURTdyTzNEUENwc1ZOd0pXVW1fVG9rZW46TGFLMGI4Y0FKb3pQTzF4QVViQWN4UXlLbnFiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
for (;;) {
    try {
        if (!timed)
            trip.await(); //阻塞
        else if (nanos > 0L)
            nanos = trip.awaitNanos(nanos);
    } catch (InterruptedException ie) {
        // 异常处理.....
    }

    // .....
    }
}
```

下面再看下当前线程为最后一个线程时的唤醒操作： 最后一个线程所执行的操作如下： 1.执行回调函数 2.唤醒之前阻塞的线程后 3.再去更新generation 这里有一个点需要额外的注意：那就是最后一个线程需要在唤醒了所有阻塞的线程后才会去生成下一代（新的generation）。 在这里需要回顾一下：条件变量唤醒后只是从等待队列中移入到同步队列中，还是需要竞争锁资源的。但是如果当前线程没有释放锁,那么这些线程是没法继续往下执行的。 所以这会造成一个什么样的现象呢？那就是当阻塞的线程获取锁后,它所处于的代和当前的代肯定是不同的

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODhhMzY4Njc1NWMyN2M4NGM5YjJmZmNmOTc3YWUxMjNfSDh5a1pMRWZiVTl3RUliWkFpdGl3UDl2NW9rUHlEWnFfVG9rZW46Q2hYcWI0QXk1b1JTeGZ4Z0ZvQ2MzNW56bmVnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWY1NmUxMTI2ZWU3YjBjNmJjZTBmMDI3MDZjYzNhZjdfR1JUNVJNRUdraDZBUWtWUFhsdTE4TmNUOEZYeEJscTFfVG9rZW46Q2I2Q2I3MVhKb1F6WFZ4dzlJb2NwRGtpbjNjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
int index = --count;
if (index == 0) {  // tripped 当前线程为最后一个线程,条件满足
    boolean ranAction = false; // 是否执行了回调函数
    try {
        final Runnable command = barrierCommand;
        if (command != null)
            command.run(); // 如果有回调函数,那么由最后一个线程执行
        ranAction = true; //标识回调函数执行完毕
        nextGeneration(); //进入到下一代
        return 0; //直接返回
    } finally {
        if (!ranAction)
            breakBarrier();
    }
}


// nextGeneration()
private void nextGeneration() {
    trip.signalAll(); // # 1 唤醒所有阻塞的线程
    count = parties;  // # 2 重置新的屏障计数器
    generation = new Generation(); // # 3 进入到下一代
}
```

下面看下当阻塞的线程获取锁成功后,继续往下执行的代码: 可以看到,其他线程是通过代（generation）的变化来判断是否可以通过屏障的

```plain
for (;;) {
    try {
        // await() 阻塞
    } catch (InterruptedException ie) {
       // 异常处理....
    }
    // 异常处理.....
    if (g != generation) // 如果g(这个g是每个线程局部保存的)!=generation(这个generation是全局的)
        return index; // 如果两者不同,那么说明当前已经进入到下一代了,当前线程和其他线程可以继续往下执行了,返回当前线程是第几个到达屏障的
    // 超时处理 ....
    }
}
```

下面再看下相关异常的处理：

```plain
private int dowait(boolean timed, long nanos){
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;
        // 为什么一进来就会存在broken的状态呢？
        if (g.broken)
            throw new BrokenBarrierException();
        // .... 
}
```

继续看下面这段代码： 如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NzIyZjNiOTEyMTE4NzI3ZmQ5MGI3OWVkNTczYzZkNzhfaUVCeFhFeVpOMUxnUnRQb0RnNm4wMDJ5ckdSWjltWVNfVG9rZW46TXI0WmJqb1Nhb3BQeTl4aTUxemN3WGVPbkhlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private int dowait(boolean timed, long nanos){
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;
        // 为什么一进来就会存在broken的状态呢？
        if (g.broken)
            throw new BrokenBarrierException();

        if (Thread.interrupted()) { // 如果线程已经被中断了,那么breakBarrier()「破坏屏障」
                breakBarrier();
                throw new InterruptedException(); // 并且抛出异常
        }
}

private void breakBarrier() {
    generation.broken = true; // 设置broken = true
    count = parties; // 重置count
    trip.signalAll(); // 并且唤醒之前所有阻塞的线程
}
```

下面继续看线程唤醒后异常处理（被中断）

```plain
for (;;) {
try {
    trip.await();
} catch (InterruptedException ie) { // 线程在等待过程中被中断
    if (g == generation && ! g.broken) { // 如果代没有改变并且没有被破坏,那么由当前线程进行破坏
        breakBarrier();
        throw ie;
    } else { // 否则当前代已经改变了,那么只是重置中断标志位而已
        Thread.currentThread().interrupt();
    }
}
```

这是什么意思？如下图1所示： 设计哲学： 1.永远由程序员来处理中断 2.中断处理和条件满足时机有关：如下图-2所示

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDZlZGE1ODcwMjVkYjQwYTY0MDAyOTQyYzc0MDE4NjRfcFRrVkw5a2JIejNwenZ5NDZHM3F3eTBtTWNvN0lmaHZfVG9rZW46SmJUNWJxTGtRb1JOSzd4U3VQOGNLeEpDbmdYXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

图-2





<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDljZWQzMDI0MThmZGE0ZjllYzYzNTQ0Zjk2YzU4ODRfVWFtZ1NOTmZaY3NtZEhnczIwbnk5ZkJQQWVSd1ZuTjlfVG9rZW46WFNsUWJyaXV2b01SSDh4cm42WWNvS0phbmJoXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

图-1

**reset():**

手动将屏障重置为初始化状态，代码很简单，不再赘述

```plain
public void reset() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        breakBarrier();   // break the current generation 破坏屏障
        nextGeneration(); // start a new generation 生成下一代
    } finally {
        lock.unlock();
    }
}
```

到这里CycliBarrier的介绍就到这里结束了,总结一下： 1.核心是线程相互等待，与CountDownLatch不同（它的核心是一个/一组线程等待其他线程） 2.CyclicBarrier是循环利用的(可以通过reset())，但是CDL则是一次性的 3.CB还有回调函数 4.Generation的概念

## Phaser
### 介绍
官网介绍如下：

一个可重用的同步屏障，功能上类似于CyclicBarrier和CountDownLatch，但支持更灵活的使用

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YTZlNGZjMGFhMTk0MTBkNzNlOGM2YTliNTllYjZkNTBfOWVWYmJTRTNRY09xdkdpWVExQmFRNkoxM3NyTWZFd01fVG9rZW46V05JcGJVbkxnb2dFVDF4SHVRa2NHV1ZYbkZjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



在讲这个类之前需要回顾一下CyclicBarrier和CountDownLatch这两个类的局限性： CountDownLatch:**不可重用**,一个/一组线程等待其他一组线程完成一次任务 CyclicBarrier:可重用，一组线程相互等待,到达屏障后一起执行,但**线程数量是固定的**。 而Phaser就解决了这两个局限性,并且更加的强大。

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RkZDdmYjRhNDg4OTIxNzZmYWJmZDRhMmQ5ODE5NzVfeEc2QWJJa2FpMlQ2SVUxUlN6MDJYNGh3TVZDU3pkdlNfVG9rZW46S3k3a2JOa0NWb3YxU3B4OVhrNmN6UlowbklmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 类关系图
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MWViMjFmYzgyY2U5OTQ2MmNjYzc5OWFjYmNmNWY2YWJfTHZTT1ljZmUyN0lpZlVQZGVVcTNLNER2WFF6elhTc1dfVG9rZW46VW1QcGIyNjlBb2FyU0x4ODJHWGNCWFJCbnZkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



先介绍其最为重要也最好理解的属性：state 在Phaser中state的不同位有不同的作用，如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NmY0OTZhZTliNzA2OWVlOTBjNTViNWFjYWI0NzU1OTNfY0haZk1NQzZuWkx6am9xVE1VVnNNdWxsUFh1c2tJVWZfVG9rZW46R0Zja2Jsemdyb2RLMVV4RFNZTGNSRDRqbjVvXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



从官网的介绍上来看,它的一般原理为：但是实际上更加的复杂和灵活

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QyMTUxYjg1NzhlNjJkNGI2ODIzZjgyYjg2MzM5Y2JfT0EyZVFsQTRvT0RCWEtNV1ZGRmZTTTFwUGR6Z2MyVWVfVG9rZW46QUpzTmJ3eFh1b0w2ajJ4OWhiUGNCOURzbnJmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 源码解析
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNhNmQzOTk0OGM3YWU0MmIwZDc2OTZiYWViMDQ2MTJfalplRlh3bWhOeUVTblhWT05IUkZsR3hTMjdaYm13OHpfVG9rZW46Vzk0bmJENjNHb2JLVGR4V3Q1ZGNnM0lVbmhmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



在下面的源码解析中,先忽略父子Phaser的情况

案例：假设有一个项目有三个核心阶段-设计，开发和测试,每个阶段都需要多名工程师（线程）写协作完成。只有所有参与的工程师完成了“设计”阶段,才能一起进入到"开发"阶段，测试阶段也是如此。并且在各个过程中,可以有已参加的工程师退出，也可以有新的工程师加入。这样的动态多线程多阶段的场景,使用Phaser就比较合适。

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQ5YWZiMTdlODU0ZDVjZGM2MzNhOTliYTdiNWVlZGRfTmhxMEVzMTJ4TGgyVU0ySnF2ZzMyRkkyOUxWT1RNRDdfVG9rZW46V1d4ZWJ2Z0dQb2pxVzR4VzhNZGMxcDd5bkZVXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
public class PhaserExample {

// 模拟一个项目任务
static class Engineer implements Runnable {
    private final String name;
    private final Phaser phaser;
    private final Random random = new Random();

    public Engineer(String name, Phaser phaser) {
        this.name = name;
        this.phaser = phaser;
        this.phaser.register(); // 注册到 Phaser
    }

    @Override
    public void run() {
        // 阶段 1：设计
        doPhaseWork("设计");
        phaser.arriveAndAwaitAdvance(); // 等待所有人完成设计

        // 阶段 2：开发
        doPhaseWork("开发");
        phaser.arriveAndAwaitAdvance(); // 等待所有人完成开发

        // 阶段 3：测试
        doPhaseWork("测试");
        phaser.arriveAndDeregister(); // 完成并注销自己
        System.out.println(name + "：所有工作完成，下班！");
    }

    private void doPhaseWork(String phaseName) {
        try {
            // 模拟工作耗时
            int time = random.nextInt(5) + 1;
            System.out.println(name + " 开始【" + phaseName + "】阶段，预计需要 " + time + " 秒。");
            Thread.sleep(time * 1000L);
            System.out.println(name + " 完成【" + phaseName + "】阶段。");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public static void main(String[] args) {
    // 创建一个 Phaser，初始参与方为 0（后面会动态注册）
    Phaser phaser = new Phaser();

    // 创建 3 个工程师线程
    for (int i = 1; i <= 3; i++) {
        new Thread(new Engineer("工程师-" + i, phaser)).start();
    }

    // 主线程等待所有阶段完成（可选）
    // 等待 Phaser 终止（当 onAdvance 返回 true 时）
    while (!phaser.isTerminated()) {
        int phase = phaser.getPhase();
        if (phase < 0) // 如果终止，getPhase() 返回负数
            break;
        System.out.println("主线程：当前阶段 [" + phase + "] 已完成，共 " + phaser.getRegisteredParties() + " 人参与。");
        // 等待当前阶段推进
        phaser.awaitAdvance(phase);
    }
    System.out.println("主线程：项目所有阶段已全部完成！");
}
}
```

+ **构造函数：**

构造函数主要完成了两件事情： 1.初始化双队列 核心思想:减少竞争,目前已经在doug lea的StampedLock(cowaiters,读写分离)，LongAdder(cells[]代替单个long)体现过了,在这里是为什么呢？

因为当线程没有完全到达时,提前到达的线程是需要阻塞的(一般情况下)，而当线程都到达后,则需要推进阶段,也即从N->N+1,同时需要唤醒N阶段阻塞的线程。而在N+1阶段可能有线程也提前到了,也需要阻塞,那么这就设计到一个问题了。N阶段的删除等待节点(唤醒线程) 和 N+1 阶段的添加等待节点(阻塞线程)如果只使用一个队列来处理，那么竞争必然是很大的。

那么可以使用2个队列，那么如何判断那个阶段使用那个队列呢？ --- 奇偶性 根据所处的阶段是奇数还是偶数来选择不同的队列。 N为奇数，那么选择奇队列，那么N+1一定是偶数，就使用偶队列，这样就把竞争分开了。提高了性能

**这个设计是非常巧妙的**

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YjAyMWU5MTI4NTFjYThhZGI4NjgwYzg3MTJlYThiZDNfYTR6V3dQOEZXRWxhRFRRR1RWczJDMGhRMDJ3T3laTWlfVG9rZW46T09FbmJ4UGx4bzRBV1d4OU5SNGNxYkM0bktlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



2.初始化state

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NzkxOThjYTZhYjljYmM5NTRlMmY3NTAzOWIwM2MxNzhfMWJwU3FJVVcxQlVWU256SU1pMW5BMWRXdzZ3Z2xqU0tfVG9rZW46U3YzcGJScUZSbzlWU3Z4SThZNmNlMUVabnplXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
public Phaser(Phaser parent, int parties) {
    if (parties >>> PARTIES_SHIFT != 0)
        throw new IllegalArgumentException("Illegal number of parties");
    int phase = 0;
    this.parent = parent; // 默认为null
    // 忽略parent不为空的代码逻辑.......
    else {
        this.root = this; // root = 自己
        this.evenQ = new AtomicReference<QNode>(); //初始化奇偶队列
        this.oddQ = new AtomicReference<QNode>();
    }
    this.state = (parties == 0) ? (long)EMPTY : //初始化state
        ((long)phase << PHASE_SHIFT) |
        ((long)parties << PARTIES_SHIFT) |
        ((long)parties);
}
```

+ register()/bulkRegister(int parties)

动态的注册要参与的线程数：这里分为了3种情况：目前只考虑两种 1.state = EMPTY,那么代表在创建phaser的时候没有传入参数，此时肯定没有线程到达,那么直接cas修改state的值即可 2.state!=EMPTY && parent == null:代表非首次注册,那么这个时候不能简单的cas修改state的值。原因如下： 这也很好理解：举个打游戏的例子 你和同学准备打LOL,这个时候来了另外一个同学说要加入你们，如果这个时候，你们还在排队中，那么肯定会回答：快来，马上就要开了（你们会选择等待）。 但是如果你们已经进入到游戏中了，那么肯定会回：来晚了,我们已经开了，下把吧

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI0YTdmNjhjMjIwN2ExNTFhYjFjNTIwNzM0NTgyNThfUEZjZXBudnpGekphTkVTOEt4UWg3eHc2QXlwYk9sN2xfVG9rZW46UHE5c2JURW03b3JFTTV4V1VzOWNNOUVSbnNoXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)







<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU1NzZlNWViYmRiNmEyNWRiMDI4ODhmNWRhMjQ1ZjNfSDA2S0VaNmRwbmxLYUdybWhWWGZ0SnQ3cmxzeWxybEdfVG9rZW46WFdQMWJEcVpTb2JuNUd4ZGZyQWM4SkZObjVlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private int doRegister(int registrations) {
    
    long adjust = ((long)registrations << PARTIES_SHIFT) | registrations;
    final Phaser parent = this.parent; // 默认为null,关于父子Phaser的源码暂时跳过
    int phase;
    for (;;) {
        long s = (parent == null) ? state : reconcileState();
        int counts = (int)s;
        int parties = counts >>> PARTIES_SHIFT;
        int unarrived = counts & UNARRIVED_MASK;
        if (registrations > MAX_PARTIES - parties)
            throw new IllegalStateException(badRegister(s));
        phase = (int)(s >>> PHASE_SHIFT);
        if (phase < 0)
            break;
         if (counts != EMPTY) {TODO} // state!=EMPTY
         else if (parent == null){TODO} // 
         else{// parent!=null的代码逻辑,暂时跳过} 
    }
}
```

下面先看属性的处理

```plain
// registrations 就是传入的注册线程数,必须大于0,否则抛出异常
long adjust = ((long)registrations << PARTIES_SHIFT) | registrations; // # 1 调整数
int phase;
long s = (parent == null) ? state : reconcileState(); // 获取当前state
int counts = (int)s;
int parties = counts >>> PARTIES_SHIFT; // 获取当前屏障需要等待的线程数
int unarrived = counts & UNARRIVED_MASK; //获取当前还没有到达的线程数
phase = (int)(s >>> PHASE_SHIFT); // 获取当前屏障所处的阶段
```

调整数含义如下：假设注册的线程为1,那么adjust值如下

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjUyZDllNGYyYWZhMjUxMDE5YTFiMTJiYjdjMDg3Y2ZfM3lzWUMxUXRzc1pjYUZUMkhoWlV2SDV6MklaRFhROHVfVG9rZW46QTlXd2JKWlN0b2xjTjJ4VWxIOWNVcDZMbkxkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



下面看下state == EMPTY的处理流程： 直接CAS增加state的值即可

```plain
else if (parent == null) {              // 1st root registration
    long next = ((long)phase << PHASE_SHIFT) | adjust;
    if (UNSAFE.compareAndSwapLong(this, stateOffset, s, next))
        break;
}
```

state!=EMPTY,并且parent == null： 代码逻辑很简单，这里引入了一个重要的方法：**internalAwaitAdvance():**&#x8BE5;方法的作用是让当前线程等待直到Phaser从指定阶段推进到下一个阶段(除非等待超时或者被中断),这个方法会被多个方法调用,后面再单独介绍

```plain
if (counts != EMPTY) {                  // not 1st registration 
    if (parent == null || reconcileState() == s) { // parent == null 
        // unarrived == 0,代表当前线程执行register时,上一个阶段的所有线程已经到达屏障了
        // 那么当前线程等待下一个阶段吧 
        if (unarrived == 0)             // wait out advance
            root.internalAwaitAdvance(phase, null);
        // 否则直接cas操作state变量即可（也即当前线程可以参与当前阶段）
        else if (UNSAFE.compareAndSwapLong(this, stateOffset,
                                           s, s + adjust))
            break;
    }
}
```

+ arriveAndAwaitAdvance()

这里只介绍该方法的原理

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=OGI2Y2Q1ZDAxYjhmNzAxMjM4YjNiMDg1YjQ1ZmMxOTBfUldwTWpwZTVQeXpFVzU0bTg0dHU4bTdLeXVhUjUwbGlfVG9rZW46RE5zQ2IyWG5Wb2JRbVN4aHBaWGNkMDI0bm9jXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



核心逻辑如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBhM2ZmNTNiZTkyN2MzYjFlZjVjMTMzMzY1YWI1MWVfaWFSS2V0RUVWMWdNSTJzUUd6VlZMbVU0d3lIRGZDZ2VfVG9rZW46RDFpVWJ0dWJ6b2lSMG54RmgzUWM1ZzFlbnZkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
public int arriveAndAwaitAdvance() {
    final Phaser root = this.root;
    for (;;) {
        long s = (root == this) ? state : reconcileState(); // 获取state变量
        int phase = (int)(s >>> PHASE_SHIFT); // 获取当前所处的阶段
        if (phase < 0) // 如果已经当前phaser已经终止,那么返回即可
            return phase;
        int counts = (int)s;
        int unarrived = (counts == EMPTY) ? 0 : (counts & UNARRIVED_MASK); // 获取当前未到达的线程数
        if (unarrived <= 0)
            throw new IllegalStateException(badArrive(s));

        if (UNSAFE.compareAndSwapLong(this, stateOffset, s, // CAS将state中的unarrived count - 1 (也就是低16位-1)
                                      s -= ONE_ARRIVAL)) {
            if (unarrived > 1) // 此时的unarrived的值是还未-1的值(如果>1,那么-1后还是>0的,也即当前线程不是最后一个参与者,那么调用internalAwaitAdvance镜像内部阻塞等待)
                return root.internalAwaitAdvance(phase, null);
            // 省略父子phaser的代码逻辑 .....

            // --- 走到这里说明,unarrived = 0 ,也即当前线程是最后一个参与者,那么需要负责唤醒当前阶段的阻塞线程(也即前面的参与者)

            long n = s & PARTIES_MASK;  // base of next state 获取下一阶段的参与者数量
            int nextUnarrived = (int)n >>> PARTIES_SHIFT; // 获取下一阶段的未到达的参与者数量(这两个局部变量是相同的)
            if (onAdvance(phase, nextUnarrived)) // 由最后一个线程执行当前阶段的回调函数,如果返回true,那么代表终止phaser,否则继续执行下去
                n |= TERMINATION_BIT;
            else if (nextUnarrived == 0) // 上面返回false,并且没有参与者了,那么重置state
                n |= EMPTY;
            else
                n |= nextUnarrived; // 否则设置下一个阶段的未到达线程数

            int nextPhase = (phase + 1) & MAX_PHASE; // 获取下一个阶段(0->1)
            n |= (long)nextPhase << PHASE_SHIFT; // 设置state所处的阶段
            if (!UNSAFE.compareAndSwapLong(this, stateOffset, s, n)) // cas设置state的值,失败的返回阶段数,成功的继续往下执行(唤醒线程)
                return (int)(state >>> PHASE_SHIFT); // terminated
            releaseWaiters(phase); // 唤醒,传入的是phase,是上一个阶段,实际state中的phaser已经是phaser + 1 了
            return nextPhase;
        }
    }
}
```

在这里涉及到两个重要的方法:

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=OGM3ZDIxZjg3NzdhNzM5OWU5N2MxNjg0MThhY2IwNmFfblkwNU03RXZxMTlDUVNzazdpdXZYQVhFSFRGUXdEeGlfVG9rZW46S1U2MmJzeExGb0pzZG54OHdld2NyTHpZbmdkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



先介绍一下internalAwaitAdvance(phase,null)方法：入参phase为当前阶段(假设为1)，那么需要**阻塞等待**阶段为2 一个线程要插入到队列中然后阻塞，应该怎么做？ 首先需要知道的是不管怎么样，一定要做的事情是：1.创建node节点 2.cas插入到队列中 3.阻塞 但是按照doug lea的代码风格，他会怎么做？ 1.一定是在一个死循环内部(for或者while) 2.一定是if -else if - else if --> 每完成一个小操作，就重新执行循环 3.再来点小优化 下面来看对应的代码：第一部分是一个自旋优化,为什么要自旋呢？要回答这个问题，首先要知道为什么要阻塞呢？--> 当然是因为当前线程不是最后一个线程「也即还有未到达的参与者线程」,那么如果此时又有参与者线程到了,那么是不是有概率：该参与者线程是最后一个参与者呢？那么我等一会，等待他推进阶段,那么我就可以不用去阻塞了。

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWEyMDJiOTVjYjc1ZGY5N2M3OWQxNDMzN2ViNDlmMDFfYmFaT1Vmb3R5akYwUm5JUmR6dmozT1RoOUZLWXNqY2FfVG9rZW46WG93dGJOeVczb2FsNUV4bjRzSWN1T2xkbktoXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
// 默认传入的node为null # 1 第一部分
private int internalAwaitAdvance(int phase, QNode node) {
     // 省略部分代码.....

     //确定当前线程所处的阶段没有发生改变(第一阶段：自旋优化，如果)
     while ((p = (int)((s = state) >>> PHASE_SHIFT)) == phase) {
      if (node == null) {           // node节点为空,第一次进来的时候都为空,自旋优化
            int unarrived = (int)s & UNARRIVED_MASK; // 获取新的unarrived(未到达的线程数)
            if (unarrived != lastUnarrived && // 如果和lastUnarrived不用,那么代表有新的线程到了,那么自旋等待
                (lastUnarrived = unarrived) < NCPU)
                spins += SPINS_PER_ARRIVAL; // 初始化自旋次数
            boolean interrupted = Thread.interrupted();

            if (interrupted || --spins < 0) { // 当spins < 0 后,那么没办法了,必须初始化线程节点了,因为我不可能无限等，不然自旋的代价就超过了上下文切换的代价了
                node = new QNode(this, phase, false, false, 0L);
                node.wasInterrupted = interrupted;
            }
        }
     }
}
```

下面继续看,经过自旋后,如果还没有等到其他线程参与者,那么没办法了,只能创建QNode,然后进入到队列中阻塞了,如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NzFjM2YzZjNmMWUzMmJjOTBmNmNhY2JkNjA5NDVmNDFfWVkydmFPVjRtamxFY2ZaZm1acFdhRE41UWFXaGM1ODdfVG9rZW46SzdFSmJWeTFTb2JVQ0F4UHdUOWNvYWZJbkNiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



接下来继续看入队的代码： 此时的状态如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY3NWFjZGIwYzRlY2IzM2EyNTgxYTI4YzE0OWY3NmFfSmd0Q0dMaFg5bngwUnNBWlFpWENQeTR3VnVuVVBMdVpfVG9rZW46Rk5KNGJ0Y1lLb01YcXB4NHozcmNyaDF0blRkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

入队

此时只是入队了，还没有阻塞,下一步就是阻塞了

```plain
else if (!queued) {           // push onto queue
    AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ; // 根据当前线程所处的阶段,选择要插入的队列(奇偶队列)
    QNode q = node.next = head.get();
    if ((q == null ||  // 队列为空,那么直接cas插入即可
           // double check 避免phaser已经被改变,但是依旧入队
        q.phase == phase) && // 否则,队列不为空，那么需要继续判断当前节点所在的阶段和队列中的节点是否相同
        (int)(state >>> PHASE_SHIFT) == phase) // 并且需要继续判断阶段没有被推进(被推进了就不需要阻塞了)
        queued = head.compareAndSet(q, node); // 满足上面的条件则会去阻塞
}
```

继续看阻塞的代码:

```plain
ForkJoinPool.managedBlock(node);
public static void managedBlock(ManagedBlocker blocker)
    throws InterruptedException {
  // .... 省略和ForkJoin相关的代码
    else {
        do {} while (!blocker.isReleasable() && // 在阻塞前再次判断当前phaser的阶段是否推进,返回false -> true进入到阻塞阶段
                     !blocker.block()); // 否则还是没有推进,那么阻塞
    }
}

public boolean block() {
    if (isReleasable()) // 再次判断阶段是否推进
        return true;
    else if (!timed) 
        LockSupport.park(this); // 永久阻塞
    // 超时阻塞.......
    return isReleasable(); // 返回阶段是否推进
}
}
```

上面已经介绍了参与者线程的自旋优化,创建QNode，插入到对应的奇偶队列中，并且阻塞的操作。 下面再看下最后一个参与者线程唤醒其他线程的代码操作：releaseWaiters(phase) 此时的状态如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjdhYzdlNWYyYzE5MThjMzE0ZjI3ZjYwZGQ0MTllZDBfMEJHZWZwdGJWaHhWN0JrN1FkV3JhR01XZ0RLbVQxdFBfVG9rZW46RXp3NWJ6enNsb0VmMXh4V1l5bWNFVWxzbnpiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YTVkNDU3NzljMDU3MWE5OWJmY2U1ZTBlMGI5ODNlOTdfM25GWGpXWExHZjFjM2dVSmJ4bGRTaXFON0daNGNqTk1fVG9rZW46UXpYWWJSTG9ObzQxaW94TDhHQWN5SGZ0blVlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)

t-3执行唤醒操作

```plain
private void releaseWaiters(int phase) {
    QNode q;   // first element of queue
    Thread t;  // its thread
    AtomicReference<QNode> head = (phase & 1) == 0 ? evenQ : oddQ; // 获取对应的队列头阶段
    while ((q = head.get()) != null && // QNode通常来说不会为空
           q.phase != (int)(root.state >>> PHASE_SHIFT)) { // 节点的所处的phase和当前state所处的phase应该不一样(只有phase被推进了才应该被唤醒)
        if (head.compareAndSet(q, q.next) && // 那么cas设置头部为下一个next
            (t = q.thread) != null) { 
            q.thread = null; // 清理thread引用
            LockSupport.unpark(t); // 唤醒
        }
    }
}
```

下面看下线程被唤醒后的操作:

```plain
// 这个分支是异常分支....,通常不是因为phase被推进被唤醒的
if (node != null) { 
    if (node.thread != null) 
        node.thread = null;      
    if (node.wasInterrupted && !node.interruptible)
        Thread.currentThread().interrupt();
    if (p == phase && (p = (int)(state >>> PHASE_SHIFT)) == phase)
        return abortWait(phase); // possibly clean up on abort
}

// 帮助最后一个参与者线程唤醒其他线程
releaseWaiters(phase);
// 返回当前线程所出的阶段
return p;
```

到这里关于Phaser的核心原理就介绍到这里了。 总结一下核心要点： 1.相比于CountDownLatch的不可重用 和 CyclicBarrier的线程固定问题,Phaser都解决了 2.将state分为4个部分：终止 - 阶段 - 参与者数量 - 未到达数量 3.**使用奇偶队列来分散竞争，提高性能**

## Exchanger
### 介绍：
类名：交换 是一个用于线程间协作的工具类。它提供了一个同步点,两个线程可以**交换彼此**的数据。 也即一个线程调用exchange()方法后,它必须等待另外一个线程也调用同一个exchanger对象的exchange()方法。 当两个线程都到达后，它们会交换彼此的数据,然后返回继续执行。

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQxZTUwYjY5ZWQxYWU3N2M3ZWE5MmUxN2ViY2Y1ZThfSENNWFlESzQ1TkZRODhYMHFWd1VERUhXZWxiVE5UREZfVG9rZW46WUlZcWJqZFRybzgwQ1F4SEhFb2NUUjN0bkRiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



相当于交易：一手交钱,一手交货。注意,这里和另外一种模式不同 -> 以送外卖为例,外卖员到了指定地点后,通常会将外卖放到某个地方后就走了，然后你去指定的位置拿就可以了(他不要求外卖员必须等待「当然也可以等待」)

### 类关系图
Participant这个类,是一个ThreadLocal的,为什么在这里会用到这种类型的类呢？ 在之前看的类中,只有ReentrantReadWriteLock使用到了这种类型：因为它有这个需求,为了支持读锁的可重入,每个线程需要记录自己加了多少次读锁。 那么在这里是为什么呢？

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNhMTZiMmJkM2JjYWQ4NjVkNDg4ZDQxZWE5Y2JhY2RfcjM1YUZIQ1JESTAzekVCSDNVWVFDN3ZpWnhMc2o4Z2RfVG9rZW46WU9PWWJlTndMb1FFMFd4eFZ4eGNPd0p6bjBmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



### 源码解析：
<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjVkMTUxZWQ0NGE5ZGQ5YjEzODYyNTU3YzQ4YzZiY2RfSGJWNm1pTlFDbWE0NDREMmlhN3RUdEFMcVlkMU9PN21fVG9rZW46WVRFeWI1TVR6bzR0QW14a3F5cmN3MnpkbmVjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



+ 构造函数：

```plain
// 构造函数只是初始化了一个Participant对象,这是一个threadLocal对象
public Exchanger() {
   participant = new Participant();
}
```

+ exchange()

一个简单的例子：

```plain
public static Exchanger<String> exchanger = new Exchanger<>();
    public static void main(String[] args) {
        // 线程A：发送一条消息，并等待接收回复
        new Thread(() -> {
            try {
                String dataToSend = "Hello from Thread-A";
                System.out.println("Thread A is sending: " + dataToSend);
                // 等待与线程B交换
                String receivedData = exchanger.exchange(dataToSend);
                System.out.println("Thread A received: " + receivedData);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Thread-A").start();

        // 线程B：发送一条消息，并等待接收回复
        new Thread(() -> {
            try {
                String dataToSend = "Hello from Thread-B";
                System.out.println("Thread B is sending: " + dataToSend);
                // 等待与线程A交换
                String receivedData = exchanger.exchange(dataToSend);
                System.out.println("Thread B received: " + receivedData);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Thread-B").start();
}
// 执行结果
Thread A is sending: Hello from Thread-A
Thread B is sending: Hello from Thread-B
Thread B received: Hello from Thread-A
Thread A received: Hello from Thread-B
```

源码分析：

想一下,要实现上面介绍的这种功能,最简单的方法是什么？ 有一个容器,当线程调用exchange()的时候,发现该容器为空,那么就将数据放进去,然后阻塞等待。 如果容器不为空，那么交换数据,然后唤醒对应阻塞的线程即可，基本原理如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NGI3OGEyYzA0ZTExZGU2YjZhMzA2ZTA0ZmYxMjEzMjlfdHdWTWViV0p0MDJjZTNFRm1XM05uUmdycGtDZzBqdmNfVG9rZW46QWRyNmJKc1h2b3JLOUh4clNIM2NEdThNbjNkXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



但是有一个问题：多个线程同时调用exchange()会怎么办？它们都认为容器为空,然后想要把数据放进去,当然最终只能有一个线程放进去,那么剩下的线程应该怎么办呢？ 所以在这里,doug lea 采用了和LongAdder一样的设计思想： 1.将竞争分散,也即使用数组来作为容器 2.当没有竞争时,使用单个容器,否则使用数组 下面进入到代码中： 从这里可以引入两个核心的方法：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODcxMzgzOGY5MTU2MTBhNjUwOGQ2ZTM4Y2YzZTgyYTlfWkRxTGt3M1hqbHpLZG9DdEJQNm15dTdSajR5bHpRcnZfVG9rZW46S3gwOGJsMk12b2tKNjF4bVpPM2NDZklJbjRjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
/*
   private volatile Node[] arena; // 数组,当发生竞争时使用
    private volatile Node slot; //单节点,当没有竞争时使用
*/
public V exchange(V x) throws InterruptedException {
Object v;
Object item = (x == null) ? NULL_ITEM : x; // 确保要交换的数据不为空,如果为空的话,会在这里替换为NULL_ITEM(实际上是一个Object对象)
if ((arena != null || // 当没有竞争时,arena是为空,先不考虑竞争
     (v = slotExchange(item, false, 0L)) == null) && // 调用slotExchange()来进行数据交换
    ((Thread.interrupted() || // disambiguates null return
      (v = arenaExchange(item, false, 0L)) == null)))
    throw new InterruptedException();
return (v == NULL_ITEM) ? null : (V)v;
}
```

先看没有发生竞争时的方法：slotExchange() 先看第一行代码：participant.get(),participant是一个threadLocal类型的对象,并且返回的是Node对象,这说明什么？ **每个线程会复用Node节点。这在之前学习过的类中都没有出现过,这样做的目的是为了避免频繁的创建Node对象！**

```plain
private final Object slotExchange(Object item, boolean timed, long ns) {
        // 调用get()时,如果是第一次,那么会调用initialValue()进行初始化
        Node p = participant.get();
        // ..... 先省略其他代码
}
```

继续看后续的代码：# 3的逻辑很简单，结果如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE3YTc2NDJiZjY4NmZmN2MxNDJhNmNlNzNkMGQ4ODlfenB5anBHOElCU1ltRkxHb1VkSm9GeHoyN3gwaXhmS0JfVG9rZW46UG5za2JFUjRxb2dra1F4ZkJLd2NIUjBWbjFiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private final Object slotExchange(Object item, boolean timed, long ns) {
     Node p = participant.get();
        // 省略中断相关的代码
     for (Node q;;) {
            if ((q = slot) != null) {TODO} // 如果slot不为空,默认都是为空的
            else if (arena != null) {TODO} // 否则slot = null && arena != null (理论上不会发生,因为如果arena!=null,那么应该会进入到arenaExchange()方法中)
            else {TODO} // # 3 线程第一次通常是进入到这个分支
 }

// # 3 
 else { 
      p.item = item; // 赋值item
      if (U.compareAndSwapObject(this, SLOT, null, p)) // cas设置exchanger中的slot,如果成功,那么直接break了
           break;
      p.item = null;
}
```

当创建完节点后，下一步就应该是阻塞了,当然按照doug lea的风格 - - 自旋优化是少不了的， 但是关键点在于park()阻塞

```plain
int h = p.hash; // 节点的"hash"值,用来计算自旋次数的
 int spins = (NCPU > 1) ? SPINS : 1; // 自旋次数:默认是1024次(非单核)
 Object v;
 while ((v = p.match) == null) { // 如果没有被其他线程匹配
     if (spins > 0) {
         h ^= h << 1; h ^= h >>> 3; h ^= h << 10;
         if (h == 0) // 第一次都为0,那么在这里初始化hash值
             h = SPINS | (int)t.getId();
         else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0) // 适当yield(),让自旋了512次(512的倍数)后,还是没有被匹配,那么释放时间片(并没有阻塞!)
             Thread.yield();
     }
     else if (slot != p) // 否则走到这里,说明自旋次数已经使用完了,并且 exchanger中的slot和当前节点不一致(但是match又为空),这说明当前节点已经被匹配了,
                         // 不过还没有被设置match而已(匹配它的线程会给设置对应的match),那么不应该阻塞,而是再次自旋
         spins = SPINS;

     else if (!t.isInterrupted() && arena == null &&
              (!timed || (ns = end - System.nanoTime()) > 0L)) { // 否则阻塞
         U.putObject(t, BLOCKER, this); 
         p.parked = t; // 将被阻塞的线程记录在节点中
         if (slot == p) //double check 确定应该阻塞
             U.park(false, ns);  // 阻塞
              // 下面是唤醒后的操作
         p.parked = null;
         U.putObject(t, BLOCKER, null);
     }
     else if (U.compareAndSwapObject(this, SLOT, p, null)) { // 否则,无法继续等待了「线程中断 / arena启用 / 超时」，那么将slot设置为空
         v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;
         break;
     }
 }
```

下面看下,另外一个线程匹配的操作,也在这个方法中：此时的状态如下图所示：当匹配线程进来时,会发现此时的slot已经不为空了,那么应该怎么做呢？ 1.将slot设置为空（因为slot不为空，代表已经有线程在等待被匹配了） 2.交换数据 3.唤醒等待的线程 下面继续看代码：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1OTU0YzNmMWM3MDBiNTU0ZDg0OGYyM2M4NGU5Nzhfcm11SXhscklEZkFsMjB6QUxUM1lMRU1ybnZmNlRvaEZfVG9rZW46WmgxZ2JCNG5Xb1ZKQld4dUZmdWNxS0xlbk9lXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private final Object slotExchange(Object item, boolean timed, long ns) {
       // 首先也是通过threadLocal获取对应的Node
       Node p = participant.get();
       // 省略中断相关的.......
       for (Node q;;) {
              if ((q = slot) != null) { // 匹配线程看到的slot是不为空的
                     if (U.compareAndSwapObject(this, SLOT, q, null)) { // cas将exchanger中的slot设置为空
                           Object v = q.item; // 获取slot中的数据(也即等待线程的数据)
                           q.match = item; // 将当前匹配线程的数据赋值给q的match属性 「上面两行代码就已经完成了数据交换了」
                           Thread w = q.parked; // 获取阻塞线程并且唤醒,当前匹配线程
                           if (w != null)
                               U.unpark(w);
                           return v;
                     }
                     // 如果上面的cas失败,那么就代表出现了竞争,那么在这里准备初始化arena[]数组
                     if (NCPU > 1 && bound == 0 && //  bound == 0 必须为0才代表数组还没有初始化
                           U.compareAndSwapInt(this, BOUND, 0, SEQ)) // 将bound 初始化为SEQ(256)
                           arena = new Node[(FULL + 2) << ASHIFT]; // 初始化arena数组（大小为FULL + 2) << ASHIFT）
              }
       }
}
```

代码比较简单,基本原理如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQwOGU2ZmI0NGNmNzgwNDBiYTU4MDgyYzMzZjIwMmJfajdob1M0RzFsWlVvNmFLcHFEV1dDSGNtSXZUN3Bwc1JfVG9rZW46TWR6UWJ4Ulh4b3U5RE14QkdOb2NpSllWbk9lXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



但是这里如果cas设置slot为空失败了,那么就代表存在竞争,此时需要初始化arena(第一次是初始化,后续是直接操作arena),在这里说明一下数组的长度：(FULL+2)<<ASHIFT

```plain
private static final int ASHIFT = 7;
private static final int MMASK = 0xff; // 255
private static final int NCPU = Runtime.getRuntime().availableProcessors();
/*
   这是什么意思？NCPU >= 510 -> 一般CPU核心数不会大于510(还没见过)
   所以FULL一般会是等于NCPU >>> 1,也即cpu核心数 / 2, 假设核心数为4,那么在这里就是 2
   一般不都是核心数 * 2吗? 为什么这里是 核心数 / 2呢？
   因为在Exchanger类中，是每两个线程共用一个arena[x]
*/
static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1; 

所以在这里最终的arena[]的长度就是 (核心数 / 2 + 2) * 128

1.在这里为什么要+2呢？理论上 (核心数 / 2 ) * 128 就已经能够容纳下所有的线程了 
 「ps：文档注释中有,暂时不讨论，主要还是为了性能」
2.为什么要*128呢？
   - 解决伪共享问题
```

假设核心数为4,那么在这里数组的长度就为 (4 / 2 + 2 ) * 128 ,如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE0ZjAxNzI5ZGM1MDFmM2QxMjdlOGE1ODY2MDQ2MzRfQXR4T2NXbzdPSnNMdmx6NHowYm1YbGNGWjFPbGVERVRfVG9rZW46VWpHN2JPS2VKb2Y5N0h4aVRJVmN3RGVobnJlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



到这里关于单个slot的匹配操作已经介绍的差不多了。下面再介绍一下关于arena[]的相关操作,此时的结构如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQyYTU0YWYxYWQ0ZTljNTc0NmVmZjhlNTYxNjYwZGRfRG42U1NvenM4YVowdlFlak9lWnhEcmtKRGxoR1laTU5fVG9rZW46U2VYNWJoV3RSbzdRWGx4cHc0dGM1Rnl2bkpmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



+ arenaExchange(Object item, boolean timed, long ns):不考虑超时相关的代码

在看代码之前,首先需要回答的是：每个线程应该要被路由到那个节点呢？能不能想LongAdder一样,采用hash算法呢？ -- 当然是不行的，因为hash算法是随机的,但是在这里*128的目的就是为了避免伪共享。 所以在这里默认所有的线程都是从0开始(并且通过线程节点中的index属性来记录)

```plain
private final Object arenaExchange(Object item, boolean timed, long ns) {
        Node[] a = arena; // 获取arena
        Node p = participant.get(); // 获取线程对应的Node节点
        for (int i = p.index;;) {          
              int b, m, c; long j;  
              Node q = (Node)U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE); // 获取线程下标j 在arena[j]中的 Node(可能为空,可能不为空),并且所有的线程初始的index都为0
              if (q != null && U.compareAndSwapObject(a, j, q, null)){todo} // # 1 如果对应的node不为空,那么cas尝试拿到交换的资格 - 然后进行下一步
              else if (i <= (m = (b = bound) & MMASK) && q == null){todo} // # 2 否则对应的node为空,并且当前线程所对应的index在bound之内(bound初始值为256,它被分为了2个部分)
              else{todo} // # 3 否则当前线程所对应的index超过了bound,那么需要进一步处理
}
```

在上面的分支中，其中最难理解的就是#3分支,在这里先介绍一下#1和#2分支的原理

当线程对应的下标index在arena[index]中有存在的node时,这意味着什么？这说明已经有线程调用过exchange()再等待匹配了,那么当前线程直接去匹配即可。代码如下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZhN2IzNjlhZDk3YTViYWMzYmRjOTc4ZDlhNTE1NWVfWk94RUd5UFM0cXlUR3h3TExoN0dGdXJibW12aXNzS25fVG9rZW46V1pHQWJUMDdjb1d4dVh4d0M2ZWNvZE5ObmZiXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
if (q != null && U.compareAndSwapObject(a, j, q, null)) { // q代表的是arena[index]对应的node节点,cas将该位置设置为null
         Object v = q.item;   // 获取等待线程的item(数据)
         q.match = item; // 设置等待线程的match为当前线程(匹配线程)的item
         Thread w = q.parked; // 获取阻塞线程对象,然后唤醒即可
         if (w != null)
             U.unpark(w);
         return v;
}
```

下面看#2场景,也就是对应的arena[index]为空的情况下,核心原理：当前线程需要把node节点填入到arena[]中,然后再去阻塞。当前线程cas成功后的状态如下：**默认都是在第一个槽位**

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NTcwZGU5NzQ3MjFjNDBiYzdmMGQ0Y2IyMzg4NTk4YTVfUGlseWZhU1psdTA2a0p1TUw1cFFLZzJCNUNrZG9pZVdfVG9rZW46VXlpbmJhZVFyb3RMZEF4UGlVUGNQV3E0bmxmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
else if (i <= (m = (b = bound) & MMASK) && q == null) {  // 这个分支的目的是将当前线程对应的node节点,填入到arena[index]中
         p.item = item;                         // p是当前线程对应的节点,保存要交换的数据
         if (U.compareAndSwapObject(a, j, null, p)) { // cas将p(当前线程对应的节点)填入到arena[index/j]中,如果成功了,继续执行,否则清理item,重新循环,这代表发生了竞争
             TODO
         }
         else
             p.item = null;                     // clear offer 清理数据,然后重新循环
}
```

下面继续看cas成功后的处理：在这里会涉及到一个很重要的属性：**bound**

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZiMDlhMTA2Y2Q5NjhiZmMyZTQxZTg4ZDI3OGI3OTBfTzRacjBMQndqT3kzcm96RzdydGFNM2FLbGxuR0FtSVRfVG9rZW46WkdkdGJSUDdlb3VnV3F4ZnFVc2NIN3o3bmZjXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



下面的代码的核心原理：自旋优化 + 线程阻塞(最终)

```plain
// 这里的bound在产生竞争的时候会被初始化为256,而MMASK = 255(0xff) (bound & MMASK 的目的是为了取bound的低8位)「低8位存储的是arena的索引信息,高24位存储的是版本号」
 // 所以在这里初始时arena[]的有效索引就是为0(256 & 255 = 0) : 并且线程在arena[]中的索引默认初始时也为0
else if (i <= (m = (b = bound) & MMASK) && q == null) {  // 这个分支的目的是将当前线程对应的node节点,填入到arena[index]中
         p.item = item;                         // p是当前线程对应的节点,保存要交换的数据
         if (U.compareAndSwapObject(a, j, null, p)) { // cas将p(当前线程对应的节点)填入到arena[index/j]中,如果成功了,继续执行,否则清理item,重新循环,这代表发生了竞争
             
             Thread t = Thread.currentThread(); // wait
             for (int h = p.hash, spins = SPINS;;) { hash是用来计算自旋次数的,通常第一次都为0
                 Object v = p.match;  // 当前节点的match,通常都为null(因为没有被匹配才需要阻塞)
                 if (v != null) { // 但是在上面已经cas成功放到arena[j]上去了,那么其他线程就能看到,就能进行交换,所以在这里check一次,看下有没有被匹配,如果有那么直接清理数据,然后返回即可
                     U.putOrderedObject(p, MATCH, null);
                     p.item = null;             // clear for next use
                     p.hash = h;
                     return v;
                 }
                 else if (spins > 0) { // 自旋处理,在slotExchange()中讲述过,不再赘述
                     h ^= h << 1; h ^= h >>> 3; h ^= h << 10; // xorshift
                     if (h == 0)                // initialize hash
                         h = SPINS | (int)t.getId();
                     else if (h < 0 &&          // approx 50% true
                              (--spins & ((SPINS >>> 1) - 1)) == 0)
                         Thread.yield();        // two yields per wait
                 }
                 else if (U.getObjectVolatile(a, j) != p) // 已经被匹配,在slotExchange()中讲述过,不再赘述
                     spins = SPINS;       // releaser hasn't set match yet 
                 else if (!t.isInterrupted() && m == 0 && // 这里的m为什么一定要为0呢？「也即arena[]的有效索引要为0」才会进入这个分支,也即去阻塞
                          (!timed ||
                           (ns = end - System.nanoTime()) > 0L)) {
                     U.putObject(t, BLOCKER, this); // emulate LockSupport
                     p.parked = t;              // minimize window
                     if (U.getObjectVolatile(a, j) == p)
                         U.park(false, ns);
                     p.parked = null;
                     U.putObject(t, BLOCKER, null);
                 }
                 // ... 暂时省略这个分支的代码....
                 else if (U.getObjectVolatile(a, j) == p && 
                          U.compareAndSwapObject(a, j, p, null)) {TODO}
```

此时再回头看下arenaExchange()方法: 重点看第三个分支： 当线程对应的节点对应的index(初始默认为0)在arena[index]中不为空（这代表已经有线程在等待匹配了），那么当前线程尝试匹配(cas),但是cas只能允许一个线程成功,那么失败的线程就会进入到第三个分支：_也即节点不为空,但是cas失败_

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFkNTAyZDA0MjFmZmU3MzVmYjFlYjZjYTJlNmIzOTBfMk9BWGtTRmIzeEZCa3kwMGx4YWtpYVJiSlJQV1Q3UlRfVG9rZW46RHd6Q2JNTXZqbzdOSDZ4bkFoWmNMSXVkbnRnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM4ZDA5ZTJlYWJiNGEzNDZmOTAyOTBkZjllZjVlZjdfSUdpcmlwcG1HSU9Ea3BTMWFjSTVJN1FjTHdvQ09XSmJfVG9rZW46SE5maGJJR2pqb3B3SFh4em9rMGNpbllZbjcwXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
private final Object arenaExchange(Object item, boolean timed, long ns) {
        Node[] a = arena; // 获取arena
        Node p = participant.get(); // 获取线程对应的Node节点
        for (int i = p.index;;) {          
              int b, m, c; long j;  
              Node q = (Node)U.getObjectVolatile(a, j = (i << ASHIFT) + ABASE); // 获取线程下标j 在arena[j]中的 Node(可能为空,可能不为空),并且所有的线程初始的index都为0
              if (q != null && U.compareAndSwapObject(a, j, q, null)){todo} // # 1 如果对应的node不为空,那么cas尝试拿到交换的资格 - 然后进行下一步
              else if (i <= (m = (b = bound) & MMASK) && q == null){todo} // # 2 否则对应的node为空,并且当前线程所对应的index在bound之内(bound初始值为256,它被分为了2个部分)
              else{todo} // # 3 否则当前线程所对应的index超过了bound,那么需要进一步处理
}
```

分支3:如果按照正常想法,arean[]是一个数组,它的目的就是在竞争的时候能够分散,所以下一步它应该就是要去另外一个槽位去操作,但是要直接去下一个槽位吗？在这里的场景是：当前线程想要在arena[index]槽位上匹配,但是竞争失败了,这说明什么？-- 当前槽位很可能是空的(因为匹配成功会将该槽位设置为空) 那么当前线程的角色变为什么了？ -- 就变成待匹配的了,直接把自己放进去就行,所以在这里会再给当前线程一次机会

```plain
else {
    /*
       当前节点的bound是否和exchanger中的bound不一致？
       每个线程节点的bound默认值都为0,全局bound默认为256(产生竞争后的默认值),所以在这里肯定是不相等的,
       所以这个分支第一次都会命中
    */
    if (p.bound != b) {                    // stale; reset 
        p.bound = b; // 设置到节点的bound属性中
        p.collides = 0; //重置发生竞争的次数
        i = (i != m || m == 0) ? m : m - 1; // 在这里 m == 0, 所以 i = 0
    }
// ... 省略代码
        p.index = i; // 当前节点依旧处于arena[0]下标
}
```

然后重新循环,理想情况下,当前线程应该会阻塞arena[0],然后等待其他匹配线程唤醒。但是在高并发场景下,当前线程可能得到结果依旧是：arena[0]!=null && cas匹配失败，那么又会再次进入到分支3，此时p.bound和全局bound就是一致的了。那么就会进入到下面的分支中:此时的bound 还是 256，m还是0

```plain
else if ((c = p.collides) < m || // 线程产生的竞争次数 < 最大索引 
          m == FULL ||   // 最大索引范围已经到达最大容量
         !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) { //  在这里cas将全局bound加上SEQ+1,如果成功,那么执行最后的p.index = i - 前提是前面两个都为false,才会走到这一步
    p.collides = c + 1;                 // 否则代表出现了竞争,在这里将线程节点的collides属性+1
    i = (i == 0) ? m : i - 1;          // cyclically traverse 唤醒处理,如果当前线程处理的下标是0,那么就跳转到m(最大索引),否则向前移动一位
}
```

针对前面两个分支不太容易理解,画图解释一下：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjlhMmJjNDJjZjk1ODFmYWVmZGVlNTBlNGQ0ZDYxZjlfTUJXNVd6a3dlN0hWZnl2bWkzdkpVUmlCSU9ycW8xZlJfVG9rZW46TGZoSWI4UVg4b0dnd2t4T3gwWWNWcU5XbjNmXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
p.collides = c + 1;       // 将线程节点的竞争次数+1            
 i = (i == 0) ? m : i - 1;  // 设置线程下次操作的数组下标(如果i=0,那么设置为m,否则设置为i-1)
```

针对第一种情况：i下一次就是1 针对第二种情况：i下一次就是2

但是还有第三种情况,如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NTAyNTQ5MzI4NmUyN2Q4OWVmNjUxMTk4ZTU1MTI3YmNfd0JyN2xCeEV1bEQ3Q2pCUFZPcDlsRDBBRnNNbGh5TTZfVG9rZW46VGs3UmJUZWJsb1pTS2l4clkxWWNFY1IwbnZoXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



而这第三种情况就是通过cas设置bound的值来完成的,如下图所示：此时线程能够操作的下标值就不是0了，而是0和1了

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM2ZjdjYzc2NzQ0N2FkOWI1ODg0YTJhNDQ3Mzk4MTNfdWdWRXVSZEhCSk9SY0oxd0lHNWtuMUQ5QTduajdEeUtfVG9rZW46Rk9qa2JNemFlb2o4OFN4c3RwQ2M3dDdrbnVnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
else if ((c = p.collides) < m || // 线程产生的竞争次数 < 最大索引 
          m == FULL ||   // 索引已经到达最大容量
         !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) { //  在这里cas将全局bound加上SEQ+1,如果成功,那么执行最后的p.index = i - 前提是前面两个都为false,才会走到这一步
    p.collides = c + 1;                 // 否则代表出现了竞争,在这里将线程节点的collides属性+1
    i = (i == 0) ? m : i - 1;          // cyclically traverse 唤醒处理,如果当前线程处理的下标是0,那么就跳转到m(最大索引),否则向前移动一位
}
```

最后一种情况为线程竞争次数大于m，m又没有到达最大范围，但是cas设置bound失败了,那么进入到分支内部：

```plain
p.collides = c + 1;       // 将线程节点的竞争次数+1            
 i = (i == 0) ? m : i - 1;  // 设置线程下次操作的数组下标(如果i=0,那么设置为m,否则设置为i-1)
```

那么cas成功的线程下面应该做什么呢？很简单，因为该线程就是因为产生了竞争,所以才扩大索引范围（m的值），既然在这里我扩大成功了，那么我去操作这个位置不就可以了吗

```plain
else
   i = m + 1;   // 这里的m是旧值,+1就是新的下标位置了
p.index = i;
```

此时再来解释一下下面的代码：

```plain
// 这里的m为什么一定要为0才会去阻塞呢？因为如果m不为0,那么代表最大索引不为0
// 那么说明有线程产生了冲突 -> 才会去扩大m的范围 -> 那么就很有可能在非0下标位置上有线程在等待匹配
// 如果这里没有这个m == 0的判断,因为所有的线程初始时都是尝试index = 0这个位置
// 而产生冲突线程则每次都是从index位置(非0)开始尝试,这会造成一个什么样的现象？
// 那么在极端情况下可能会导致后续的线程永远无法被匹配,如下图所示:
else if (i <= (m = (b = bound) & MMASK) && q == null) {
   // ... 省略代码
   else if (!t.isInterrupted() && m == 0 && // 这里的m为什么一定要为0呢？「也即arena[]的有效索引要为0」才会进入这个分支,也即去阻塞
                          (!timed ||
                           (ns = end - System.nanoTime()) > 0L)) {
}
```

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA0ZDdmZWM3ODI2YmVmN2JjMmVmNmUzMjA0YTJmMTNfUnBOa0JMckE5NjkwSjE1Z3RMVDlSUzZwc3F6UVp4WU9fVG9rZW46TW4xbmJhdFRBb0U0M3B4dEdTcWNnZk1QblNlXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



下面继续看下,当m!=0时的操作,如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQzNjFjZmU4OTA3N2JjZDVjNzQ1Mjk0NjNhYzFkZjZfYnRCbW5BdmF6OEFHYWMzOHdOam1PR3phY0I0OGRLTWhfVG9rZW46WHY4T2JadkhjbzJqVlJ4OElrTWNQNEdlbmVnXzE3Njg2NTU2MDk6MTc2ODY1OTIwOV9WNA)



```plain
else if (U.getObjectVolatile(a, j) == p && // 如果线程对应的arena[index]还在
                          U.compareAndSwapObject(a, j, p, null)) { // 那么就cas设置为null
                     if (m != 0)                // try to shrink cas将bound操作为+SEQ-1,也即修改线程可以操作的下标范围
                         U.compareAndSwapInt(this, BOUND, b, b + SEQ - 1);
                     p.item = null; // 清理数据,然后重新执行循环
                     p.hash = h;
                     i = p.index >>>= 1;        // descend 
                     if (Thread.interrupted())
                         return null;
                     if (timed && m == 0 && ns <= 0L)
                         return TIMED_OUT;
                     break;                     // expired; restart
                 }
```

到这里arenaExchange()方法也差不多了,但是比较复杂。总结一下： 1.和LongAdder一样,都对数组的长度进行了限制 2.总的思路就是换位置不断重试,并且是动态的"扩容"和"缩容"

到这里,juc中的同步器就介绍到这里了。感谢阅读！

