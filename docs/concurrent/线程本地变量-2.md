## InheritableThreadLocal

* ThreadLocal的局限性

它的核心目的是为每个使用该threadlocal变量的线程提供一个独立的变量副本,使得每个线程都可以只访问自己的副本.实现线程隔离(或者说是线程安全)。

但是在某些场景下,比如父子线程,在线程-A中设置了一个threadlocal的值，然后线程-A创建了一个线程B，那么线程B是获取不到线程-A设置的值的。这也是正常的,因为线程-A和线程-B是不同的线程,它们的值是隔离的。

```plain&#x20;text
public class Demo {
    public static ThreadLocal<String> tl = new ThreadLocal<>();
    public static void main(String[] args) {
        tl.set("parent");
        new Thread(()->{
            System.out.println(Thread.currentThread()+":"+tl.get()); // null 获取的是null
        }).start();
        System.out.println(tl.get()); // parent
    }
}
```

而InheritableThreadLocal(可继承的ThreadLocal)就是为了满足这个场景的

```plain&#x20;text
public class Demo {
    public static InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
    public static void main(String[] args) {
        itl.set("parent");
        new Thread(()->{
            System.out.println(Thread.currentThread()+":"+itl.get()); // parent 能够获取到父线程设置的值
        }).start();
        System.out.println(itl.get()); // parent
    }
}
```

### 类关系图



在InheritableThreadLocal类中没有新增加的属性，只有三个方法&#x20;



### 源码解析

那么InheritableThreadLocal类到底是如何做到子线程继承父线程的ThreadLocal的值的呢？

```plain&#x20;text
public static InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
```

当执行完这一行代码,因为该类没有新增加的属性,所以其内部的值和创建ThreadLocal对象是一样的。 继续看itl.set()方法,因为当前类没有set()方法,所以最终调用的则是ThreadLocal中的set()方法

```plain&#x20;text
public void set(T value) {
    Thread t = Thread.currentThread(); // 获取当前线程
    ThreadLocalMap map = getMap(t); // 获取线程对应的threadLocalMap
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value); // 初始化map
    }
}
```

父线程第一次set的时候,map肯定是为空的,getMap(t)返回null,那么接下来会调用createMap()

```plain&#x20;text
ThreadLocalMap getMap(Thread t) {
   return t.inheritableThreadLocals;
}

void createMap(Thread t, T firstValue) {
    t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
}
```

可以看到,在这里每个线程所对应的map是inheritableThreadLocals而不是threadLocals了

```plain&#x20;text
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // 此时每个线程内部的map为这个
```

此时的结构为：



然后创建子线程，关键点就在于线程初始化

```plain&#x20;text
private Thread(ThreadGroup g, Runnable target, String name,
               long stackSize, AccessControlContext acc,
               boolean inheritThreadLocals) {

    // .....
    // inheritThreadLocals 默认为true
    if (inheritThreadLocals && parent.inheritableThreadLocals != null) // 如果父线程的inheritableThreadLocals不为null,当前条件符合

        this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); // 那么子线程的itls则是由createInheritedMap()来进行初始化

    // .....
}
```

继续看createInheritedMap()方法：参数为父类的inheritableThreadLocals属性,此时的结构如下图所示：



```plain&#x20;text
static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {
    return new ThreadLocalMap(parentMap);
}

private ThreadLocalMap(ThreadLocalMap parentMap) {
    Entry[] parentTable = parentMap.table; // 获取父类map中的entry[]数组
    int len = parentTable.length;
    setThreshold(len); // 设置子线程map的扩容阈值
    table = new Entry[len]; // 创建一个和父线程一样大的entry[]数组

    for (Entry e : parentTable) { // 下面就是数据拷贝
        if (e != null) {
            @SuppressWarnings("unchecked")
            ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();
            if (key != null) {
                Object value = key.childValue(e.value);
                Entry c = new Entry(key, value);
                int h = key.threadLocalHashCode & (len - 1);
                while (table[h] != null)
                    h = nextIndex(h, len);
                table[h] = c;
                size++;
            }
        }
    }
}
```

虽然只是数据拷贝,但是在这里有一个方法需要注意,那就是并不是直接拷贝value,而是需要先经过一个childValue()方法,而这个方法在ITL中的默认实现为返回传入的值,所以在这里是浅拷贝,而不是深拷贝

```plain&#x20;text
protected T childValue(T parentValue) {
    return parentValue;
}
```

这意味着父子线程之间的修改是相互可见的,但是如果存储的是String类型的话,则是互不影响的(但是这是String的特性,并不影响浅拷贝的事实)

```plain&#x20;text
public class Demo {
    public static InheritableThreadLocal<StringBuilder> itl = new InheritableThreadLocal<>();
    public static void main(String[] args) throws InterruptedException {
        StringBuilder builder = new StringBuilder("parent");
        itl.set(builder);
        new Thread(()->{
            System.out.println(Thread.currentThread()+":"+itl.get()); // 输出 parent
            itl.get().append("child"); // 会影响到父线程get的值
        }).start();
        Thread.sleep(2000);
        System.out.println(itl.get()); // parent + child
    }
}
```

这个childValue()就是留给用户扩展的方法,因为有时候不希望子线程只是单纯的继承父线程的值,而是基于父线程的值做一些修改,那么可以重写childValue()方法

```plain&#x20;text
public static InheritableThreadLocal<StringBuilder> itl = new InheritableThreadLocal<>() {
    @Override
    protected StringBuilder childValue(StringBuilder parentValue) {
      // TODO
    }
};
```

注意：从代码中可以看出来，父子线程ITL数据的传递是在子线程创建的时候就完成了，如果父线程是在子线程创建之后才set()值,那么子线程是获取不到的！

* ITL的缺陷

ITL类可以完成父线程到子线程的值传递。 但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的ThreadLocal值传递已经没有意义， 应用需要的实际上是把**任务提交给线程池时**的ThreadLocal值传递到**任务执行时.**

这是什么意思呢？



```plain&#x20;text
import com.alibaba.ttl.TransmittableThreadLocal;
import java.util.concurrent.*;
public class Demo {
    public static InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
    public static ThreadPoolExecutor executor
            = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
    private static final InheritableThreadLocal<String> TRACE_ID = new InheritableThreadLocal<>();
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i <10; i++) { // 预启动线程池中的线程
            executor.execute(()->{
                System.out.println("pre start thread");
            });
        }
        Thread.sleep(3000); // 此时线程池中的工作线程的父子关系已经确定了,因为它们已经被创建并且启动了
        // 模拟处理线程 - 设置上下文「trace_id」- 然后投递给线程池执行 - 但是线程池中工作线程则获取的null
        for (int i = 0; i < 5; i++) {
            int requestId = i;
            new Thread(()->{
                TRACE_ID.set("Trace-" + requestId);
                System.out.println(Thread.currentThread().getName() + " 设置 TraceID: " + TRACE_ID.get());
                executor.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + " 执行任务，获取 TraceID: " + TRACE_ID.get());
                });
            }).start();
        }
        Thread.sleep(3000);
        executor.shutdown();
    }
}

// output
pre start thread
// ....
pre start thread
Thread-0 设置 TraceID: Trace-0
Thread-1 设置 TraceID: Trace-1
Thread-2 设置 TraceID: Trace-2
Thread-3 设置 TraceID: Trace-3
Thread-4 设置 TraceID: Trace-4
pool-1-thread-1 执行任务，获取 TraceID: null
pool-1-thread-4 执行任务，获取 TraceID: null
pool-1-thread-7 执行任务，获取 TraceID: null
pool-1-thread-3 执行任务，获取 TraceID: null
pool-1-thread-1 执行任务，获取 TraceID: null
```

但是如果使用TTL

```plain&#x20;text
public class Demo_2 {
    public static TransmittableThreadLocal<String> ttl = new TransmittableThreadLocal<>();
    public static ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS, new LinkedBlockingQueue<>());

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            executor.execute(() -> {
                System.out.println("pre start thread");
            });
        }
        Thread.sleep(3000);
        for (int i = 0; i < 5; i++) {
            int requestId = i;

            new Thread(() -> {
                ttl.set("Trace-" + requestId);
                System.out.println(Thread.currentThread().getName() + " 设置 TraceID: " + ttl.get());
                executor.execute(TtlRunnable.get(() -> {
                    System.out.println(Thread.currentThread().getName() + " 执行任务，获取 TraceID: " + ttl.get());
                }));
            }).start();
        }
        Thread.sleep(3000);
        executor.shutdown();
    }
}
// output
pre start thread
// ....
pre start thread
Thread-0 设置 TraceID: Trace-0
Thread-1 设置 TraceID: Trace-1
Thread-2 设置 TraceID: Trace-2
Thread-3 设置 TraceID: Trace-3
Thread-4 设置 TraceID: Trace-4
pool-1-thread-1 执行任务，获取 TraceID: Trace-0
pool-1-thread-4 执行任务，获取 TraceID: Trace-3
pool-1-thread-7 执行任务，获取 TraceID: Trace-1
pool-1-thread-5 执行任务，获取 TraceID: Trace-4
pool-1-thread-2 执行任务，获取 TraceID: Trace-2
```

可以看到，线程池中的工作线程可以获取到外部线程设置的context,在这里有一个很关键的点：就是使用TtlRunnable.get()来包装原本的任务。

当然也可以用来修饰线程池(这样不用每次提交包装任务),以及使用JavaAgent无侵入的修改JDK线程池实现类。但是在这里先介绍基本原理.也即TTL是如何做到的上述行为的。

## TransmittableThreadLocal

问题引出：



首先需要知道的是：TransmittableThreadLocal它肯定是一个ThreadLocal「从源码可以看出来它是继承InheritableThreadLocal的」,但是它却能够解决不同线程之间传递ThreadLocal对应值的能力，如下图所示：

```plain&#x20;text
public class TransmittableThreadLocal<T> extends InheritableThreadLocal<T>{
 // ....
}
```







### 源码解析

以下面这个例子来探索它的工作原理：「下面这个例子是最简单的」

```plain&#x20;text
public class Demo_2 {
    public static TransmittableThreadLocal<String> ttl = new TransmittableThreadLocal<>();
    public static ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS, new LinkedBlockingQueue<>());

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            executor.execute(() -> {
                System.out.println("pre start thread");
            });
        }
        Thread.sleep(3000);
        for (int i = 0; i < 5; i++) {
            int requestId = i;

            new Thread(() -> {
                ttl.set("Trace-" + requestId);
                System.out.println(Thread.currentThread().getName() + " 设置 TraceID: " + ttl.get());
                executor.execute(TtlRunnable.get(() -> {
                    System.out.println(Thread.currentThread().getName() + " 执行任务，获取 TraceID: " + ttl.get());
                }));
            }).start();
        }
        Thread.sleep(3000);
        executor.shutdown();
    }
}
```

* new TTL()：构造函数

可以看到构造函数只是初始化一个变量，默认为false 当该值为false时, 忽略空值语义

```plain&#x20;text
public TransmittableThreadLocal() {
    this(false);
}

public TransmittableThreadLocal(boolean disableIgnoreNullValueSemantics) {
    this.disableIgnoreNullValueSemantics = disableIgnoreNullValueSemantics; // 该属性默认为false
}
```

可以看到初始时并没有做很多其他的操作，和初始化InheritableThreadLocal是差不多的,但是除此之外还初始化了另外一个静态属性，这个属性是属于类的,而不是对象的。

这个变量是一个InheritableThreadLocal类型，它存储的是一个WeakHashMap,而这WeakHashMap存储的又是TransmittableThreadLocal对象，作用是什么呢？&#x20;



```plain&#x20;text
// 初始化对象时会先初始化类变量
private static final InheritableThreadLocal<WeakHashMap<TransmittableThreadLocal<Object>, ?>> holder =
        new InheritableThreadLocal< WeakHashMap < TransmittableThreadLocal<Object> , ? > >() {
            // ....
        };
```

到这里初始化已经完毕了，下面看下set()方法



暴露出disableIgnoreNullValueSemantics属性来影响空值的操作,在这里会调用super.set(value)来存储值,此时结构如下：&#x20;



```plain&#x20;text
public final void set(T value) {
    if (!disableIgnoreNullValueSemantics && value == null) { // disableIgnoreNullValueSemantics:忽略空值语义,并且要set的value为null时,实际上执行的remove()操作
        // may set null to remove value
        remove();
    } else { // 这里是正常分支
        super.set(value); // 调用父类的set()方法,这个是ThreadLocal的特性
        addThisToHolder(); // 这个为TTL的扩展方法
    }
}
```

继续看addThisToHolder()方法 从这里就可以看出在TTL中的ITL对象的作用了：就是用来存储每个线程set过的TTL对象的

```plain&#x20;text
private void addThisToHolder() {
    if (!holder.get().containsKey(this)) { // 拿到TTL类中的holder对象,调用get() -> 返回的是一个 weakHashMap() -> 然后调用containsKey()方法来判断当前TTL对象存在于该weakHashMap()中
        // 如果不在,那么将当前TTL存放到对应的weakHashMap中
        holder.get().put((TransmittableThreadLocal<Object>) this, null); // WeakHashMap supports null value.
    }
}
```

如果有以下代码： 那么此时的结构如下：&#x20;



```plain&#x20;text
public class Demo_3 {
    public static TransmittableThreadLocal ttl_1 = new TransmittableThreadLocal();
    public static TransmittableThreadLocal ttl_2 = new TransmittableThreadLocal();
    public static void main(String[] args) {
        ttl_1.set("1");
        ttl_2.set("2");
    }
}
```

继续看下一个核心步骤：



```plain&#x20;text
public static TtlRunnable get(@Nullable Runnable runnable) {
    return get(runnable, false, false); // 默认传入的两个参数为false
}

public static TtlRunnable get(@Nullable Runnable runnable, boolean releaseTtlValueReferenceAfterRun, boolean idempotent) { // 这里 第三个参数的作用用来做幂等操作的,避免传入的任务已经是TtlRunnable类型的了

    if (runnable == null) return null;
    // 是否对已经被包装的TtlRunnable做处理 - idempotent = false「默认」,则会抛出异常
    if (runnable instanceof TtlEnhanced) {
        // avoid redundant decoration, and ensure idempotency
        if (idempotent) return (TtlRunnable) runnable;
        else throw new IllegalStateException("Already TtlRunnable!");
    }
    // 否则创建一个新的TtlRunnable对象
    return new TtlRunnable(runnable, releaseTtlValueReferenceAfterRun);
}

// TtlRunnable构造函数
private TtlRunnable(@NonNull Runnable runnable, boolean releaseTtlValueReferenceAfterRun) {
    this.capturedRef = new AtomicReference<>(capture()); // 首先会调用capture()方法,然后保存在当前TtlRunnable对象中
    this.runnable = runnable; // 保存任务
    this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun; // 内存管理策略标志,决定执行完毕后是否释放Ttl值引用(默认为false)
}

// 创建对象前需要先初始化类(类属性 - 静态 / 非静态)
// 从这个属性的名字来看,应该是作为task的附件,也即TtlRunnable可以携带额外的数据
private final TtlAttachmentsDelegate ttlAttachment = new TtlAttachmentsDelegate();
// 而这个类也有一个对象属性,所以在这里会初始化两个属性
public class TtlAttachmentsDelegate implements TtlAttachments {
    private final ConcurrentMap<String, Object> attachments = new ConcurrentHashMap<>();
    // ... methods
}
```

继续看capture()方法



在看capture方法之前,需要先介绍一个类：Transmitter，这个就是专门负责实现跨线程的线程本地变量传输功能。 并且这个类中有7个静态属性



在这里先关心前面3个类属性，此时的结构为：&#x20;



```plain&#x20;text
// 在该类初始化的时候
// 创建transmitteeSet - 这是一个set,用来存储Transmittee对象的
private static final Set<Transmittee<Object, Object>> transmitteeSet = new CopyOnWriteArraySet<>(); 

// 创建Transmittee 和 ttl相关
private static final Transmittee<HashMap<TransmittableThreadLocal<Object>, Object>, HashMap<TransmittableThreadLocal<Object>, Object>> ttlTransmittee =
        new Transmittee<HashMap<TransmittableThreadLocal<Object>, Object>, HashMap<TransmittableThreadLocal<Object>, Object>>() { .... };
// 创建Transmittee - 和 ThreadLocal相关
private static final Transmittee<HashMap<ThreadLocal<Object>, Object>, HashMap<ThreadLocal<Object>, Object>> threadLocalTransmittee =
                new Transmittee<HashMap<ThreadLocal<Object>, Object>, HashMap<ThreadLocal<Object>, Object>>() { .... };
                };

// 将这两个Transmittee对象添加到transmitteeSet中
static {
    registerTransmittee(ttlTransmittee);
    registerTransmittee(threadLocalTransmittee);
}

public static <C, B> boolean registerTransmittee(@NonNull Transmittee<C, B> transmittee) {
        return transmitteeSet.add((Transmittee<Object, Object>) transmittee);
}

public static <C, B> boolean registerTransmittee(@NonNull Transmittee<C, B> transmittee) {
    return transmitteeSet.add((Transmittee<Object, Object>) transmittee);
}
```

然后再看capture()方法

```plain&#x20;text
public static Object capture() {
    // 创建一个hashMap,大小为3(size = 2 , 在newHashMap()中还需要计算一下)
    final HashMap<Transmittee<Object, Object>, Object> transmittee2Value = newHashMap(transmitteeSet.size());
    // 遍历transmitteeSet中的每个 Transmittee 对象
    for (Transmittee<Object, Object> transmittee : transmitteeSet) {

        // 将Transmittee 和 Transmittee.capture()对象一起存放到该HashMap中
        transmittee2Value.put(transmittee, transmittee.capture());

        // .... 省略 try()catch{}代码
    }
    // 再使用Snapshot类来包装该对象
    return new Snapshot(transmittee2Value);
}

// transmittee.capture() - ttlTransmittee 和 threadLocalTransmittee 都有capture()方法
// 在这里先看ttlTransmittee的
// 返回值为一个HashMap(),注意,这里是从TtlRunnable.get()方法进来的,执行这个方法的线程是 「外部线程」
public HashMap<TransmittableThreadLocal<Object>, Object> capture() {
    // 创建一个hashMap(),大小是当前线程holder.get().size --> 这个大小 是 外部线程 调用了ttl-x.set()的个数 
    final HashMap<TransmittableThreadLocal<Object>, Object> ttl2Value = new HashMap<>(holder.get().size());
    // holder.get()是一个WeakHashMap(),存放的ttl对象
    // 在这里将ttl对象以及所对应的value存放到上ttl2Value这个hashMap()中
    for (TransmittableThreadLocal<Object> threadLocal : holder.get().keySet()) {
        ttl2Value.put(threadLocal, threadLocal.copyValue());
    }
    // 将这个hashMap返回
    return ttl2Value;
}

// threadLocal.copyValue() 默认没有扩展,就是直接返回对应的value
private T copyValue() {
    return copy(get());
}

// threadLocalTransmitteed的 在这里threadLocalHolder默认为空,这里先不关注
public HashMap<ThreadLocal<Object>, Object> capture() {
    final HashMap<ThreadLocal<Object>, Object> threadLocal2Value = new HashMap<>(threadLocalHolder.size());
    // .....
    return threadLocal2Value;
}
```

此时的结构为：&#x20;



然后继续看TtlRunnable的构造方法



```plain&#x20;text
private TtlRunnable(@NonNull Runnable runnable, boolean releaseTtlValueReferenceAfterRun) {
    this.capturedRef = new AtomicReference<>(capture());
    this.runnable = runnable;
    this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;
}
```

到这里TtlRunnable ttlRunnable = TtlRunnable.get(runnable)方法就结束了,下面看下当线程池中的线程「别的线程」在执行ttlRunnable.run()时候的处理「到底是如何做到访问外部线程设置的ttl的值的呢？」

这里会看到另外两个非常重要的方法：&#x20;



```plain&#x20;text
public void run() {
    final Object captured = capturedRef.get(); // 获取到Snapshot对象
    
    // 省略异常处理...

    final Object backup = replay(captured);
    try {
        runnable.run();
    } finally {
        restore(backup);
    }
}
```

* replay(captured):注意此时执行的线程为线程池中的线程，而不是外部线程(提交任务的线程了)

此时的结构为：这里同样也是浅拷贝,但是在图中没有体现出来,所以在工作线程中set()了值,那么在外部线程是可以感知的

```plain&#x20;text
// threadLocal.copyValue() // 默认返回获取的值,是浅拷贝,但是可以重写

private T copyValue() {
    return copy(get());
}

public T copy(T parentValue) {
    return parentValue;
}
```

&#x20;部分图

部分图

完整图

完整图

```plain&#x20;text
public static Object replay(@NonNull Object captured) {
    // 强转类型
    final Snapshot capturedSnapshot = (Snapshot) captured;
    // 创建一个hashMap 
    final HashMap<Transmittee<Object, Object>, Object> transmittee2Value = new HashMap<>(capturedSnapshot.transmittee2Value.size());

    //遍历所有的entry
    for (Map.Entry<Transmittee<Object, Object>, Object> entry : capturedSnapshot.transmittee2Value.entrySet()) {
        // 获取key - ttlTransmittee
        Transmittee<Object, Object> transmittee = entry.getKey();
        // 获取value - hashMap  - 存储的是ttl和对应的value
        Object transmitteeCaptured = entry.getValue();
        // 对value(hashMap)还需要作进一步的处理 - 调用key.replay()方法
        transmittee2Value.put(transmittee, transmittee.replay(transmitteeCaptured));
    }
    // 使用Snapshot来包装
    return new Snapshot(transmittee2Value);
}

// transmittee.replay(transmitteeCaptured)
public HashMap<TransmittableThreadLocal<Object>, Object> replay(@NonNull HashMap<TransmittableThreadLocal<Object>, Object> captured) {
    // 创建一个新的hashMap
    final HashMap<TransmittableThreadLocal<Object>, Object> backup = new HashMap<>(holder.get().size());

    // 使用迭代器 - 迭代当前工作线程对应的holder - 而holder的作用是什么？在前面说过,holder是一个itl,它是用来存储每个线程set过的ttl的
    // 因为 工作线程 也可能使用了对应的ttl来保存自己的值,所以在这里会把对应的ttl和ttl的值保存在backup这个hashMap中
    // --保存工作线程本身set()的值
    for (final Iterator<TransmittableThreadLocal<Object>> iterator = holder.get().keySet().iterator(); iterator.hasNext(); ) {
        TransmittableThreadLocal<Object> threadLocal = iterator.next();

        // backup
        backup.put(threadLocal, threadLocal.get());
        // ....
    }

    // set TTL values to captured 这里的captured为外部传入的,指向的就是外部线程创建的transmittee2Value中某个entry的value「hashMap」
    // 这里主要做的事情就是将外部线程set()的值设置到当前工作线程中
    setTtlValuesTo(captured);
  
    // ---- 当setTtlValuesTo()执行完毕后,外部线程set的上下文信息就能被工作线程获取到了,因为工作线程重新调用了set()
    // ---- 这次set()后,上下文信息就存储在工作线程thread中的map中了, 后续就能通过get()获取到了  
    // call beforeExecute callback - 默认什么都不做,可扩展
    doExecuteCallback(true);
    // 返回当前线程本身的值(保存在这个hashMap中)
    return backup;
}

// setTtlValuesTo(captured)
/*
    1.遍历hashMap中的所有key - ttl对象
    2.获取hashMap中的所有value - 这里就是外部线程设置的上下文信息
    3.调用ttl.set(value) - 注意:此时是工作线程,在这里会覆盖掉当前工作线程自己set的值,但是没关系,在上面已经保存过了
*/
private static void setTtlValuesTo(@NonNull HashMap<TransmittableThreadLocal<Object>, Object> ttlValues) {
    for (Map.Entry<TransmittableThreadLocal<Object>, Object> entry : ttlValues.entrySet()) {
        TransmittableThreadLocal<Object> threadLocal = entry.getKey();
        threadLocal.set(entry.getValue());
    }
}
```

继续看下doExecuteCallback(true)方法:调用所有ttl的beforeExecute()方法 - 通过isBefore来影响 这里是一个扩展方法，默认实现为空

```plain&#x20;text
private static void doExecuteCallback(boolean isBefore) {
    // 获取当前线程在holder中保存的WeakHashMap()并且拷贝一份 - ttlInstances
    WeakHashMap<TransmittableThreadLocal<Object>, ?> ttlInstances = new WeakHashMap<TransmittableThreadLocal<Object>, Object>(holder.get());
    // 遍历所有ttlInstances中所有的key - ttl对象 isBefore参数用来影响是调用ttl的beforeExecute()方法还是调用afterExecute()方法 
    for (TransmittableThreadLocal<Object> threadLocal : ttlInstances.keySet()) {
        try {
            if (isBefore) threadLocal.beforeExecute();
            else threadLocal.afterExecute();
        } catch (Throwable t) {
            if (logger.isLoggable(Level.WARNING)) {
                logger.log(Level.WARNING, "TTL exception when " + (isBefore ? "beforeExecute" : "afterExecute") + ", cause: " + t, t);
            }
        }
    }
}
```

然后进入到runnable.run()方法 此时工作线程get()时,获取的就是外部线程set()的值,这里总结一下：



```plain&#x20;text
Runnable runnable = () -> {
    ttl.get();
};

public final T get() {
    T value = super.get(); // 调用父类的get()
    // ....
    return value;
}
```

当任务执行完毕,看下restore(backup)是如何工作的 此时结构如下：&#x20;

数据复原restore()

```plain&#x20;text
public static void restore(@NonNull Object backup) { // 这里的backup是Snapshot类型的,存储了工作线程原本的ttl及其value
    // 获取backup中的transmittee2Value中的所有entry - key是
    for (Map.Entry<Transmittee<Object, Object>, Object> entry : ((Snapshot) backup).transmittee2Value.entrySet()) {
        // 获取entry对应的key
        Transmittee<Object, Object> transmittee = entry.getKey();
        // 获取entry对应的value
        Object transmitteeBackup = entry.getValue();
        // 调用key.restore() - 传入的是hashMap() - 里面存储了工作线程原本的所有ttl及其对应的value
        transmittee.restore(transmitteeBackup);
        // ... 省略异常处理
    }
}



// key.restore()
public void restore(@NonNull HashMap<TransmittableThreadLocal<Object>, Object> backup) {
    // call afterExecute callback
    // 回掉函数 - 这次调用的是afterExecute()
    doExecuteCallback(false);

    // ... 

    // restore TTL values
    setTtlValuesTo(backup);
}

// setTtlValuesTo(backup)
private static void setTtlValuesTo(@NonNull HashMap<TransmittableThreadLocal<Object>, Object> ttlValues) {
    // 遍历所有的entry - 每一个entry包含了ttl及其value
    for (Map.Entry<TransmittableThreadLocal<Object>, Object> entry : ttlValues.entrySet()) {
        // 获取ttl
        TransmittableThreadLocal<Object> threadLocal = entry.getKey();
        // 重新set回去
        threadLocal.set(entry.getValue());
    }
}
```

到这里：TransmittableThreadLocal的基本工作就介绍到这里了,但是我所学习的只是该类的冰山一角。后续有机会再深入了解。

在这里总结一下：其实TTL和ITL的设计思想差不多。 因为ThreadLocal它的设计目标就是为了线程隔离。

1. 但是此时出现了子线程需要访问父线程的ThreadLocal,那么就出现了ITL,他的解决办法是什么呢？当子线程初始化时，***拷贝***&#x7236;线程的ThreadLocal数据，这样子线程就能访问到了。

2. 而如果再进一步,如果是非父子线程呢？同样也是拷贝,将A线程的ThreadLocal拷贝一份「capture()」, 当B线程需要访问的时候, 将拷贝的数据保存在自己的map中「replay()」 不过由于B线程有自己的value,所以这里不能简单的覆盖，而是要先store() ，然后再访问完毕后再restore()
