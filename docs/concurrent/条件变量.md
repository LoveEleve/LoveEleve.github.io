条件变量：Condition，需要再次回顾一下管程模型

<!-- 这是一张图片，ocr 内容为： -->
![图片1](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDcxMjJiNGRjMmFmY2FjYWM1NmMxZGFiYTA4M2Q5ZmVfMWdKa0d2aXBHdVA3WVRGZkJvZ1RKNVBEb250ZlpVeFZfVG9rZW46UkhHdmJZSDJyb1VFM2F4eGxjMmM4VDhZbkc2XzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")

管程模型

多个线程想要进入到临界区的时候,就需要先通过条件判断,通常来说这个条件判断是对锁资源的判断，如果锁资源还存在,那么就能通过，反之则不能。

但是还有另外一种场景,可以参考生产者和消费者的场景：

当生产者和消费者想要操作「put / take」时,首先需要拿到容器的锁后才能进行操作「只能有一个人操作容器 - 一个生产者或者一个消费者」。 但是存在一种场景：当某个操作者获取锁成功后，发现要后续操作走不下去了,比如当某个生产者获取锁成功后,想要put元素进去,但是发现容器满了,这个时候应该怎么办? 对应下面的else分支,一种很简单的实现方式,那就是直接释放锁「lock.unlock()」，但是线程的调度是不可预估的，下一个获取到锁的线程可能还是该生产者「它判断出条件不满足后又要重复下面的操作」,那这不是在浪费时间吗？ 所以一种合理的做法应该是让该生产者阻塞在“容器没满”这个条件变量上，当这个条件满足后，再被唤醒去执行「同理,消费者也是如此」 这里还有另外一个要注意的点：线程阻塞在条件变量之前,需要释放锁「如果不释放锁，那么其他线程如果拿到锁来进行操作以满足条件呢？」

```java
//producer
lock = producer.lock()
if(lock){
    if(容器没有满){
      put();
    }
    //容器满了
    else{
      TODO
      // lock.unlock();
    }
}

//producer
lock = producer.lock()
if(lock){
    if(容器没有满){
      put();
    }
    //容器满了
    else{
      notfullCondition.await()
    }
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片1](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDcxMjJiNGRjMmFmY2FjYWM1NmMxZGFiYTA4M2Q5ZmVfMWdKa0d2aXBHdVA3WVRGZkJvZ1RKNVBEb250ZlpVeFZfVG9rZW46UkhHdmJZSDJyb1VFM2F4eGxjMmM4VDhZbkc2XzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")

生产者消费者

所以条件变量的作用是：当线程获取锁成功后，发现继续执行的条件不满足,那么就需要阻塞在对应的条件变量上.

## 条件队列
一般的使用方式

```java
static Condition putCondition = lock.newCondition(); //创建条件变量
lock.lock();
try {
    if (array.length == 10){ // 容器满了
        putCondition.await(); //阻塞在条件变量上
    }
} catch (InterruptedException e) {
    throw new RuntimeException(e);
} finally {
    lock.unlock();
}

// 条件变量
public class ConditionObject implements Condition{
         private transient Node firstWaiter; //首个等待节点
         private transient Node lastWaiter;  //末尾等待节点
}
```

### 入队列源码
入队列要首先要做的就是创建对应的node节点,然后添加到等待队列尾部,这个实现和所有入队的实现方式都一样 但是在这里依然需要考虑特殊情况：如下图所示 -- 等待队列可能为空，但是尾部也可能存在着被取消的节点 但是链接到被取消的节点后面是没有意义的,所以在这里需要将当前节点链接到第一个状态不为cancel的等待节点并且同时做清理操作

<!-- 这是一张图片，ocr 内容为： -->
![图片2](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg3ZDYxZGNlYTc0NjMyOTI5MTM1NWNmOTNjYTVjN2FfSGZzRXUzd3pWMVJXRHhEMFpldk1WOVNnaVlmRkJabDVfVG9rZW46TnFodGJmTGR3bzAwVlN4MUFsbmNicXlsbjRkXzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
private Node addConditionWaiter() {
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    if (t != null && t.waitStatus != Node.CONDITION) { // 如果lastWaiter存在,并且其状态不为condition,那么做清理操作
        unlinkCancelledWaiters();
        t = lastWaiter; //上面的方法执行完毕后 t 指向最后一个状态不为cancel的等待节点
    }

    Node node = new Node(Thread.currentThread(), Node.CONDITION); // 创建等待节点 - 含有线程对象和节点状态「condition」
    //链接到等待队列上去
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}

// 清除被取消的节点 -- 从头到尾清理一遍 -- 下面就是链表操作
private void unlinkCancelledWaiters() {
    Node t = firstWaiter;
    Node trail = null;
    while (t != null) {
        Node next = t.nextWaiter;
        if (t.waitStatus != Node.CONDITION) {
            t.nextWaiter = null;
            if (trail == null)
                firstWaiter = next;
            else
                trail.nextWaiter = next;
            if (next == null)
                lastWaiter = trail;
        }
        else
            trail = t;
        t = next;
    }
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片3](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA3YWU3MGU5OGZmZWJkYjA1NmQ0ZjI4ZDhlZjgyNmZfdm12RTFWTXducllCT20xbkRKZk5oNlRUU2RYek1MTzlfVG9rZW46UmdleWJVVjhFb0ZFNFN4a2hYS2NPVGFvbmpnXzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")

插入到队列的清理流程

当线程对应的等待节点已经插入到等待队列后,接下来应该要做什么？直接阻塞吗？还是说自旋等待？

直接阻塞和自旋等待都是不应该的做法： 1.直接阻塞：当前条件无法支持线程继续往下执行下去，需要别的线程拿到锁后满足条件,然后当前线程才能继续执行下去，但是如果没有释放锁就直接阻塞「别的线程是拿不到锁的」，那就会造成死锁 2.自旋后再释放锁：这个自旋是否有必要？ -- 没有必要，因为自旋出现的场景是：所等待的条件应该很快就会被其他线程满足,那么才需要自旋来减少不必要的上下文切换，但是在这里如果没有释放锁，是永远不可能满足条件的

所以下一步就是直接释放锁

```java
final int fullyRelease(Node node) {
    boolean failed = true;
    try {
            // 获取当前的锁资源状态 - 通常这里代表的是锁被加了几次 - 通常是1 - 如果大于1则代表锁重入了 
        int savedState = getState(); 
        if (release(savedState)) { // 释放锁
            failed = false;
            return savedState; //返回旧的锁数量
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed) // 如果失败则将当前节点状态设置为cancel
            node.waitStatus = Node.CANCELLED;
    }
}
```

好了,到目前为止：线程等待节点创建好了，并且也插入到等待队列中了，并且锁也释放了，那么下面按道理来说应该是直接阻塞,但是这里需要注意关键的一点：就是在上面一步才刚刚释放了锁,在这么段的时间内,其他线程获取了锁,并且满足了条件，然后调用了condition.signal()方法,让当前等待节点出等待队列，那么如果在释放锁后直接阻塞就显的性能太差了。为了理解后续的操作，在这里需要先关注**出等待队列**(condition.signal()方法)

### 出队列
前提：此时线程节点正在等待队列中,那么当条件满足后,应该怎么做？再次看生产者消费者模型 当生产者阻塞在等待队列后,拿到锁的消费者消费了元素后「也即容器不满了,生产者可以put元素了」， 但是这是一个线程安全的容器,那么生产者想要put的前提是，需要重新拿到操作容器的锁 那么能不能直接唤醒生产者？当然不能 -- 因为现在锁还被消费者拿着呢 所以这里默认可以认为生产者竞争锁失败 -- 竞争锁失败会进入到那哪个队列呢？ -- 同步队列 所以在这里消费者要做的就是将消费者插入到同步队列的尾部,然后设置前驱节点的状态即可 注意这里在正常情况下,需要唤醒生产者吗？ -- 不需要，因为唤醒了也抢不到，因为锁还在消费者手上呢 所以消费者做的事情如下面第二张图所示

<!-- 这是一张图片，ocr 内容为： -->
![图片4](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQzMGRmZTU4MzczY2NhMTAyYTliY2M4YzVjOGRlZGVfajhlblR6eW1PcU9pTnpIcldUalpCWWJwYWw4ZG5CSFBfVG9rZW46QXNxNWJFS2twb2FyOVB4OEZRbmM4dFBSbnhjXzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")

生产者消费者模型

<!-- 这是一张图片，ocr 内容为： -->
![图片5](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjExNTU4NjY1ZTA4NjRlM2YwZWU4NDk3OGNhMWFhZDlfSFp2TWpNVlplMUJsVUtURlJkbFlabGlkTXFaTmtkRktfVG9rZW46T29yMWJaU25Ob0xGWDZ4b1F1ZWNvajNWbnFkXzE3Njg2NDM4Nzg6MTc2ODY0NzQ3OF9WNA "图片链接可能已过期，如无法显示请联系作者")

消费者操作前后

这里再次强调：消费者只会将生产者放入到同步队列尾部,正常情况下并不会唤醒，也即如上图右侧所示

核心点：消费者只会将生产者等待节点移动到同步队列中，并不会唤醒生产者「在正常情况下」

```java
// condition.signal() --> doSignal(firstWaiter)
// 只唤醒一个,更新等待队列结构(firstWaiter和lastWaiter)
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null) // 如果等待队列中只有1个节点，那么清空等待队列
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) && // 操作等待队列的firstWaiter
             (first = firstWaiter) != null);
}

final boolean transferForSignal(Node node) {
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) //将等待节点的状态从condition -> 0
        return false;

    Node p = enq(node); // 入队,只是插入到同步队列的尾部,返回的是前驱节点
    
    int ws = p.waitStatus; 
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) // 正常情况下只需要将前驱节点的状态设置为signal即可,因为这代表当前线程节点处于阻塞状态
        LockSupport.unpark(node.thread); //只有处于不正常状态,才会唤醒等待节点，正常情况下是不会执行这样代码的
    return true;
}
```

接下来回到入队流程：

在看了出队流程后，可以知道,消费者「使用消费者和生产者来代替会比较好理解」会将生产者节点从等待队列移动到同步队列尾部,所以在生产者释放锁后,消费者拿到锁后就执行了出队操作，所以一个核心点就在于：生产者在释放锁后需要判断自己是否还在等待队列中,如果还在,那么说明条件依旧不满足,否则则代表条件已经满了「当然条件满足时，生产者节点就已经在同步队列了」

接下来看出队流程中当生产者释放锁后的代码逻辑：

```java
// 判断自己是否在同步队列中，如果不在，那么说明条件不满足,那么阻塞,
// 否则条件满足，并且在同步队列中了,那么结束while循环「也即先不阻塞」
while (!isOnSyncQueue(node)) { 
    LockSupport.park(this);
    //中断相关 ...
    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
        break;
}
```

### 判断是否在同步队列中
```java
//判断当前节点是否在同步队列中
final boolean isOnSyncQueue(Node node) {
    /*
        1.如果当前节点状态还是condition
        2.如果当前节点的prev == null
        满足其中一点都说明其还在等待队列中 - 因为等待节点node是没有prev的
    */
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    // 否则当前节点的node不为空,那么就说明是在同步队列中，因为等待节点是通过nextWaiter来链接的
    if (node.next != null) // If has successor, it must be on queue
        return true;

    // 上面两种方式是快速判断，下面这个是慢速判断 -- 笨方法 - 遍历同步队列一个个判断即可
    return findNodeFromTail(node);
}
```

在等待队列中阻塞就没什么好说的了，下面看看当被唤醒后的处理

被唤醒的原因：正常情况下是因为条件满足了，并且在同步队列中,被释放锁的线程唤醒了 但是被唤醒,不代表拿到锁了,这在前面讲AQS的时候就已经讲过了

```java
// 被唤醒后的操作 -- 先不关注中断相关
// 依旧还是要通过acquireQueued()来尝试获取锁,如果获取锁成功,返回最终会从await()返回,继续执行生产者的后续代码,否则会阻塞在同步队列中
if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
if (node.nextWaiter != null) // clean up if cancelled
    unlinkCancelledWaiters();
if (interruptMode != 0)
    reportInterruptAfterWait(interruptMode);
```

### 中断相关
现在来关注一下和中断有关的处理

1.调用await()之前就被中断了,那么直接抛出异常 2.当生产者从#1代码处醒来时,有两种情况： a.消费者满足了条件,并且将生产者线程节点从等待队列移动到了同步队列中,并且生产者线程节点被释放锁的线程唤醒了 b.生产者线程被中断唤醒了 -- 但是在这里也有两种情况，因为生产者线程在同步队列中也是阻塞的 -> 生产者线程节点阻塞在同步队列时被中断 #1 -> 生产者线程节点阻塞在等待队列时被中断 #2 关于线程中断的相关知识不在这里说明，但是当线程被中断时,处理方式是由程序员自己来响应的(优雅方式) 在这里doug lea 就针对不同位置的中断做了不同的处理 当中断情况是#1时,那么忽略中断 当中断情况是#2时,那么抛出异常 为什么要这么做呢？因为关于中断,JLS以及核心类API文档上有具体的说明：比如Object.wait()的文档说明： **InterruptedException**- if any thread interrupted the current thread before or while the current thread was waiting for a notification.**The interrupted status of the current thread is cleared when this exception is thrown.** 这段话有两个核心点： 1.中断可以发生在 **等待过程之前** 和 **等待过程中** 如果在等待过程之前就被中断了,那么抛出异常是合理的,也确实应该让线程停止,因为中断的意图就是让线程停止,并且此时线程还没有开始做任何事情 但是如果是在线程等待过程中被中断了,那么不应该抛出异常来终止线程执行，因为线程已经开始工作了,并且需要恢复中断标志位 对应这里就是当生产者线程还在等待队列中被中断，那么应该抛出异常 但是如果是在同步队列中被中断,那么不应该抛出异常，而是让线程继续执行下去,并且恢复中断标志位

这里为什么要恢复中断标志位呢？Thread.interrupt()的文档如下：

If this thread is blocked in an invocation of thewait(),wait(long), orwait(long, int)methods of theObjectclass, or of thejoin(),join(long),join(long, int),sleep(long), orsleep(long, int)methods of this class, then**its interrupt status will be cleared and it will receive anInterruptedException.**

线程被中断时会清除状态，并且抛出异常「这里的异常抛出是针对上面这些方法的」，因为在这里清楚了中断标志位,为了不丢失中断,所以在上面的处理中就应该恢复中断标志位

```java
public final void await() throws InterruptedException {
    // 1.还没有await()之前就被中断了,那么直接抛出异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 2.
    int interruptMode = 0; // 中断标识符
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this); //#1
        // 2.从上面park()唤醒后 -- 可能是正常唤醒,也可能是被中断唤醒
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
```

继续看checkInterruptWhileWaiting()方法：检查在等待过程中是否发生中断

```java
//checkInterruptWhileWaiting(node)
/*
    Thread.interrupted()：线程是否被中断了？
    1.如果没有被中断,那么返回0 -> interruptMode = 0
    2.线程被中断了,那需要进一步判断:transferAfterCancelledWait(node)
       返回true:再返回THROW_IE = -1 -- 抛出异常
       返回false:再返回REINTERRUPT = 1 -- 恢复中断标志位

*/
private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ? 
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
}

//transferAfterCancelledWait(node)
final boolean transferAfterCancelledWait(Node node) {
    
    //1.如果能够将线程节点的状态从condition -> 变为0 
    //那么就代表线程节点还在等待队列中,此时被中断,应该要抛出异常
    //所以这里返回true
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    //否则线程节点的状态已经被设置为0了,但是不一定在同步队列中
    //因为signal()方法中是先将节点状态设置为0，然后再入队的,所以这里可能处于中间状态
    //但是状态变化为0 到 入队 这个过程是很快的，这里只需要自旋等待即可
    while (!isOnSyncQueue(node))
        Thread.yield();
    // 返回false
    return false;
}
```

继续看如何处理中断

```java
// reportInterruptAfterWait(interruptMode)
private void reportInterruptAfterWait(int interruptMode)
    throws InterruptedException {
    // 如果是THROW_IE,那么抛出异常
    if (interruptMode == THROW_IE)
        throw new InterruptedException();
    // 否则只是恢复中断标志位
    else if (interruptMode == REINTERRUPT)
        selfInterrupt();
}
```

到这里,关于条件变量的入队和出队就先介绍到这里了，总结一下 代码细节是记不住的,但是要清楚2点：

1.为什么要有条件变量？

2.中断不同时机的处理方式

