<!-- 这是一张图片，ocr 内容为： -->
![图片1](图片暂时无法显示 - 请联系作者获取图片资源)



本篇文章介绍一下Netty框架的ThreadLocal -> FastThreadLocal「后续简称FTL 和 TL」

基于Netty版本:4.2.6.Final

## jdk的TL的缺点
在介绍FTL之前,先回顾一下jdk中TL的"不足",以下为我的理解：

1. 哈希冲突与线性探测法：目前接触到的哈希冲突的解决办法有两种：一种是hashMap中的链地址法，另外一种则是在ThreadLocal中的线性探测法
2. 链地址法：数组+链表(在实际中还使用了红黑树来做性能优化)：数组主要是用来做索引的，而数据则主要存储在数组外部 - 链表中，当冲突发生时，只需要在这个小范围中去线性搜索
3. 线性探测法：将所有的数据都放在数组内部，当冲突发生时,主动的去寻找下一个空位

当然两者都有各自的优点和缺点,在这里就简单讲一下TL所用的线性探测法的缺点：

<!-- 这是一张图片，ocr 内容为： -->
![图片2](图片暂时无法显示 - 请联系作者获取图片资源)

TL的”不足“

缺点： 1.**聚集效应,这是最致命的缺点**,一旦出现较长的连续占用块,任何哈希到该区域的key都需要很长的时间才能找到空位。 删除操作：非常复杂,因为不能简单的将数组槽位置空,具体的原因在TL的文章中详细讲过了

2.**内存泄露风险：** 在TL文章中讲过,这里的内存泄露分为两部分，一个是ThreadLocal本身的内存泄露,另外一个是entry和value的内存泄露。 而ThreadLocal对entry的key采用了弱引用来解决这个问题。 但是对于entry和value的内存泄露,虽然threadLocal采用了内部补救的方式,但是还是无法完全避免

3.**性能开销** 有一句名言：You don’t pay for what you don’t use ThreadLocal在get()/set()操作时,都可能会尝试做清理操作,虽然能够在一定程度上避免内存泄露，但是带来了额外的CPU开销

而在高并发,低延迟的网络通信中，jdk中的ThreadLocal的缺点会被无限放大,最终可能成为性能瓶颈,因此Netty设计了FastThreadLocal来代替ThreadLocal「从名字上就可以听出 ， 它应该很快」

## FastThreadLocal
那么应该如何避免TL的聚集效应呢？ 在这里先回顾一下TL的工作方式「简要介绍」：每一个tl对象都有hashcode,在调用tl.set()的时候，会使用这个hashcode来计算出它在map中entry[]的下标index，获取entry[index]上的entry对象 1.如果为空，那么创建一个新的entry，存放到到entry[index] 2.如果不为空,并且entry.key == 当前tl,那么使用新值覆盖旧值即可 3.**如果不为空，并且也不相等,那么会继续往后找**

<!-- 这是一张图片，ocr 内容为： -->
![图片3](图片暂时无法显示 - 请联系作者获取图片资源)



聚集效应最大的问题就是在第三步,第1步和第2步都是O(1)的,如果能够解决掉第3步的瓶颈,那么性能自然就上去了。 这还不简单? 从 线性探测法 换成 链地址法 不就行了？ 链地址法也有他的缺点，比如它的cache友好型就不如数组....「当然还有其他的不足」。

如果是基于数组的特性来做优化，应该如何做呢？ 为什么会出现上述的问题呢？因为通过每个threadLocal的hashcode「不管是什么黄金数字/黄金分割 」计算下标时，不可避免的会产生冲突，而产生冲突就可能会出现聚集效应。

那么是否可以从这里作为出发点呢？也即不要产生冲突？但是又没有一个完美的哈希算法来避免哈希冲突，应该怎么做呢？ -> 没有完美的哈希函数 -- 哈希冲突 -- 聚集效应

要解决这个死循环的方法有：1.找到一个完美的哈希算法 2.不要用哈希的方式来计算每个tl所在的位置

在这里FTL采用的则是第2种方式：也即不再采用hash的方式来决定每个FTL对象在数组中的下标，而是采用基于index，也即每一个FTL对象都有一个唯一对应的数组槽位「但是显然这会付出一定的代价」

### 源码解析
前提：使用FTL的前提是需要线程是FastThreadLocalThread(Netty内部的线程默认就是该类型的)

<!-- 这是一张图片，ocr 内容为： -->
![图片4](图片暂时无法显示 - 请联系作者获取图片资源)



下面开始介绍FTL是如何工作的

<!-- 这是一张图片，ocr 内容为： -->
![图片5](图片暂时无法显示 - 请联系作者获取图片资源)



+ **构造函数**

```java
public FastThreadLocal() {
    index = InternalThreadLocalMap.nextVariableIndex();
}
```

这里涉及到了一个核心属性index以及一个很重要的类InternalThreadLocalMap 对比一下ThreadLocal的构造函数, threadLocal在初始的时候计算hashcode, 而FTL在初始的时候计算index

```java
// 虽然构造函数为空,但是实际上执行的是如下代码(对象的初始化过程)
public ThreadLocal() {
   threadLocalHashCode = nextHashCode(); // 计算当前ThreadLocal对象对应的hashcode
}
```

+ **InternalThreadLocalMap类**

其结构为：

<!-- 这是一张图片，ocr 内容为： -->
![图片6](图片暂时无法显示 - 请联系作者获取图片资源)



```java
public final class InternalThreadLocalMap extends UnpaddedInternalThreadLocalMap {
    
    // 类属性 - 所有FTL对象共享的 
    // 这个属性是用于当线程不是FastThreadLocalThread类型时的退化操作 - 暂时不关心
    private static final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();
    private static final AtomicInteger nextIndex = new AtomicInteger();
    public static final int VARIABLES_TO_REMOVE_INDEX = nextVariableIndex()
    public static final Object UNSET = new Object();

    // .... 省略其他属性

    // 对象属性 - 每个FTL对象私有的
    private Object[] indexedVariables;

    // .... 省略其他属性
}

// 该方法的作用是返回nextIndex「返回的是旧值」的值并且递增
public static int nextVariableIndex() {
    int index = nextIndex.getAndIncrement(); // 返回0并且增加nextIndex的值(为1)
    // 异常处理....
    return index;
}
```

继续回到FTL的构造函数,可以看出每一个FTL对象在初始化时都会设置自己的index,并且这个index是自增的 结构如下： 这里就是和ThreadLocal不同的一点,不是采用hash值,而是index,每个FTL对象固定放在一个位置，永远不会产生冲突

<!-- 这是一张图片，ocr 内容为： -->
![图片7](图片暂时无法显示 - 请联系作者获取图片资源)



```java
public FastThreadLocal() {
    index = InternalThreadLocalMap.nextVariableIndex();
}


// 该方法的作用是返回nextIndex「返回的是旧值」的值并且递增
public static int nextVariableIndex() {
    int index = nextIndex.getAndIncrement();
    // 异常处理....
    return index;
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片8](图片暂时无法显示 - 请联系作者获取图片资源)



下面看下Netty中的线程：每个线程对象都有一个InternalThreadLocalMap属性，并且也是懒加载，应该是在线程第一次set('xx')的时候才会进行初始化

```java
public class FastThreadLocalThread extends Thread {
    // ... 省略其他属性
    private InternalThreadLocalMap threadLocalMap; // 每个线程对象都有一个InternalThreadLocalMap属性
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片9](图片暂时无法显示 - 请联系作者获取图片资源)



+ set()

```java
public final void set(V value) {
    getAndSet(value);
}
/**
    
    Set the value for the current thread and returns the old value.
    为当前线程设置值,并且返回旧的值
        1.如果要set的值是一个UNSET对象,那么调用removeAndGet() - > 这里先不关心
        2.否则设置的是一个普通的值
            1.先get()获取每个线程的map对象 「如果没有会进行初始化」
            2.调用setKnownNotUnset()方法
 */ 
public V getAndSet(V value) {
    if (value != InternalThreadLocalMap.UNSET) {
        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();
        return setKnownNotUnset(threadLocalMap, value);
    }
    return removeAndGet(InternalThreadLocalMap.getIfSet());
}
```

看下map的初始化过程 此时的结构如下：

<!-- 这是一张图片，ocr 内容为： -->
![图片10](图片暂时无法显示 - 请联系作者获取图片资源)



```java
// 只有Netty的线程才能使用FTL - fastGet()
public static InternalThreadLocalMap get() {
    Thread thread = Thread.currentThread();
    if (thread instanceof FastThreadLocalThread) {
        return fastGet((FastThreadLocalThread) thread); // fastGet()
    } else {
        return slowGet();
    }
}

// fastGet()
private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) {
    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap(); // 获取线程所属的map对象
    if (threadLocalMap == null) { // 如果为空,那么创建一个新的map对象,并且设置到当前线程中
        thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap());
    }
    return threadLocalMap;
}

// 构造函数
private InternalThreadLocalMap() {
    indexedVariables = newIndexedVariableTable();
}

/*
    创建 "entry[]" 数组
    private static final int INDEXED_VARIABLE_TABLE_INITIAL_SIZE = 32 初始容量为32
    public static final Object UNSET = new Object(); UNSET对象
*/
private static Object[] newIndexedVariableTable() {
    Object[] array = new Object[INDEXED_VARIABLE_TABLE_INITIAL_SIZE];
    Arrays.fill(array, UNSET); // 将数组的每一个位置都指向该UNSET对象,代表当前位置从来没有被set()过
    return array;
}

public static void fill(Object[] a, Object val) {
    for (int i = 0, len = a.length; i < len; i++)
        a[i] = val;
}
```

下面继续看set()方法

```java
public V getAndSet(V value) {
    if (value != InternalThreadLocalMap.UNSET) {
        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();
        return setKnownNotUnset(threadLocalMap, value);
    }
    return removeAndGet(InternalThreadLocalMap.getIfSet());
}
```

+ setKnownNotUnset()

```java
private V setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) {
    //  index 是当前FTL对象的index下标,在这里返回obj[index]的值,并且设置value值
    V old = (V) threadLocalMap.getAndSetIndexedVariable(index, value);
    // 如果old = UNSET,那么代表当前FTL对象之前没有set过,那么调用addToVariablesToRemove()
    if (old == UNSET) {
        addToVariablesToRemove(threadLocalMap, this);
        return null;
    }
    // 否则返回old值
    return old;
}
```

1.调用getAndSetIndexedVariable()设置value，并且返回旧值，从这个方法可以看到，Netty中的数组没有阈值这个概念,只有当tl对应的index 大于数组的当前容量时，才会扩容。这会导致什么问题？ -- **内存浪费(或者说空间利用率低,也即使用内存来换取性能)** 2.如果当前线程是第一次set(),那么还会调用addToVariablesToRemove()方法

```java
private V setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) {
    //  index 是当前FTL对象的index下标,在这里返回obj[index]的值,并且设置value值
    V old = (V) threadLocalMap.getAndSetIndexedVariable(index, value);
    // 如果old = UNSET,那么代表当前FTL对象之前没有set过,那么调用addToVariablesToRemove()
    if (old == UNSET) {
        addToVariablesToRemove(threadLocalMap, this);
        return null;
    }
    // 否则返回old值
    return old;
}

public Object getAndSetIndexedVariable(int index, Object value) {
    Object[] lookup = indexedVariables; 
    // 将新增设置到对应的槽位上,然后返回旧值
    if (index < lookup.length) {
        Object oldValue = lookup[index];
        lookup[index] = value;
        return oldValue;
    }
    // 如果index > lookup.length,那么进行扩容
    expandIndexedVariableTableAndSet(index, value);
    return UNSET;
}
```

继续看下addToVariablesToRemove()，当线程第一次调用某个FTL.set()时的额外操作 在这里每个线程中的map的数组对象的index = 0 都是一个Set<>集合,用来跟踪所有set过的FTL对象 此时的结构为：

<!-- 这是一张图片，ocr 内容为： -->
![图片11](图片暂时无法显示 - 请联系作者获取图片资源)

此时的结构

验证一下：

```java
public class Demo_5 {
    public static FastThreadLocal<String> ftl_1 = new FastThreadLocal<>();
    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        new FastThreadLocalThread(() -> {
            try {
                ftl_1.set("hello");
                InternalThreadLocalMap internalThreadLocalMap = InternalThreadLocalMap.get();
                Field field = internalThreadLocalMap.getClass().getDeclaredField("indexedVariables");
                field.setAccessible(true);
                Object[] indexedVariables = (Object[]) field.get(internalThreadLocalMap);
                System.out.println(indexedVariables[0]); // 断点打在这
            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }).start();
    }
```

<!-- 这是一张图片，ocr 内容为： -->
![图片12](图片暂时无法显示 - 请联系作者获取图片资源)



```java
private static void addToVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal<?> variable) { // variable是当前FTL对象
    Object v = threadLocalMap.indexedVariable(VARIABLES_TO_REMOVE_INDEX); // 获取线程对应map的entry[0]位置 - 默认为一个UNSET对象 - 这个位置是一个特殊的位置,专门用于存储需要被清理的FTL变量
    Set<FastThreadLocal<?>> variablesToRemove;
    if (v == InternalThreadLocalMap.UNSET || v == null) {
        variablesToRemove = Collections.newSetFromMap(new IdentityHashMap<FastThreadLocal<?>, Boolean>()); // 创建一个Set
        threadLocalMap.setIndexedVariable(VARIABLES_TO_REMOVE_INDEX, variablesToRemove); // 当该set集合设置到map中数组的第一个位置
    } else {
        variablesToRemove = (Set<FastThreadLocal<?>>) v;
    }
    // 将当前FTL对象添加到这个set中
    variablesToRemove.add(variable);
}
```

所以当线程第一次调用ftl-x.set(value)时会做以下事情： 1.将value设置到对应的槽位上去 2.如果是第一次设置,则可能会初始化一个set集合,然后将其添加到该set中进行保存 3.如果index > 数组的长度,那么还会出发扩容

下面再看下扩容的操作：expandIndexedVariableTableAndSet(index, value)，index是当前FTL对象的index,value就是要存储的值。「新容量计算 和 数组拷贝, 逻辑比较清晰」

```java
private void expandIndexedVariableTableAndSet(int index, Object value) {
    Object[] oldArray = indexedVariables;
    final int oldCapacity = oldArray.length;
    int newCapacity;
    /*
        1 << 30,一般不会有这么多的FTL对象
        下面这段代码是找到离index最近的一个2的次幂 来作为新的数组容量
    */
    if (index < ARRAY_LIST_CAPACITY_EXPAND_THRESHOLD) { 
        newCapacity = index;
        newCapacity |= newCapacity >>>  1;
        newCapacity |= newCapacity >>>  2;
        newCapacity |= newCapacity >>>  4;
        newCapacity |= newCapacity >>>  8;
        newCapacity |= newCapacity >>> 16;
        newCapacity ++;
    } else { // 不会走到这里
        newCapacity = ARRAY_LIST_CAPACITY_MAX_SIZE;
    }
    // 将旧数组中的数据拷贝到新数据中
    Object[] newArray = Arrays.copyOf(oldArray, newCapacity);
    // 设置新增加的数组位置为UNSET
    Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);
    // 将当前FTL对象对应的value设置到index上去
    newArray[index] = value;
    // 更新数组引用
    indexedVariables = newArray;
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片13](图片暂时无法显示 - 请联系作者获取图片资源)



下面来看下为什么在上面说FastThredLocal的设计其实是用内存来换取性能呢？ 之前介绍过,在创建FastThreadLocal的时候就会初始化每个FTL对象对应的index属性：注意在创建的时候就会初始化index（这会影响到InternalThreadLocalMap中的nextIndex属性 - - 因为每个FTL对象的index都是通过返回nextIndex属性 并且 递增它 来获取的）

<!-- 这是一张图片，ocr 内容为： -->
![图片14](图片暂时无法显示 - 请联系作者获取图片资源)



而在set()中,如果发现当前的FTL对象的index > indexedVariables[].length , 那么就会出发扩容。 前提：每个线程内部的map对应的数组的初始容量都为32（其中0位置是用来存放set集合的），剩下31个位置是用来存放对应的value值的，如果此时已经创建了32了FTL对象「 FTL-1 ~ FTL-32」,FTL-32的index = 32， 那么如果有个线程执行如下代码：

<!-- 这是一张图片，ocr 内容为： -->
![图片15](图片暂时无法显示 - 请联系作者获取图片资源)

数组容量为64

<!-- 这是一张图片，ocr 内容为： -->
![图片16](图片暂时无法显示 - 请联系作者获取图片资源)



```java
public class Demo_5 {
    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        for (int i = 0 ; i < 31; i++) {
            new FastThreadLocal<String>(); // 创建31个FTL对象
        }

        // 创建第32个FTL对象 - 该ftl对象的index应该为32 = length(所以会触发扩容)
        FastThreadLocal<String> ftl_32 = new FastThreadLocal<>();
        // 该线程只set了ftl_32,但是却要为其他没有使用到的ftl付出代价
        new FastThreadLocalThread(() -> {
            try {
                ftl_32.set("hello");
                InternalThreadLocalMap internalThreadLocalMap = InternalThreadLocalMap.get();
                Field field = internalThreadLocalMap.getClass().getDeclaredField("indexedVariables");
                field.setAccessible(true);
                Object[] indexedVariables = (Object[]) field.get(internalThreadLocalMap);
                System.out.println(indexedVariables[0]);
            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }).start();
    }
```

可以看到，由于Netty中的ThreadLocal采用的是基于index的方式，虽然避免了JDK中ThreadLocal的哈希冲突带来的影响，但是Netty中的每一个线程都需要为它没有使用到的FastThreadLocal预留空间，也即Netty是使用内存来换取性能的一种做法(当然,如果线程没有不需要的ThreadLocal「或者很少」，那么这里就不算缺点了)。

<!-- 这是一张图片，ocr 内容为： -->
![图片17](图片暂时无法显示 - 请联系作者获取图片资源)



下面来看下get()方法：正常逻辑就是返回index上的value即可，但是如果线程之前没有set()过,就调用get()方法，那么这里有一个扩展方法：initialValue() - 但是默认为null,所以这里的结构会有点奇怪： index = 1 位置上为存储的是null

```java
public class Demo_6 {
    public static FastThreadLocal<String> ftl_1 = new FastThreadLocal<>();

    public static void main(String[] args) throws InterruptedException {
        new FastThreadLocalThread(() -> {
            try {
                String str = ftl_1.get();
                System.out.println(str);
                InternalThreadLocalMap internalThreadLocalMap = InternalThreadLocalMap.get();
                Field field = internalThreadLocalMap.getClass().getDeclaredField("indexedVariables");
                field.setAccessible(true);
                Object[] indexedVariables = (Object[]) field.get(internalThreadLocalMap);
                System.out.println(indexedVariables[0]);
            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }).start();
        Thread.sleep(2000);
    }
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片18](图片暂时无法显示 - 请联系作者获取图片资源)



<!-- 这是一张图片，ocr 内容为： -->
![图片19](图片暂时无法显示 - 请联系作者获取图片资源)



```java
public final V get() {
    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get(); // 获取当前线程对应的map
    Object v = threadLocalMap.indexedVariable(index); // 获取当前FTL对象index所在的槽位上的对象
    if (v != InternalThreadLocalMap.UNSET) { // 如果不为UNSET,那么就返回该即可
        return (V) v;
    }
    // 否则代表,当前线程此前没有set()过,那么调用initialize()来进行初始化值
    return initialize(threadLocalMap);
}

private V initialize(InternalThreadLocalMap threadLocalMap) {
    V v = null;
    try {
        v = initialValue(); // 调用initialValue()值来进行初始化 - 默认实现为空,留给子类的扩展方法 - 默认为null
        if (v == InternalThreadLocalMap.UNSET) { // 不能初始化为UNSET,因为该值具有特殊意义,代表从未set过
            throw new IllegalArgumentException("InternalThreadLocalMap.UNSET can not be initial value.");
        }
    } catch (Exception e) {
        PlatformDependent.throwException(e);
    }
    // 否则v是正常的,那么设置到对应的index上,并且将当前FTL对象添加到set集合中
    threadLocalMap.setIndexedVariable(index, v);
    addToVariablesToRemove(threadLocalMap, this);
    return v;
}
```

下面在简单看一下“内存泄露”相关的内容： 在TL的文章中说过ThreadLocal的内存泄露包括“两部分”：

<!-- 这是一张图片，ocr 内容为： -->
![图片20](图片暂时无法显示 - 请联系作者获取图片资源)



但是在FastThreadLocal中,没有entry,所以在这里的引用情况为：

<!-- 这是一张图片，ocr 内容为： -->
![图片21](图片暂时无法显示 - 请联系作者获取图片资源)



在这里可没有entry,没有兜底的清理策略,那么Netty是如何处理的呢？ ThreadLocal虽然存在兜底策略，但是为什么要兜底呢？还不是因为没有调用remove()，才导致的性能下降「get()/set()如果遇到了stale entry，那么需要做清理操作」

那么如果调用了remove()，不就不存在这些问题了 如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![图片22](图片暂时无法显示 - 请联系作者获取图片资源)



```java
// 任务在Netty中会被包装为FastThreadLocalRunnable,
// 在run()方法中会主动的调用removeAll()做清理操作
public void run() {
    try {
        runnable.run();
    } finally {
        FastThreadLocal.removeAll(); 
    }
}

// removeAll()
public static void removeAll() {
    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();
    if (threadLocalMap == null) {
        return;
    }

    try {
        Object v = threadLocalMap.indexedVariable(VARIABLES_TO_REMOVE_INDEX); // 获取set集合
        if (v != null && v != InternalThreadLocalMap.UNSET) {
            Set<FastThreadLocal<?>> variablesToRemove = (Set<FastThreadLocal<?>>) v;

            // 将set集合转换为数组
            FastThreadLocal<?>[] variablesToRemoveArray =
                    variablesToRemove.toArray(new FastThreadLocal[0]);
            // 挨个处理数组中的每个FTL对象,调用它们的remove()方法
            for (FastThreadLocal<?> tlv: variablesToRemoveArray) {
                tlv.remove(threadLocalMap);
            }
        }
    } finally {
        InternalThreadLocalMap.remove(); // 最终清理
    }
}


// ftl.remove()
private V removeAndGet(InternalThreadLocalMap threadLocalMap) {
    if (threadLocalMap == null) {
        return null;
    }

    Object v = threadLocalMap.removeIndexedVariable(index); // 获取当前ftl对象对应index再数组中的value
    if (v != InternalThreadLocalMap.UNSET) { // 如果不为UNSET
        removeFromVariablesToRemove(threadLocalMap, this); // 那么将对应的位置设置为UNSET
        try {
            onRemoval((V) v); //钩子函数
        } catch (Exception e) {
            PlatformDependent.throwException(e);
        }
        return (V) v;
    }
    return null;
}

// InternalThreadLocalMap.remove() 将thread -> map的强引用 取消 
public static void remove() {
    Thread thread = Thread.currentThread();
    if (thread instanceof FastThreadLocalThread) {
        ((FastThreadLocalThread) thread).setThreadLocalMap(null);
    } else {
        slowThreadLocalMap.remove();
    }
}
```

到这里FastThreadLocal的简单介绍就到这里了。 核心要点： 1.使用index来代替hash 2.主动清理来彻底避免内存泄露

