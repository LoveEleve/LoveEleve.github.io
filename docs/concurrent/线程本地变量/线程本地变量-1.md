## ThreadLocal
jdk11 ThreadLocal学习

### 核心思想
核心思想是 **无锁化**

ThreadLocal的核心思想是提供了线程本地变量，避免了多线程之间**锁竞争**的开销，每个线程在操作数据的时候,实际上操作的是线程自己的数据副本，实现数据在线程之间的隔离。

如何做到线程隔离的呢？这里设计到几个类的共同协作

<!-- 这是一张图片，ocr 内容为： -->
![图片1](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQzMWQ3MjQ5N2M1MzhjYmJhNDNiYTU2YzM4NDA5OGZfTDdaNmdXdkF1aURxcjM0SWM0SHpGS0tlNXhOMXA5S3hfVG9rZW46WE5Yc2JrUENKb1dMQlp4RUl3WWNyVnphbjJmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



ThreadLocalMap类定义在ThreadLocal内部,但是是作为Thread类的一个内部属性

```java
public class Thread implements Runnable {
    
    // ...
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // ...
}
```

也即每一个线程都有对应的ThreadLocalMap

<!-- 这是一张图片，ocr 内容为： -->
![图片2](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NmODk2MWRiYmE4NzY3Mjg2MjZjMjZmZDhjYmViYjVfdTloaTRLNDEwWm5uTmJMcVhsY1UyaUswczdoakdoWkJfVG9rZW46VEtSaGJXRGllb0Jnc2V4TGJvU2NaWmlNbmJiXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")

ThreadLocalMap与Thread的关系

### 类关系图
<!-- 这是一张图片，ocr 内容为： -->
![图片3](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJkMmI4ZGZkN2UzM2E3NjQzZGEyZWNlODE0ODAzMDNfY0t3aTRzSFVnRlBldndGUU01NkpIRmhPdE9laEVDZ25fVG9rZW46WFBid2JlWFA4b2lUbXl4aFVid2MxMkdvbjZjXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



### 源码解析
<!-- 这是一张图片，ocr 内容为： -->
![图片4](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFlOTlhNTY5NjRhYmRhNmExYWYzNDRjMTFmMDA1MmJfNFNBOWR2TGlldnYxUXh6OXg4VXh1T1h2TVlEWUwyTUdfVG9rZW46WTlnUmJ4VUxIb2FGTTZ4cXZYZmNhV2xiblVnXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
/*
    构造函数为空,但是对象创建时,首先会初始化变量(包括类变量和实例变量)
    private final int threadLocalHashCode = nextHashCode(); // 实例变量,每一个threadLocal对象都有对应的hashcode
    private static AtomicInteger nextHashCode = new AtomicInteger(); // 类变量
    private static final int HASH_INCREMENT = 0x61c88647; // 类变量
*/
public ThreadLocal() {
}
```

此时的状态如下：

<!-- 这是一张图片，ocr 内容为： -->
![图片5](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NDRkMDJkNzc0ZjdmYzczMjkxN2NjMGEwOTMzYzE0NGFfMW9UQmVSRUljQ2RTVkc0Q2VIT1p2dWZKUVBuUXZNQ09fVG9rZW46UmxUTWJpUWNOb3J4Mk54WEhNM2NkUU5ZblVmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



这里的HASH_INCREMENT的作用等后续在说明,下面继续看代码

<!-- 这是一张图片，ocr 内容为： -->
![图片6](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M4YmNhYzUzODBkYjg1OGFjNzM2MjUxY2U2MWFkZDVfcnVNWlVUa003RmFuMmJqNGVnc21QcndFQzR0UW9Nck9fVG9rZW46T1NoTGJCeW5lb1F6ZnZ4OGU2aWNOcks5bnJmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
// 每个线程都通过set设置自己的值,在get的时候获取的就是直接设置的值
new Thread(()->{
    threadLocal.set("t-1");
}).start();

new Thread(()->{
    threadLocal.set("t-..");
}).start();

new Thread(()->{
    threadLocal.set("t-N");
}).start();
```

<!-- 这是一张图片，ocr 内容为： -->
![图片7](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE2ZTgyYTlkYjIzMzllMjYzNmUxNjRmNDU1ZTkwNzJfcm8xdmZlbVNmRG4yODVJWTZJMFg4Z2R1eU45TTdIclpfVG9rZW46Q2kyNmJEbmtHb2RaRkV4cGlldGNZQ0EzbjFjXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
public void set(T value) {
    Thread t = Thread.currentThread(); 
    ThreadLocalMap map = getMap(t); // 获取当前线程中的ThreadLocal.ThreadLocalMap threadLocals
    if (map != null) { 
        map.set(this, value);
    } else { // 首次set的时候,线程的map是为空的,则进入这里分支
        createMap(t, value);
    }
}

// 获取线程的的threadLocals属性,默认为null
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

创建threadLocalMap对象

```java
// 通过new操作符来创建ThreadLocalMap对象,并且将当前threadLocal对象以及线程要保存的值穿进去了
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

下面继续看该类的构造函数： 1.threadlocal对象和线程set的值会被包装为entry对象,存放在每个线程所对应的threadLocalMap中的Entry[]数组 2.对应的entry的存储位置和threadLocal对象的threadLocalHashCode有关

```java
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY]; // 创建Entry[],初始大小默认为16
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); // 获取当前threadLocal对应的hashcode,与数组长度-1 做与运算,得到存储的下标(但是可能会发生冲突),第一个threadLocal存储在map中的下标为0
    table[i] = new Entry(firstKey, firstValue); // 创建entry对象(threadlocal对象和线程存储的value会被包装为一个entry,然后存储到对应的下标中)
    size = 1; // 更新map中entry的数量
    setThreshold(INITIAL_CAPACITY); // 设置扩容阈值,默认为容量的2/3,在这里是10
}
```

此时的状态如下：

<!-- 这是一张图片，ocr 内容为： -->
![图片8](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRhYjRiMTA0OTNiNzkyNTYyZDRiM2JiNmY3Y2M2MzdfdGJrenJ0SGhhWW9YbG1QYWc3WVJ3YjRxTjFUOU1yTHJfVG9rZW46SXprd2IxWWtwb1Z0ZFB4Z1VvYWN3UTNwbkljXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



如果创建了多个threadLocal,并且set后，那么结构会是怎么样呢？ 和预想中的有点误差,在我编写的类中只有4个threadlocal,但是在Thread中的threadlocals中却有9个entry, 应该有些是jvm设置「在这里先不考虑这些值是什么」

<!-- 这是一张图片，ocr 内容为： -->
![图片9](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQ2NDc2Yjc4NzY1NmE1OTFkOWU0OGE5ZjA5MzVhMzZfbWlmejY3eDJKVGR2bG5PbGNvVmEzbmpvNGtPYWc0NDJfVG9rZW46UHpvN2J0Uzczb3VSeVd4MzNyaGNnTnUzbk9jXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
public class Main {
    public static ThreadLocal<String> threadLocal_1 = new ThreadLocal<>();
    public static ThreadLocal<String> threadLocal_2 = new ThreadLocal<>();
    public static ThreadLocal<String> threadLocal_3 = new ThreadLocal<>();
    public static ThreadLocal<String> threadLocal_4 = new ThreadLocal<>();
    public static void main(String[] args) throws InterruptedException {
        System.out.println("begin");
        Thread thread = new Thread(() -> {
            Thread thread1;
            threadLocal_1.set("1");
            threadLocal_2.set("2");
            threadLocal_3.set("3");
            threadLocal_4.set("4");
            thread1 = Thread.currentThread();
            System.out.println("hello");
        });
        thread.start();
        System.out.println("debug");
    }
}
```

下面再来看下map对象已经初始化后,再set()的代码逻辑

```java
public void set(T value) {
    Thread t = Thread.currentThread(); 
    ThreadLocalMap map = getMap(t); // 获取当前线程中的ThreadLocal.ThreadLocalMap threadLocals
    if (map != null) {  // 当map不为空时,直接set即可
        map.set(this, value);
    } else { 
        createMap(t, value);
    }
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片10](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA4Y2FlNjBiM2JkYmU1Mjg5ZWFiNTM4MjczZTEyZDlfN1hiaXo0VWZ0cmhzS1VCYklrTEhUSzhzaFZqNFQ4aTdfVG9rZW46SmV6R2JaenRxb3RaTHh4R0hoOWN3d0pSbmpkXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1); // 获取threadLocal中的threadLocalHashcode , 然后获取在Entry[]中的下标i

    for (Entry e = tab[i]; // 获取tab[i]对应的entry对象
         e != null; // 如果该位置不为空,那么进入到该for(;;)循环中
         e = tab[i = nextIndex(i, len)]) {

        ThreadLocal<?> k = e.get(); // 获取entry[i]中的threadlocal对象
        // 如果和当前set的threadlocal一致,那么说明是重复set,使用新值覆盖旧值,然后返回即可
        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) { // 否则如果entry[i]不为空,但是entry.threadlocal为空,那么说明threadlocal已经被回收了,当前entry是过期条目(stale entry),那么调用replaceStaleEntry()
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    // 否则当前threadlocal对应的下标entry[i]为空,或者产生冲突,向后找到了某个空位
    // 那么包装为entry对象,并且放入到entry[i]中即可
    tab[i] = new Entry(key, value);
    int sz = ++size; // 更新map中的entry数量
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

再进一步分析这个方法： 前提： 1.每个threadlocal对象都有自己的threadlocalHashcode,会根据该值计算threadlocal在线程的map中的下标 那么在这里的正常逻辑应该如下： 这里有个疑问：**后续看下能不能自己解决这个疑问**

<!-- 这是一张图片，ocr 内容为： -->
![图片11](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2MwMzA2NjNiNzg2N2VmMjkzMDZlZjE3YjQzYThiODRfWTIzRFE0U3phWE5wTklxWlV2aUE0TVhXMmswSmZvU0FfVG9rZW46UkF3b2I3djg2b3hscjJ4ZGV5TGMzTXo5bkVnXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



下面看下当entry[i]不为空,并且entry.threadlocal为空时的处理（被GC了）,此时会进入到replaceStaleEntry(key,value,i)方法中 此时的结构如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![图片12](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRlZDY2NWIyMDJlOWQ2YjM4MWFmODJmOWRiMTdjYjRfdGt1V0ZFWlF4MVVMQ1pNVXF2ZjdmSUF1bFVXNnNob2JfVG9rZW46Q1dUV2JCUEE3b1VsWnB4NmhneWNUOTlUbnFoXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



为什么会出现entry不为空,但是所包含的threadlocal为null呢？ 这是因为该threadLocal对象没有其他强引用了,如下图所示

<!-- 这是一张图片，ocr 内容为： -->
![图片13](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzc2NTA2YWNiOTc1YjI1N2NkYzI3Njc0YmNhNzY2ZWRfSmFrd1RNdEFEYTZ3eTRUTGVTRXQxRk1WU3FSczFLYndfVG9rZW46UGk0ZmJWbkJFb3loWUh4bkpxSWNEUGRRblFnXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



下面进入到replaceStaleEntry(key, value, i)方法中：参数为当前set()的threadlocal对象,value值,和过期entry所在的数组下标。 在阅读方法的具体实现之前,再次回顾一下前提：threadLocal-2 简称 tl-2 , 过期的threadLocal简称tl-stale 1.**tl-2调用set('xx')方法想要存储到对应的map中，但是根据当前tl-2的tlhashcode来计算出的entry数组下标index上已经存在entry对象了「或者是index上的entry不为空,那么说明产生了冲突了,需要继续往后找,此时的index并非tl-2通过hashcode计算出来的位置」** 2.但是该entry对象中的tl对象为空 3.那么会调用replaceStaleEntry(key, value, i)来替换这个过期的entry(replace stale entry) 那么正常的实现逻辑应该如下： 1.将当前的key(也就是tl-2)和value包装为entry 2.放入到entry[index]中「因为entry[index]上存储的是过期entry，直接替换掉是没有关系的」

<!-- 这是一张图片，ocr 内容为： -->
![图片14](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg2MWVjNjlhMWZjODZhMTE1NGUxMzdlODA3M2M0YzFfRkx3Rk1IckZGcktnalNaNWZZRERGT21ZUGI1Mm9Mem5fVG9rZW46SlZzT2JjeWVVb3VURXl4Z1hEVmNyd3FhbnBkXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {   
     Entry[] tab = table;
     int len = tab.length;
     Entry e;
     entry[staleSlot].value = null; // 将过期entry的value设置为空
     e = new Entry(key,value); // 然后直接覆盖即可
     tab[staleSlot] = e;
}
```

这样的实现很简单,同样也很容易理解,但是doug lea并没有选择这么做,下面分析doug lea的代码,先看doug lea的注释文档.

1. Replace a stale entry encountered during a set operation withan entry for the specified key: 在set的过程中,使用指定key的entry (这里指tl-2)来替换过期的entry
2. The value passed in the value parameter is stored in the entry, whether or not an entry already exists for the specified key. 无论指定的key是否已经存在对应的entry,都会参数中传递的value存到entry中
3. As a side effect,this method expunges all stale entries in the "run" containing the stale entry. 方法的副作用：它会清除包含该过期entry的 "run"内的其他过期条目
4. (A run is a sequence of entries between two null slots.) run指的是两个空槽位之间的连续entry

```java
Replace a stale entry encountered during a set operation with an entry for the specified key.  

The value passed in the value parameter is stored in the entry, whether or not
an entry already exists for the specified key.

As a side effect, this method expunges all stale entries in the "run" containing the stale entry.  
(A run is a sequence of entries between two null slots.)
```

继续看第一段代码的文档注释：

1. 向前回溯检查当前run中更早的过期entry
2. 由于垃圾回收起会批量的释放引用，所以我们一次性清理整个run,避免持续的增量rehash操作

```java
Back up to check for prior stale entry in current run. 向前回溯检查当前run中更早的过期条目
We clean out whole runs at a time  我们一次性清理整个run
to avoid continual incremental rehashing  避免持续的增量rehash
due to garbage collector freeing up refs in bunches 由于垃圾回收器批量释放引用
(i.e., whenever the collector runs) 每当收集器运行时
```

继续看代码： 这里先解释一下第一行代码：对应的staleSlot有3种情况 这里对应case-1,case-2和case-3

<!-- 这是一张图片，ocr 内容为： -->
![图片15](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q0NTExMmE3OWFmNTBkYTllNjI3YjY4MDNkZjMxMGJfNFh4MlpFQ3M2QWxGcWpRbERpRXJtanZlVGFMNm5DRlVfVG9rZW46WEpnTGJNQmJHb3JGdjR4SWVmWWNLQ1dWbkhoXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
private void replaceStaleEntry(ThreadLocal<?> key, Object value,
                               int staleSlot) {
    Entry[] tab = table; // 获取entry[]
    int len = tab.length; // 获取entry数组的长度
    Entry e;
    /*
        # 1 保存过期的entry下标,这个下标是根据tl-2的hashcode计算出来的index再进一步判断,
            可能就是index
            或者是从index向后一直找,找到的第一个stale entry所在的下标(可能已经跑到index前面去了)
    */ 
    int slotToExpunge = staleSlot; 

    // .....
}
```

继续看下面的代码：

```java
private void replaceStaleEntry(ThreadLocal<?> key, Object value,
                               int staleSlot) {
    Entry[] tab = table; // 获取entry[]
    int len = tab.length;
    Entry e;

    int slotToExpunge = staleSlot; 

    // 当这段代码执行完毕,slotToExpunge就是当前staleSlot到第一个为null的slot这段距离中,最"靠前"的一个stale entry
    for (int i = prevIndex(staleSlot, len); // 获取前一个下标i
         (e = tab[i]) != null; //  e = entry[i]不为空
         i = prevIndex(i, len))
        if (e.get() == null) // 如果e是一个stale entry
            slotToExpunge = i; // 那么设置slotToExpunge = i

        // 省略下面代码
}

// int i = prevIndex(staleSlot, len); 获取当前staleSlot的前一个下标
private static int prevIndex(int i, int len) {
    return ((i - 1 >= 0) ? i - 1 : len - 1);
}
```

用图来介绍上述代码的含义吧：就是向前找到第一个null slot，并且离这个null slot最近的stale entry下标 此时的slotToExpunge = 2

<!-- 这是一张图片，ocr 内容为： -->
![图片16](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIzOTQzNDk0MTE5Y2I5NzgzNmQ5ZWQ2YWFiNmIwMThfR1l0dHk2TEhtdG8zMlJZZTRzT1RtWTJxcDVnZ0IxUFVfVG9rZW46UUt5Q2JnSkhvb3BVNFZ4TTYxSmNHNW10bjRjXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



继续看下面的代码：先看下文档注释 查找指定的key或者找到"run"的结尾,先遇到哪个就处理哪个。 前面说过run指的是包含当前stale entry 的两个null slot之间的所有entry，而在上面的代码中已经找到了往前遇到的第一个null slot(但是真实保存下来的其实是最近的一个stale entry , 使用slotToExpunge来记录) 那么接下里就是向后找。

```java
Find either the key or trailing null slot of run, whichever occurs first
```

注意此时的前提： tl-2调用set('xx'),但是通过tl2.hashcode计算出来的index，在e = entry[index]上不为空,这代表发生了冲突，那么需要继续向前找,但是在找的过程中：在找到空位以及找到和当前tl2相等前，遇到了一个entry不为空，但是其内部的threadlocal为空entry，然后会进入到replaceStaleEntry()方法中，并且在上面已经找到了run的”开始“(并非是null slot,而是最近的一个stale entry，并且使用了slotToExpunge来记录)

在看代码前还是先阅读一下doug lea 写的文档注释

1. If we find key, then we need toswap it withthe stale entry tomaintain hash table order 若查找到key,则需要将其与stale entry 交换位置以维持hash table的顺序
2. The newly stale slot, or any other stale slot encountered above it, can then be sent toexpungeStaleEntrytoremove or rehash all of the other entries in run. 随后便可以将新产生的stale entry，或者在此过程中遇到的任何其他stale entry 交由给expungeStaleEntry()方法处理，以处理或者rehash运行段中的所有其他条目

```java
If we find key, then we need to swap it with the stale entry to maintain hash table order. 
The newly stale slot, or any other stale slot encountered above it, 
can then be sent to expungeStaleEntry to remove or rehash all of the other entries in run.
```

下面在来看代码：下面代码的目的有两个： 1.找到tl-2存储的entry,如果有的话，那么将交换更新tl-2的值,并且与stale entry进行位置交换，并且更新清理的开始位置(前提是在上面的代码中没有找到需要清理的stale entry) - 图-1为向前找到了对应的stale entry - 但是依旧会交换位置 - 图-2为向前没有找到对应的stale entry - 但是依旧会交换位置

<!-- 这是一张图片，ocr 内容为： -->
![图片17](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJkZmY5ZWNhMTBmNTc1YzQ4OTk0NzMxNTQyODI1YzRfZ0kxUDBnaEI4b2RnMUpJWGc3enE5cm1abUZKMWdFNjJfVG9rZW46SUxIa2J1YnNQb0xSbVB4dlVWMmNOVDRzbnRmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")

图-1

<!-- 这是一张图片，ocr 内容为： -->
![图片18](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUxNjVlMzdhZDllMTZlYjk3ODg0ZmY2MzI2NjE3YTlfNG5JVmtEQ0NOV0JHQXdVaXpCOFlQZFk0aENVTXQwQ1lfVG9rZW46WDNxZWJvQTFDbzU2dFN4dmhCbWNVUHMybklkXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")

图-2

2.否则：tl-2在之前根本没有set过,那么if (k == key)就永远不会执行。那么在这里做的事情和上面的代码一样,向后找到第一个为null的slot，然后判断key是否为null并且在上面向前找时没有找到stale entry，那么在这里更新清理的开始位置，否则不更新 同上：不过不会交换位置,会一直向后找, 同样更新slotToExpunge的条件也是和之前一样，直到找到一个null slor，才会结束当前for循环

```java
private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) {
    
    // ....
for (int i = nextIndex(staleSlot, len); // 获取下一个索引
             (e = tab[i]) != null; // 如果其不为空
             i = nextIndex(i, len)) {

            ThreadLocal<?> k = e.get(); // 获取entry对应的threadlocal

            if (k == key) {  // 如果就是当前key,说明之前已经set过一次了
                e.value = value; // 在这里使用新值覆盖旧值
                tab[i] = tab[staleSlot]; // 将stale entry 放到 i 位置上 
                tab[staleSlot] = e; // 将当前entry 放到 stale slot 上

                // Start expunge at preceding stale entry if it exists
                if (slotToExpunge == staleSlot) // # 1  如果 slotToExpunge == staleSlot),那么这意味着什么？说明在前面向前找的时候,在遇到第一个null slot时,这之间没有任何一个stale entry
                    slotToExpunge = i; // 那么将清理的开始位置更新为i,否则保持不变

                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); // # 2 这里会执行两个方法
                return; //返回
            }

            // If we didn't find stale entry on backward scan, the
            // first stale entry seen while scanning for key is the
            // first still present in the run.
            if (k == null && slotToExpunge == staleSlot) // # 3 否则当前k不等于key,并且为空 - 说明向后找到了一个过期条目,并且在上面向前找时,没有找到stale entry,那么将清理的开始位置更新为i,否则保持不变
                slotToExpunge = i;
        }

}

// 获取当前索引的"下一个"索引 - 循环
private static int nextIndex(int i, int len) {
    return ((i + 1 < len) ? i + 1 : 0);
}
```





如果找到了old entry「也即之前set()过，这里我还是有个疑问，等下再说」，那么就没有后续代码了。 否则就是在往后找到第一个null slot之前,没有找到old entry，但是不管怎么样：slotToExpunge是清理的开始下标 那么继续看下面的代码： 「疑问：是否会出现old entry 在 后面的第一个null slot 后面？」 如下图：此时就结束循环了,继续下面的代码

<!-- 这是一张图片，ocr 内容为： -->
![图片19](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2MxNjQ4YjlhNzRmYmM0YTc1ODI0ZjZjMTBiODM1NDVfVTZwOUFJVDJYbnpLbTVmdlZOWld0bW52NWUxNThJMHRfVG9rZW46TDE2aWJGY0NpbzV5MFB4cjFXMGNRSHlFbmhjXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
// 获取当前索引的"下一个"索引 - 循环
private static int nextIndex(int i, int len) {
    return ((i + 1 < len) ? i + 1 : 0);
}

// If key not found, put new entry in stale slot 如果没有找到key,那么放一个新的entry,到这个stale entry上
tab[staleSlot].value = null; // 清理stale entry 上的 value
tab[staleSlot] = new Entry(key, value);

// If there are any other stale entries in run, expunge them
if (slotToExpunge != staleSlot) // 如果向前没有找到过期entry,那么不会执行这段代码,否则继续执行
    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
```

如下图：如果slotToExpunge != staleSlot，那么代表在这之前有需要被清理的entry，那么调用另外两个方法

<!-- 这是一张图片，ocr 内容为： -->
![图片20](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGM1YzlmNDMzZDE3ZWM3NWQyZDAxNGIyODEzMzE5NGFfM2ZmRXZrclVmTmFxeDIzWEozTlBMSkVYVVVZN1ptTWpfVG9rZW46QkhWb2JFTFo2b2FVRzd4a2F5SWNTMHdubjEwXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



疑问：如下图所示

<!-- 这是一张图片，ocr 内容为： -->
![图片21](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM0NzU3ZTg0ZGE3NDA5NzBmMzI2N2EwYzNkNjY3ZWZfU0NrQmtJMVpqVFNuUGdtSVRWelJSWXM5NU11MUhhZ1ZfVG9rZW46SmxuTmI1c2pmbzduQk94VHhWZWNOV2JTbk1zXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



这个疑问先保留,继续看后续两个清理的方法：

<!-- 这是一张图片，ocr 内容为： -->
![图片22](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjEzMmRlZjIzNDgxYzdiY2FkNDQxMzBhM2M5OTY0MzVfYnlydVdKaG1pVThxNnNYN0Y4cGQxQVlKQWRKSnlQTVdfVG9rZW46UXlUMGIxSFNzb2JWcmp4YVdOcGM1Y28wbjZjXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



+ expungeStaleEntry(int staleSlot)： 参数为清理的开始下标 返回值：返回在staleSlot之后遇到的第一个null slot的下标

同样在开始阅读这个方法之前，先阅读一下doug lea写的关于这个方法的文档注释

1. Expunge a stale entry 清理一个stale entry by rehashing any possibly colliding entries lying between staleSlot and the next nullslot. 对位于已知stale entry 的索引(staleSlot) 和 下一个null slot 之间所有的条目进行rehash
2. This also expunges any other stale entries encountered before the trailing null. 在执行rehash的过程中,如果在这个区间内(从staleSlot到下一个null之间)遇到了其他stale entry，会一并清理它们的value，并且将其槽位置空
3. See Knuth,Section6.4 计算机科学名著 _**Donald Knuth**_&#x7684;**《**&#x54;he Art of Computer Programmin&#x67;**》**（计算机程序设计艺术）第 6.4 节 在这一节详细的讨论了哈希表的各种算法,这里使用的正是其中一种标准的删除处理算法

```java
Expunge a stale entry by rehashing any possibly colliding entries lying between staleSlot and the next null slot.  
This also expunges any other stale entries encountered before the trailing null.  
See Knuth, Section 6.4
```

下面进入到代码中：代码解释如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![图片23](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE5YWRkNGY1YmE1MDQ3Y2Q3NmVlYTEyMzMzYzdkMzZfTVd2QlpZWlo0cjJtU2xweHUyaUF6VmkxVmpBZzBVTG5fVG9rZW46V0NQNGJ5QWFjbzNBbkR4cWR4VmN1dGR6bjVmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



那么再来解释一下为什么这里的操作能够解答我上面的疑问：

<!-- 这是一张图片，ocr 内容为： -->
![图片24](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=OGI4YThlMjFhYzE2NjU3ZWYxNzNiMTEzYzcxNjYzNmFfT0h1RFV4YU5QYmsySzdZN2xYMUp3UWdtd1A4N0RGR0tfVG9rZW46QlFQR2JTWDhOb0xielB4cm9BQWNhdXphbnljXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



问题的关键点：是否会存在某个entry会在null slot的后面呢？ 1.因为需要知道的是当发生冲突后,向后找位置并且停下来的条件是：找到一个null slot然后放进去。但不会跳过null slot。所以从这个角度来考虑,是不会出现上面的情况的 2.但是有可能是其他的tl被回收掉了,形成了stale entry：如下图所示

<!-- 这是一张图片，ocr 内容为： -->
![图片25](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MmUxOGYxZGVmOGYzNDc1YWEwMzc1MGE3NzFlNmMzYzFfUHpudnIwSXZVN2FQRE80TGNsc25pNDVKZTlDUjNESGNfVG9rZW46SGdzeGJpNGtIb1lHNXl4RTNtcGNCV1B0blFmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
private int expungeStaleEntry(int staleSlot) { // staleSlot是清理的开始位置：对应着slotToExpunge变量

    Entry[] tab = table; // 获取entry[]数组
    int len = tab.length; // 数组长度

    // expunge entry at staleSlot
    tab[staleSlot].value = null; // 将staleSlot对应的stale entry中的value和entry置为空
    tab[staleSlot] = null;
    size--; // 更新map中的entry数量

    // Rehash until we encounter null rehash直到遇到null slot
    Entry e;
    int i;
    for (i = nextIndex(staleSlot, len); // 从stale entry开始,往后处理
         (e = tab[i]) != null; // 不为空
         i = nextIndex(i, len)) {

        ThreadLocal<?> k = e.get(); // 获取entry中的threadlocal

        if (k == null) {  // 如果为空,那么代表当前是一个stale entry,那么清理
            e.value = null;
            tab[i] = null;
            size--;
        } 
        else { // 否则不等于空

            int h = k.threadLocalHashCode & (len - 1); // 获取当前entry对应的threadlocal对应的threadlocalhashcode - 并且计算出他在entry[]数组中的下标 h(本来应该在的位置)

            if (h != i) { // 如果 h(本来应该在的位置) != i(现在的位置),那么说明当前threadlocal不应该在这个位置(之前产生了冲突)

                tab[i] = null; // 将当前位置设置为null

                // Unlike Knuth 6.4 Algorithm R, we must scan until
                // null because multiple entries could have been stale.
                while (tab[h] != null)  // 从它本来应该在的位置开始向后找,直到找到一个为null的位置,然后将其放进去
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i; // 这里的i是从staleSlot开始向后遇到的第一个null slot的 index
}
```

<!-- 这是一张图片，ocr 内容为： -->
![图片26](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIxMTg3NjRmNDRmYjhhNzUxNmVhZjg1OTZhZmRjMzRfemNObVhyZlhWeTA0Mmt4TGYxcFZnVjdCYTVxSlJtcjJfVG9rZW46RWc5ZWJ3VXJUb2V3Z014WjVsNmNiMGtObjVkXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



下面就进入到另外一个方法：cleanSomeSlots(int i ,int n) 参数： int i : 是expungeStaleEntry()返回的从slotToExpunge向后遇到的第一个null slot int n : entry的长度

首先就是为什么要有这个方法? expungeStaleEntry()还不够吗？ 因为expungeStaleEntry()被调用的前提是：发生了冲突并且发现了stale entry,如下面代码所示

```java
private void set(ThreadLocal<?> key, Object value) {

Entry[] tab = table;
int len = tab.length;
int i = key.threadLocalHashCode & (len-1);

for (Entry e = tab[i];
     e != null;
     e = tab[i = nextIndex(i, len)]) {
    ThreadLocal<?> k = e.get();

    // ..
    if (k == null) { // 发现stale entry
        replaceStaleEntry(key, value, i); // 内部会调用expungeStaleEntry()
        return;
    }
}
```

但是如果没有发现stale entry呢？当前tl向后找到了一个null slot,并且在找的过程中没有发现stale entry，那么将不会主动调用replaceStaleEntry()方法来做清理。这样会导致内存泄露和哈希表的效率下降。

所以提供了cleanSomeSlots()方法来做清理。 但是又不能从entry[]的第一个元素开始清理，这会导致每次set的操作都变为O(N)，所以在这里采用的是轻量级的启发式的清理。从已知的非stale entry开始做清理。并且初始时默认只尝试log(size)次「size是当前map中的entry个数」

比如map中只有3个元素,那么只会尝试一次，如果一次没有找到过期的entry,那么就结束set方法. 但是如果找到了一个，那么说明什么？因为gc工作时,是一次性的清理垃圾，所以这意味着entry[]数组中有很大可能：还存在其他的stale entry，那么会更新清理的次数为logn(len)次「len是数组的长度，而不是元素的个数」

那么为什么在replaceStaleEntry()会同时调用两个方法呢？ 因为expungeStaleEntry()方法只会清理run段之间的stale entry以及rehash操作，其他部分是不会处理的，所以需要从一个非stale entry开始,调用cleanSomeSlots()来做处理。

```java
private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table; // entry[]数组
    int len = tab.length; // 数组长度
    do {
        i = nextIndex(i, len); // 从i的next index开始(i是已知的一个非stale entry的index,比如null slot)
        Entry e = tab[i];

        if (e != null && e.get() == null) { // 如果遇到的是stale entry,那么再次调用expungeStaleEntry()来做清理操作
            n = len; // 如果找到了,那么更新n为len「默认是size」
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n >>>= 1) != 0); // 执行log2(n)次

    return removed; // 最终返回此次是否清理了stale entry
}
```

下面在回到set()方法中

```java
private void set(ThreadLocal<?> key, Object value) {

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    // .....

    // 走到这里说明：在set的过程中没有找到stale entry,并且有null slot,那么直接set到该null slot中即可
    // 然后调用cleanSomeSlots()做启发式的清理,如果此次清理了stale entry,那么是不会去判断阈值的
    // 否则没有清理到元素：并且超过了阈值,那么进行扩容操作

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

下面在看下扩容操作

```java
private void rehash() {
    expungeStaleEntries();

    // 正常扩容的阈值时2/3,但是在这里使用的是3/4,如果清理后还是不行,那么进行扩容
    // resize()就是普通的数组拷贝,不再赘述
    // Use lower threshold for doubling to avoid hysteresis
    if (size >= threshold - threshold / 4)
        resize();
}



// 清理整个entry[]
private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    for (int j = 0; j < len; j++) {
        Entry e = tab[j];
        if (e != null && e.get() == null)
            expungeStaleEntry(j);
    }
}
```

在这里总结一下threadlocal做清理的时机：

<!-- 这是一张图片，ocr 内容为： -->
![图片27](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NDFkYWQ0OWI1N2E4ZTBjMmUwZTU3MWE0OGU2M2NkOTBfbmJMU2lEUFg5S1VTdmQ0eUEwY2tkeDRRT3Q2QTV6UmJfVG9rZW46RnQzT2J3ZkFxbzk4Q094cFNPWWNsdDhTbkRnXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



下面在介绍一下get()方法：代码很简单,不在赘述，不过要更新一下清理的时机

<!-- 这是一张图片，ocr 内容为： -->
![图片28](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQzNzAwZGNkZGRhYjBmZTNjOTljNTJkNzNkZDkyY2NfazlsaEFQajY1cmhxaGl2bGtReU9Ta0sxN05CWlpNQnZfVG9rZW46VFdhcmIzZmtDbzE3RVh4T3lKaGNYQU5qbnBiXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
public T get() {
    Thread t = Thread.currentThread(); // 获取当前thread
    ThreadLocalMap map = getMap(t); // 获取thread中的map
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this); // 从map中获取当前threadlocal对应的entry
        if (e != null) { // 如果不为空,那么返回对应的value即可
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    // 如果map或者entry为空,那么在调用get时会返回setInitialValue()中的值
    return setInitialValue();
}

private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1); // 获取当前threadlocal应该在entry[]中的下标
    Entry e = table[i];
    if (e != null && e.get() == key) // 如果在entry[i]中不为空并且就是当前tl,那么返回value即可,否则产生了冲突,或者为null,继续调用后续方法
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}


private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal<?> k = e.get();
        if (k == key)
            return e;
        if (k == null) // 如果遇到了stale entry,那么做清理操作
            expungeStaleEntry(i);
        else // 否则继续往后找
            i = nextIndex(i, len);
        e = tab[i];
    }
    // 没有找到,返回null
    return null;
}
```

问题：为什么要将Entry基础WeakReference,并且使用WeakReference中的referent来保存threadlocal呢？ 换句话说：entry对threadlocal的引用是弱引用。

而弱引用的作用：如果一个threadlocal对象没有其他强引用指向它(比如被赋值为null),那么在下次垃圾回收的时候,这个threadlocal对象就会被回收。

那么为什么要这么设计呢？换句话说为什么entry对threadLocal的引用要被设计为弱引用呢？

这里就会涉及到内存泄露,假设entry对threadlocal的引用是强引用，那么会出现什么样后果？ 这里举一个例子来说明：

```java
public class HelloWorld {
    public static ThreadLocal<String> thread_Local = new ThreadLocal<>();
    public static void main(String[] args) {
        new Thread(()->{ 
            thread_Local.set("1");
        }).start();
     
    }
}
```

上面这段代码对threadlocal有几个强引用？2个,如下图所示：

<!-- 这是一张图片，ocr 内容为： -->
![图片29](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYwNmIxZGE0YjZmZTg3OTZhNDczYzIyZWZjMTZjNzBfNTB0dGtzS0N4OHhDV2RtalNXdHllQUJBd1Fyd2YyNWVfVG9rZW46RDQzNmJkaENFb21QdWp4czRzbGN5QUFsbkdoXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



此时你写了下面这行代码：你认为这个变量所占的内存在垃圾回收的时候会被清理掉，但是实际上,由于上面的线程可能一直存活(比如作为线程池的核心线程),这就会到另外一条路线会一直强引用着该threadlocal对象，导致该threadlocal不能再被访问，同时也无法被回收 - 也即内存泄露 「造成这个问题的原因就在于：threadlocalmap的生命周期和thread是一致的」

<!-- 这是一张图片，ocr 内容为： -->
![图片30](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU0ZDY5NDc4NTllOWFlN2Q0MjYzZjA4MzBjY2RmYTFfT2ZUUlFDSXpMV3g5dm5hY3FkZ3VPM1RNWWpSSm1kWGxfVG9rZW46RkFia2J1OVBrbzlWaGh4eG1yVmNubWVpbm1kXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



```java
thread_Local = null;
```

但是如果采用弱引用后,结果会如何呢？ 由于此时threadlocal对象没有强引用对象引用它,那么在下一次gc的时候就会回收该threadlocal对象，避免了threadlocal对象本身的内存泄露

<!-- 这是一张图片，ocr 内容为： -->
![图片31](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NTg4MDA2ZjhiYzVjZGI5YmYzYjJkZTAxZjQ4OWUyYjVfenJOSU5KWjMwSGcwV0NWRkNTS3Q1Ykg3VlBjYTU3cGFfVG9rZW46SHl3S2JBVmsyb0RIZld4V1lqR2N3ZU9PbnVlXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



注意：这里entry对threadlocal的引用采用弱引用的目的(或者说设计初衷)是为了解决threadlocal对象本身的内存泄露。

但是这会存在另外一个隐式的内存泄露：那就是entry和value对象的内存泄露。因为entry对value依旧是强引用。 当entry中的threadlocal被回收了,那么无法通过threadlocal来访问到对应的entry以及value了

<!-- 这是一张图片，ocr 内容为： -->
![图片32](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MGNlNGFlYzVlNTc4YTI0YzQ5NDBkYjVkYmVjYjY4YjdfVTlvT2RqQlpHQmk1Q3RqS1R3VzBCd2pJcFBjS3k0NkdfVG9rZW46WW11YWI5VWtYb2lLNnR4bDlpY2NJcFA3bmtmXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



那么如何解决呢？如果不用了，那么remove掉 - threadlocal.remove()

```java
public void remove() {
     ThreadLocalMap m = getMap(Thread.currentThread());
     if (m != null) {
         m.remove(this);
     }
 }

private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) { // 找到key所对应的entry,调用clear(),并且从这里可以看出,remove()操作也会做
            e.clear();
            expungeStaleEntry(i); // 清理当前entry,因为i代表的是清理的起始位置,在该方法中会将entry和value设置为null
            return;
        }
    }
}

public void clear() {
    this.referent = null; // 将当前entry中对tl的弱引用清理掉
```

<!-- 这是一张图片，ocr 内容为： -->
![图片33](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJhMzk1YmZiYzZiMWU0ZGQzMmI5Mjk0MzA0M2Q0MTBfVTJEZmVQcG9BTFR3VjhvdEFFWU1ORFRxb3M2dkRvd21fVG9rZW46T1Ezd2J3YVEzb1RqZWt4V1ZDRGNSZEZBbjllXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



在这里又需要更新一下清理的时机：

<!-- 这是一张图片，ocr 内容为： -->
![图片34](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU1NjlhOTkyOGIxZmY0NDFiNTUwOWZiZDVmNzllMTNfU2cwcnRIVmRPZ2xTYzh3ZlVRemdubFcwODA2MHJSMENfVG9rZW46QnRudWJRcG9Ybzk0S1F4eUk2UmNncmpCbnFnXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



在这里总结一下内存泄露：

<!-- 这是一张图片，ocr 内容为： -->
![图片35](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=NDg3NzVhZWM0YjA5YjY5ZDlkMjY0ZjMzN2NmYmEyM2ZfNWRPTmlkUWVwM2FoWWliNGFXWnV4Z0RsT2NvY2tXOElfVG9rZW46S3lDM2JpOWxGbzVCMXB4bUdXMWNDbjhqbmFlXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")



到这里关于threadlocal的介绍就介绍了,后续代补充的内容如下：

<!-- 这是一张图片，ocr 内容为： -->
![图片36](https://scnjnj9snmp7.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDlhYWZjNmU4MDViNDM3Zjc2ZmUyNWYxZDViOWZhNjRfNEhtcFY2ZHJDS1h3aWt2OUM3enVxV1VuMEdBYVhva2FfVG9rZW46U2NCc2JoOGxmb2hTSXN4Vk1LNGNMT0xJblZpXzE3Njg2NTU2NzU6MTc2ODY1OTI3NV9WNA "图片链接可能已过期，如无法显示请联系作者")

