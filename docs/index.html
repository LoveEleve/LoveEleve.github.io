<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>LoveEleve's Tech Blog</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
  <meta name="referrer" content="no-referrer" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar.min.css" />

  <style>
    :root {
      --theme-color: #42b983;
      --sidebar-width: 250px;
      --content-max-width: 850px;
      --base-font-size: 13px;

      --code-border: rgba(0, 0, 0, 0.06);
      --code-toolbar-bg: #f6f8fa;
      --code-gutter-bg: #f6f8fa;
      --code-text: #24292f;
      --code-muted: #8b949e;
    }

    /* ä¾§è¾¹æ ï¼šç®€å•çš„æ ¼å¼å¯¹é½ä¿®å¤ */
    .sidebar-nav ul li a {
      font-weight: normal !important;
    }

    /* ä¾§è¾¹æ ï¼šé¦–é¡µä¸å±•ç¤º"é¡µé¢å†…ç›®å½•" */
    .sidebar-nav a[href="#/"] + ul,
    .sidebar-nav a[href="#/README"] + ul {
      display: none !important;
    }
    .sidebar-nav a[href="#/"]::after,
    .sidebar-nav a[href="#/README"]::after {
      display: none !important;
    }

    /* ä¾§è¾¹æ ï¼šç»Ÿä¸€äºŒçº§èœå•é¡¹çš„æ ¼å¼å¯¹é½ */
    .sidebar-nav > ul > li > ul > li > a,
    .sidebar-nav > ul > li > ul > li:not(:has(a)) {
      font-size: inherit !important;
      line-height: inherit !important;
      padding-left: 20px !important;
      margin-left: 0 !important;
      font-weight: inherit !important;
    }

    /* éšè—æ‰€æœ‰åŸæœ‰çš„ç®­å¤´å’Œå±•å¼€ç¬¦å· */
    .sidebar-nav .folder-button,
    .sidebar-nav .folder-button::before,
    .sidebar-nav .folder-button::after,
    .sidebar-nav li::before,
    .sidebar-nav li::after,
    .sidebar-nav a::before,
    .sidebar-nav a::after {
      display: none !important;
    }

    /* ä¸ºæ‰€æœ‰æœ‰å­é¡¹çš„äºŒçº§é¡¹ç›®æ·»åŠ ç»Ÿä¸€çš„ç®­å¤´ */
    .sidebar-nav > ul > li:has(ul) > a,
    .sidebar-nav > ul > li:has(ul):not(:has(a)) {
      position: relative !important;
      padding-left: 18px !important;
    }

    .sidebar-nav > ul > li:has(ul) > a::before,
    .sidebar-nav > ul > li:has(ul):not(:has(a))::before {
      content: "â–¶" !important;
      position: absolute !important;
      left: 0 !important;
      top: 50% !important;
      transform: translateY(-50%) !important;
      font-size: 10px !important;
      color: #666 !important;
      width: 12px !important;
      text-align: center !important;
    }

    /* ---------------- ä»£ç å—ï¼šç»Ÿä¸€é¡¶æ  + è¡Œçº§æŠ˜å ï¼ˆç›´æ¥åœ¨ä»£ç å—å†…ï¼‰ ---------------- */
    pre[data-lang] {
      position: relative !important;
      margin: 1.5em 0 !important;
      padding: 3.1em 0 0 !important; /* é¡¶éƒ¨ç•™å·¥å…·æ  */
      border-radius: 12px !important;
      border: 1px solid rgba(0, 0, 0, 0.08) !important;
      background: #ffffff !important;
      overflow: hidden;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.02),
        0 12px 28px rgba(0, 0, 0, 0.06);
      transition: box-shadow 0.2s ease, transform 0.2s ease;
    }

    pre[data-lang]:hover {
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.02),
        0 16px 34px rgba(0, 0, 0, 0.08);
    }

    pre[data-lang].is-collapsed {
      max-height: 44px !important;
      padding-bottom: 0 !important;
      cursor: pointer;
    }

    .code-tools {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 34px;
      padding: 0 12px;
      background: linear-gradient(180deg, rgba(246, 248, 250, 0.98), rgba(246, 248, 250, 0.92));
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
      user-select: none;
      backdrop-filter: saturate(180%) blur(10px);
      -webkit-backdrop-filter: saturate(180%) blur(10px);
    }

    .code-tools-left {
      font-size: 11px;
      color: var(--code-muted);
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.7px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .code-tools-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .tool-btn {
      font-size: 11px;
      color: var(--theme-color);
      cursor: pointer;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(66, 185, 131, 0.22);
      background: rgba(66, 185, 131, 0.08);
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.15s ease;
      line-height: 1;
    }

    .tool-btn:hover {
      background: rgba(66, 185, 131, 0.14);
      border-color: rgba(66, 185, 131, 0.30);
      transform: translateY(-1px);
    }

    .tool-btn:active {
      transform: translateY(0);
    }

    /* ç¦ç”¨ docsify-copy-code çš„æŒ‰é’®ï¼ˆæˆ‘ä»¬è‡ªå·±å®ç°å¤åˆ¶å¹¶æ”¾åˆ°é¡¶æ ï¼‰ */
    .docsify-copy-code-button {
      display: none !important;
    }

    /* è¡Œçº§æŠ˜å å¸ƒå±€ */
    .fold-wrap {
      display: flex;
      background: #fff;
    }

    .fold-gutter {
      flex: 0 0 36px;
      background: transparent;
      border-right: 1px solid rgba(0, 0, 0, 0.04);
      user-select: none;
      padding: 10px 0;
    }

    .fold-gutter-row {
      height: 1.55em;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 8px;
      gap: 8px;
    }

    .fold-toggle {
      width: 20px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.15s ease;
      flex: 0 0 20px;
    }

    .fold-toggle:hover {
      background: rgba(66, 185, 131, 0.10);
    }

    .fold-toggle svg {
      width: 14px;
      height: 14px;
      fill: #8b949e;
      transition: transform 0.15s ease, fill 0.15s ease;
    }

    .fold-toggle:hover svg {
      fill: var(--theme-color);
    }

    .fold-toggle.is-folded svg {
      transform: rotate(-90deg);
    }

    .fold-code-scroll {
      flex: 1;
      overflow-x: auto;
      padding: 10px 0;
    }

    pre[data-lang][data-inline-fold-skipped="1"] > code {
      display: block;
      padding: 10px 14px;
      overflow-x: auto;
    }

    /* ---------------- Tabs / Alerts / å›¾ç‰‡ç¼©æ”¾ï¼ˆäº§å“çº§æ–‡æ¡£ç»„ä»¶ï¼‰ ---------------- */
    /* Tabsï¼ˆdocsify-tabsï¼‰ */
    .markdown-section .docsify-tabs {
      margin: 14px 0;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      overflow: hidden;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
    }

    .markdown-section .docsify-tabs__tab {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .markdown-section .docsify-tabs__tab--active {
      color: var(--theme-color);
    }

    .markdown-section .docsify-tabs__content {
      padding: 10px 12px 2px;
    }

    /* Alertsï¼ˆdocsify-plugin-flexible-alertsï¼‰ */
    .markdown-section .alert {
      margin: 14px 0;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.10);
      background: #fff;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
      overflow: hidden;
    }

    .markdown-section .alert .title {
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      background: linear-gradient(180deg, rgba(246, 248, 250, 0.98), rgba(246, 248, 250, 0.92));
    }

    .markdown-section .alert p,
    .markdown-section .alert ul,
    .markdown-section .alert ol {
      margin: 10px 12px;
    }

    .markdown-section .alert.note,
    .markdown-section .alert.info {
      border-left: 4px solid #2f81f7;
    }

    .markdown-section .alert.tip,
    .markdown-section .alert.success {
      border-left: 4px solid var(--theme-color);
    }

    .markdown-section .alert.warning {
      border-left: 4px solid #d29922;
    }

    .markdown-section .alert.danger,
    .markdown-section .alert.error {
      border-left: 4px solid #cf222e;
    }

    /* å›¾ç‰‡ç¼©æ”¾ï¼ˆmedium-zoomï¼‰ */
    .medium-zoom-overlay {
      z-index: 1000;
    }

    .medium-zoom-image--opened {
      z-index: 1001;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }

    /* è®©æ­£æ–‡å›¾ç‰‡å¯ç‚¹å‡»ï¼ˆæœ‰äº›ä¸»é¢˜/æ ·å¼ä¼šæ„å¤–ç¦ç”¨ pointer-eventsï¼‰ */
    .markdown-section img {
      pointer-events: auto !important;
      cursor: zoom-in !important;
    }

    .markdown-section a > img {
      cursor: zoom-in !important;
    }

    /* å…³é”®ï¼šä¸è¦ç”¨ flex æ¸²æŸ“ä»£ç è¡Œï¼Œé¿å…ç©ºç™½å­—ç¬¦é»è¿å¯¼è‡´"ä»£ç å˜å½¢" */
    .fold-code-row {
      display: block;
      padding: 0 14px;
      white-space: pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      line-height: 1.55em;
      color: var(--code-text);
    }

    .fold-code-row.is-hidden {
      display: none;
    }

    .fold-ellipsis {
      display: none;
      margin-left: 10px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(66, 185, 131, 0.10);
      color: var(--theme-color);
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }

    .fold-code-row.is-fold-head .fold-ellipsis {
      display: inline-block;
    }

    /* åœ¨æŠ˜å çŠ¶æ€ï¼Œç»™èµ·å§‹è¡Œç¨å¾®é«˜äº® */
    .fold-code-row.is-fold-head {
      background: rgba(66, 185, 131, 0.04);
    }

    /* è®© Prism token æ ·å¼è¿˜èƒ½ç”Ÿæ•ˆï¼ˆæˆ‘ä»¬ä»ä½¿ç”¨ Prism.highlight è¾“å‡º token spanï¼‰ */
    .fold-code-row .token.comment,
    .fold-code-row .token.prolog,
    .fold-code-row .token.doctype,
    .fold-code-row .token.cdata {
      color: #999;
    }

    /* ---------------- è¯„è®ºåŒºï¼ˆgiscusï¼‰ ---------------- */
    .markdown-section #giscus {
      margin-top: 28px;
    }

    .markdown-section #giscus .giscus-card {
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      overflow: hidden;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.02),
        0 12px 28px rgba(0, 0, 0, 0.06);
    }

    .markdown-section #giscus .giscus-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(246, 248, 250, 0.98), rgba(246, 248, 250, 0.92));
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      backdrop-filter: saturate(180%) blur(10px);
      -webkit-backdrop-filter: saturate(180%) blur(10px);
    }

    .markdown-section #giscus .giscus-head-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .markdown-section #giscus .giscus-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #1f2328;
    }

    .markdown-section #giscus .giscus-meta {
      font-size: 12px;
      color: var(--code-muted);
    }

    .markdown-section #giscus .giscus-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(66, 185, 131, 0.22);
      background: rgba(66, 185, 131, 0.08);
      color: var(--theme-color);
      font-size: 11px;
      font-weight: 700;
      line-height: 1;
      text-decoration: none;
    }

    .markdown-section #giscus .giscus-badge:hover {
      background: rgba(66, 185, 131, 0.14);
      border-color: rgba(66, 185, 131, 0.30);
    }

    .markdown-section #giscus .giscus-body {
      padding: 12px 14px 16px;
    }

    .markdown-section #giscus .giscus-body:empty {
      display: none;
    }

    .markdown-section .giscus-frame {
      width: 100%;
    }

    /* ---------------- æ–‡ç« å…ƒä¿¡æ¯ï¼ˆæ›´æ–°æ—¶é—´ / é˜…è¯»æ—¶é•¿ / å­—æ•°ï¼‰ ---------------- */
    .page-meta-card {
      margin: 18px 0 18px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      overflow: hidden;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.02),
        0 12px 28px rgba(0, 0, 0, 0.06);
    }

    .page-meta-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(246, 248, 250, 0.98), rgba(246, 248, 250, 0.92));
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      backdrop-filter: saturate(180%) blur(10px);
      -webkit-backdrop-filter: saturate(180%) blur(10px);
    }

    .page-meta-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #1f2328;
    }

    .page-meta-body {
      padding: 10px 14px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      color: #57606a;
      font-size: 13px;
      line-height: 1.6;
    }

    .page-meta-body b {
      color: #1f2328;
      font-weight: 800;
    }

    .page-meta-sep {
      opacity: 0.5;
      padding: 0 2px;
    }

    .page-tip {
      padding: 10px 14px;
      border-top: 1px dashed rgba(0, 0, 0, 0.10);
      background: rgba(66, 185, 131, 0.06);
      color: #1f2328;
      font-size: 13px;
    }

    .page-tip b {
      color: var(--theme-color);
    }

    /* ---------------- å³ä¾§ TOCï¼ˆç›®å½•å¢å¼ºï¼‰ ---------------- */
    .toc-aside {
      position: fixed;
      top: 86px;
      right: 18px;
      width: 260px;
      max-height: calc(100vh - 110px);
      overflow: auto;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.02),
        0 12px 28px rgba(0, 0, 0, 0.06);
      z-index: 20;
      display: none;
    }

    /* é˜²æ­¢æŸæ¬¡è¯¯åˆ¤å¯¼è‡´è¡Œå†… display å¡æ­»ï¼šç”¨ data å±æ€§æ§åˆ¶æ˜¯å¦çœŸæ­£æ˜¾ç¤º */
    .toc-aside[data-has-items="0"] {
      display: none !important;
    }

    .toc-head {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(180deg, rgba(246, 248, 250, 0.98), rgba(246, 248, 250, 0.92));
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      backdrop-filter: saturate(180%) blur(10px);
      -webkit-backdrop-filter: saturate(180%) blur(10px);
    }

    .toc-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #1f2328;
    }

    .toc-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .toc-action {
      width: 30px;
      height: 30px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.75);
      color: #57606a;
      cursor: pointer;
      line-height: 1;
      user-select: none;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, color 120ms ease, box-shadow 120ms ease;
    }

    .toc-icon {
      width: 16px;
      height: 16px;
      display: block;
    }

    .toc-action:hover {
      transform: translateY(-1px);
      background: rgba(66, 185, 131, 0.10);
      border-color: rgba(66, 185, 131, 0.26);
      color: #1f2328;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.10);
    }

    .toc-action:active {
      transform: translateY(0);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.08);
    }

    .toc-action.is-disabled {
      opacity: 0.42;
      filter: saturate(0.8);
      pointer-events: none;
      box-shadow: none;
    }

    .toc-action.is-hidden {
      display: none;
    }

    html[data-theme="dark"] .toc-action,
    html[data-theme="dark"] .toc-close {
      background: rgba(22, 27, 34, 0.72);
      border-color: rgba(255, 255, 255, 0.08);
      color: rgba(230, 237, 243, 0.78);
    }

    html[data-theme="dark"] .toc-action:hover,
    html[data-theme="dark"] .toc-close:hover {
      background: rgba(66, 185, 131, 0.10);
      border-color: rgba(66, 185, 131, 0.28);
      color: rgba(230, 237, 243, 0.92);
    }

    .toc-close {
      width: 28px;
      height: 28px;
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.7);
      color: #57606a;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      user-select: none;
    }

    .toc-close:hover {
      background: rgba(66, 185, 131, 0.10);
      border-color: rgba(66, 185, 131, 0.22);
      color: #1f2328;
    }

    .toc-fab {
      position: fixed;
      right: 14px;
      bottom: 16px;
      z-index: 9998;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(66, 185, 131, 0.22);
      background: rgba(255, 255, 255, 0.92);
      color: #1f2328;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.10);
      backdrop-filter: saturate(180%) blur(10px);
      -webkit-backdrop-filter: saturate(180%) blur(10px);
    }

    .toc-body {
      padding: 10px 10px 12px;
      font-size: 12px;
      line-height: 1.55;
      color: #57606a;
    }

    .toc-body a {
      display: block;
      padding: 6px 8px;
      border-radius: 8px;
      color: inherit;
      text-decoration: none;
      border: 1px solid transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .toc-body a:hover {
      background: rgba(66, 185, 131, 0.08);
      border-color: rgba(66, 185, 131, 0.18);
      color: #1f2328;
    }

    .toc-body a.is-active {
      background: rgba(66, 185, 131, 0.12);
      border-color: rgba(66, 185, 131, 0.26);
      color: #1f2328;
      font-weight: 800;
    }

    /* TOC ç›®å½•æ ‘ï¼šh2 åˆ†ç»„ + å­é¡¹æŠ˜å  */
    .toc-group {
      margin: 2px 0 6px;
    }

    .toc-group-head {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .toc-group-toggle {
      width: 22px;
      height: 22px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.6);
      color: inherit;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
    }

    .toc-group-toggle.is-hidden {
      visibility: hidden;
      pointer-events: none;
    }

    .toc-caret {
      width: 14px;
      height: 14px;
      display: block;
      opacity: 0.8;
      transition: transform 120ms ease;
    }

    .toc-group.is-collapsed .toc-caret {
      transform: rotate(-90deg);
    }

    .toc-group-link {
      flex: 1;
      min-width: 0;
    }

    .toc-children {
      margin: 4px 0 0 11px;
      padding-left: 8px;
      border-left: 1px dashed rgba(0, 0, 0, 0.10);
    }

    .toc-group.is-collapsed .toc-children {
      display: none;
    }

    html[data-theme="dark"] .toc-group-toggle {
      background: rgba(22, 27, 34, 0.60);
      border-color: rgba(255, 255, 255, 0.10);
    }

    html[data-theme="dark"] .toc-children {
      border-left-color: rgba(255, 255, 255, 0.14);
    }

    .toc-l1 { padding-left: 0; font-weight: 900; }
    .toc-l2 { padding-left: 0; }
    .toc-l3 { padding-left: 12px; }
    .toc-l4 { padding-left: 22px; opacity: 0.95; }

    /* åªåœ¨å¤§å±æ˜¾ç¤ºå³ä¾§ TOCï¼šæ˜¯å¦ç»™æ­£æ–‡é¢„ç•™ç©ºé—´ç”± body class æ§åˆ¶ */
    @media (min-width: 1024px) {
      .toc-aside { display: block; }
      body.has-toc-aside .content { padding-right: 300px; }
    }

    @media (max-width: 1023px) {
      .content { padding-right: 0; }

      /* å°å±ï¼šç›®å½•ä»¥æµ®å±‚å½¢å¼æ‰“å¼€ï¼Œé»˜è®¤éšè—ï¼Œé€šè¿‡æŒ‰é’®å”¤èµ· */
      .toc-aside {
        display: none;
        left: 12px;
        right: 12px;
        top: 74px;
        width: auto;
        max-height: calc(100vh - 96px);
        z-index: 9999;
      }

      .toc-aside.is-open {
        display: block;
      }

      .toc-close {
        display: inline-flex;
      }

      .toc-fab {
        display: inline-flex;
      }

      body:not(.has-toc-aside) .toc-fab {
        opacity: 0.55;
        border-color: rgba(0, 0, 0, 0.10);
        color: #57606a;
      }

      body.has-toc-aside .toc-fab {
        opacity: 1;
      }
    }

    /* ---------------- æ ‡é¢˜ï¼šå¤åˆ¶é“¾æ¥ï¼ˆä¸æ±¡æŸ“ TOC æ–‡æœ¬ï¼‰ ---------------- */
    .markdown-section h1,
    .markdown-section h2,
    .markdown-section h3,
    .markdown-section h4 {
      scroll-margin-top: 90px;
    }

    .heading-link-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 8px;
      width: 24px;
      height: 24px;
      border-radius: 8px;
      border: 1px solid rgba(66, 185, 131, 0.18);
      background: rgba(66, 185, 131, 0.08);
      color: var(--theme-color);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      vertical-align: middle;
      opacity: 0;
      transform: translateY(-1px);
      transition: opacity 0.15s ease, transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
    }

    .heading-link-btn:hover {
      background: rgba(66, 185, 131, 0.14);
      border-color: rgba(66, 185, 131, 0.30);
      transform: translateY(-1px);
    }

    .heading-link-btn.is-copied {
      background: rgba(66, 185, 131, 0.18);
      border-color: rgba(66, 185, 131, 0.38);
    }

    .markdown-section h1:hover .heading-link-btn,
    .markdown-section h2:hover .heading-link-btn,
    .markdown-section h3:hover .heading-link-btn,
    .markdown-section h4:hover .heading-link-btn {
      opacity: 1;
    }

    @media (hover: none) {
      .heading-link-btn {
        opacity: 0.85;
      }
    }

    html[data-theme="dark"] .heading-link-btn {
      border-color: rgba(102, 219, 162, 0.20);
      background: rgba(102, 219, 162, 0.10);
      color: rgba(102, 219, 162, 0.95);
    }

    html[data-theme="dark"] .heading-link-btn.is-copied {
      background: rgba(102, 219, 162, 0.18);
      border-color: rgba(102, 219, 162, 0.38);
    }

    /* ---------------- é˜…è¯»ä½“éªŒå¢å¼ºï¼šè¿›åº¦æ¡ / é¢åŒ…å±‘ / ä¸Šä¸€ç¯‡ä¸‹ä¸€ç¯‡ ---------------- */
    #read-progress {
      position: fixed;
      top: 0;
      left: 0;
      height: 3px;
      width: 0;
      background: var(--theme-color);
      z-index: 999;
      transition: width 0.08s linear;
    }

    .page-breadcrumb {
      margin: 10px 0 12px;
      font-size: 12px;
      line-height: 1.5;
      color: var(--code-muted);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .page-breadcrumb a {
      color: inherit;
      text-decoration: none;
      border-bottom: 1px dashed rgba(66, 185, 131, 0.25);
    }

    .page-breadcrumb a:hover {
      color: #1f2328;
      border-bottom-color: rgba(66, 185, 131, 0.55);
    }

    .page-breadcrumb .crumb-sep {
      opacity: 0.5;
    }

    .page-nav {
      margin: 18px 0 26px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .page-nav a {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
      text-decoration: none;
      color: #1f2328;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    .page-nav a:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.06);
      border-color: rgba(66, 185, 131, 0.25);
    }

    .page-nav .nav-kicker {
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: var(--code-muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .page-nav .nav-title {
      font-size: 13px;
      font-weight: 800;
      color: #1f2328;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .page-nav .is-disabled {
      opacity: 0.45;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .page-nav {
        grid-template-columns: 1fr;
      }
    }

    /* ä¾§è¾¹æ æ ·å¼ */
    .sidebar-nav > ul > li {
      margin: 10px 0;
      font-weight: bold;
      font-size: 14px;
    }

    /* ---------------- ä¸»é¢˜åˆ‡æ¢æŒ‰é’®ï¼ˆæš—è‰²/äº®è‰²/è·Ÿéšç³»ç»Ÿï¼‰ ---------------- */
    .theme-toggle {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 1002;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.10);
      background: rgba(255, 255, 255, 0.86);
      color: #111827;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.10);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: saturate(180%) blur(12px);
      -webkit-backdrop-filter: saturate(180%) blur(12px);
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
    }

    .theme-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 38px rgba(0, 0, 0, 0.14);
      border-color: rgba(66, 185, 131, 0.28);
    }

    .theme-toggle:active {
      transform: translateY(0);
    }

    .theme-toggle .theme-icon {
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: rgba(66, 185, 131, 0.10);
      color: var(--theme-color);
      font-size: 14px;
      line-height: 1;
    }

    .theme-toggle .theme-text {
      opacity: 0.9;
    }

    @media (max-width: 900px) {
      .theme-toggle {
        right: 12px;
        bottom: 12px;
      }
    }

    /* ---------------- å…¨æ–‡æœç´¢ï¼ˆCtrl/âŒ˜+Kï¼‰ ---------------- */
    .search-toggle {
      position: fixed;
      right: 18px;
      bottom: 78px;
      z-index: 1002;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.10);
      background: rgba(255, 255, 255, 0.86);
      color: #111827;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.10);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: saturate(180%) blur(12px);
      -webkit-backdrop-filter: saturate(180%) blur(12px);
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.6px;
    }

    .search-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 38px rgba(0, 0, 0, 0.14);
      border-color: rgba(66, 185, 131, 0.28);
    }

    .search-toggle:active {
      transform: translateY(0);
    }

    .search-toggle .search-icon {
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: rgba(66, 185, 131, 0.10);
      color: var(--theme-color);
    }

    .search-toggle .search-icon svg {
      width: 16px;
      height: 16px;
      display: block;
    }

    .search-toggle .search-hint {
      opacity: 0.7;
      font-weight: 800;
      font-size: 11px;
      letter-spacing: 0.3px;
    }

    @media (max-width: 900px) {
      .search-toggle {
        right: 12px;
        bottom: 72px;
      }
      .search-toggle .search-hint {
        display: none;
      }
    }

    #fts-modal {
      position: fixed;
      inset: 0;
      z-index: 2000;
      display: none;
    }

    #fts-modal.is-open {
      display: block;
    }

    #fts-modal .fts-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #fts-modal .fts-panel {
      position: relative;
      width: min(760px, calc(100vw - 24px));
      margin: 92px auto 0;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(0, 0, 0, 0.10);
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.30);
      overflow: hidden;
    }

    #fts-modal .fts-head {
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #fts-modal .fts-input {
      flex: 1;
      height: 40px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.12);
      padding: 0 12px;
      outline: none;
      font-size: 14px;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.9);
    }

    #fts-modal .fts-input:focus {
      border-color: rgba(66, 185, 131, 0.55);
      box-shadow: 0 0 0 3px rgba(66, 185, 131, 0.18);
    }

    #fts-modal .fts-close {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 1px solid rgba(0, 0, 0, 0.10);
      background: rgba(66, 185, 131, 0.08);
      color: var(--theme-color);
      cursor: pointer;
      font-weight: 900;
      font-size: 16px;
    }

    #fts-modal .fts-close:hover {
      background: rgba(66, 185, 131, 0.14);
      border-color: rgba(66, 185, 131, 0.28);
    }

    #fts-modal .fts-meta {
      padding: 8px 12px;
      font-size: 12px;
      color: rgba(17, 24, 39, 0.72);
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #fts-modal .fts-meta .fts-meta-right {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #fts-modal .fts-link {
      color: rgba(66, 185, 131, 0.95);
      font-weight: 800;
      cursor: pointer;
      text-decoration: none;
    }

    #fts-modal .fts-link:hover {
      text-decoration: underline;
    }

    #fts-modal .fts-results {
      max-height: min(62vh, 520px);
      overflow: auto;
      padding: 6px;
    }

    #fts-modal .fts-item {
      display: block;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid transparent;
      text-decoration: none;
      color: inherit;
    }

    #fts-modal .fts-item:hover {
      background: rgba(66, 185, 131, 0.08);
      border-color: rgba(66, 185, 131, 0.22);
    }

    #fts-modal .fts-title {
      font-weight: 900;
      font-size: 13px;
      line-height: 1.35;
      color: #0f172a;
    }

    #fts-modal .fts-snippet {
      margin-top: 4px;
      font-size: 12px;
      line-height: 1.6;
      color: rgba(15, 23, 42, 0.78);
    }

    #fts-modal mark {
      background: rgba(250, 204, 21, 0.45);
      color: inherit;
      padding: 0 2px;
      border-radius: 4px;
    }

    /* é¡µé¢å†…é«˜äº® */
    .fts-mark {
      background: rgba(250, 204, 21, 0.45);
      border-radius: 4px;
      padding: 0 2px;
    }

    html[data-theme="dark"] .search-toggle {
      border-color: rgba(255, 255, 255, 0.10);
      background: rgba(15, 23, 42, 0.72);
      color: rgba(226, 232, 240, 0.92);
    }

    html[data-theme="dark"] #fts-modal .fts-panel {
      background: rgba(15, 23, 42, 0.92);
      border-color: rgba(255, 255, 255, 0.10);
    }

    html[data-theme="dark"] #fts-modal .fts-input {
      background: rgba(2, 6, 23, 0.66);
      border-color: rgba(255, 255, 255, 0.12);
      color: rgba(226, 232, 240, 0.92);
    }

    html[data-theme="dark"] #fts-modal .fts-meta {
      color: rgba(226, 232, 240, 0.70);
      border-bottom-color: rgba(255, 255, 255, 0.10);
    }

    html[data-theme="dark"] #fts-modal .fts-title {
      color: rgba(226, 232, 240, 0.96);
    }

    html[data-theme="dark"] #fts-modal .fts-snippet {
      color: rgba(226, 232, 240, 0.72);
    }

    html[data-theme="dark"] #fts-modal .fts-close {
      border-color: rgba(255, 255, 255, 0.10);
      background: rgba(66, 185, 131, 0.12);
      color: rgba(102, 219, 162, 0.95);
    }

    /* ---------------- æš—è‰²æ¨¡å¼ï¼šä»…è¦†ç›–å¿…è¦åŒºåŸŸï¼Œé¿å…ç ´åç°æœ‰ä»£ç å—/å·¥å…·æ  ---------------- */
    html[data-theme="dark"] {
      color-scheme: dark;

      --code-border: rgba(255, 255, 255, 0.10);
      --code-toolbar-bg: rgba(17, 24, 39, 0.92);
      --code-gutter-bg: rgba(17, 24, 39, 0.92);
      --code-text: rgba(226, 232, 240, 0.96);
      --code-muted: rgba(226, 232, 240, 0.62);
    }

    html[data-theme="dark"] body {
      background: #0b1220;
      color: rgba(226, 232, 240, 0.92);
    }

    html[data-theme="dark"] .sidebar {
      background: #0f172a;
      border-right: 1px solid rgba(255, 255, 255, 0.08);
    }

    html[data-theme="dark"] .sidebar-nav a {
      color: rgba(226, 232, 240, 0.78);
    }

    html[data-theme="dark"] .sidebar-nav a:hover,
    html[data-theme="dark"] .sidebar-nav li.active > a {
      color: rgba(226, 232, 240, 0.96);
    }

    html[data-theme="dark"] .markdown-section {
      color: rgba(226, 232, 240, 0.92);
    }

    html[data-theme="dark"] .markdown-section a {
      color: rgba(102, 219, 162, 0.95);
    }

    html[data-theme="dark"] .markdown-section h1,
    html[data-theme="dark"] .markdown-section h2,
    html[data-theme="dark"] .markdown-section h3,
    html[data-theme="dark"] .markdown-section h4 {
      color: rgba(226, 232, 240, 0.98);
    }

    /* å¡ç‰‡ç±»å®¹å™¨ï¼šTabs / Alerts / TOC / å¯¼èˆªå¡ç‰‡ / è¯„è®ºå¡ç‰‡ */
    html[data-theme="dark"] .markdown-section .docsify-tabs,
    html[data-theme="dark"] .markdown-section .alert,
    html[data-theme="dark"] .markdown-section #giscus .giscus-card,
    html[data-theme="dark"] .toc-aside,
    html[data-theme="dark"] .page-nav a {
      background: rgba(15, 23, 42, 0.92) !important;
      border-color: rgba(255, 255, 255, 0.10) !important;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.16) !important;
    }

    html[data-theme="dark"] .markdown-section .alert .title,
    html[data-theme="dark"] .markdown-section #giscus .giscus-head,
    html[data-theme="dark"] .code-tools {
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.92)) !important;
      border-bottom-color: rgba(255, 255, 255, 0.08) !important;
    }

    html[data-theme="dark"] .markdown-section #giscus .giscus-title,
    html[data-theme="dark"] .page-nav .nav-title {
      color: rgba(226, 232, 240, 0.96) !important;
    }

    html[data-theme="dark"] .page-nav a:hover {
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35) !important;
    }

    /* ä»£ç å—ï¼ˆä½ è¿™é‡Œæœ‰å¤§é‡ !importantï¼Œæ‰€ä»¥æš—è‰²ä¹Ÿéœ€è¦åŒçº§åˆ«è¦†ç›–ï¼‰ */
    html[data-theme="dark"] pre[data-lang] {
      background: rgba(2, 6, 23, 0.90) !important;
      border-color: rgba(255, 255, 255, 0.10) !important;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.20),
        0 18px 40px rgba(0, 0, 0, 0.40) !important;
    }

    html[data-theme="dark"] .fold-wrap {
      background: transparent !important;
    }

    html[data-theme="dark"] .fold-gutter {
      border-right-color: rgba(255, 255, 255, 0.06) !important;
    }

    html[data-theme="dark"] .fold-code-row.is-fold-head {
      background: rgba(66, 185, 131, 0.08) !important;
    }

    html[data-theme="dark"] .theme-toggle {
      border-color: rgba(255, 255, 255, 0.10);
      background: rgba(15, 23, 42, 0.72);
      color: rgba(226, 232, 240, 0.92);
      box-shadow: 0 16px 45px rgba(0, 0, 0, 0.40);
    }

    html[data-theme="dark"] .theme-toggle .theme-icon {
      background: rgba(66, 185, 131, 0.16);
      color: rgba(102, 219, 162, 0.95);
    }

    /* ---------------- æç®€é£æ ¼ï¼ˆå…¨ç«™ï¼Œå¯åˆ‡æ¢ï¼‰ ---------------- */
    :root {
      --min-font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Noto Sans CJK SC", "Noto Sans", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --min-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --min-radius: 10px;

      /* é»˜è®¤ï¼šMonoï¼ˆé»‘ç™½ï¼‰â€”â€”æ›´ç®€å•ã€æ›´"å¹²å‡€" */
      --min-accent: #2563eb;
      --min-text: rgba(17, 24, 39, 0.92);
      --min-subtext: rgba(17, 24, 39, 0.62);
      --min-border: rgba(17, 24, 39, 0.14);
      --min-bg: #ffffff;
      --min-surface: #ffffff;
      --min-code-bg: rgba(17, 24, 39, 0.045);

      /* æç®€ï¼šä¸ä½¿ç”¨é˜´å½±ï¼ˆå‡å°‘é‡ç»˜/åˆæˆå¼€é”€ï¼‰ */
      --min-shadow: none;
      --min-shadow-hover: none;
      --min-float-shadow: none;
      --min-float-shadow-hover: none;
    }

    html[data-min-style="paper"] {
      --min-accent: #b45309;
      --min-bg: #fbfbf7;
      --min-surface: #ffffff;
      --min-border: rgba(120, 53, 15, 0.18);
      --min-code-bg: rgba(120, 53, 15, 0.06);
    }

    html[data-min-style="mono"] {
      --min-accent: #2563eb;
      --min-bg: #ffffff;
      --min-surface: #ffffff;
      --min-border: rgba(17, 24, 39, 0.14);
      --min-code-bg: rgba(17, 24, 39, 0.045);
    }

    html[data-min-style="soft"] {
      --min-accent: #7c3aed;
      --min-bg: #f8f7ff;
      --min-surface: #ffffff;
      --min-border: rgba(30, 27, 75, 0.14);
      --min-code-bg: rgba(30, 27, 75, 0.05);
    }

    html[data-theme="dark"] {
      /* é»˜è®¤æš—è‰²ï¼ˆéš style è¿›ä¸€æ­¥è¦†ç›–ï¼‰ */
      --min-text: rgba(226, 232, 240, 0.92);
      --min-subtext: rgba(226, 232, 240, 0.66);
      --min-border: rgba(226, 232, 240, 0.14);
      --min-bg: #0a0c10;
      --min-surface: #0a0c10;
      --min-code-bg: rgba(226, 232, 240, 0.07);

      /* æš—è‰²ä¹Ÿä¿æŒ"æ— é˜´å½±" */
      --min-shadow: none;
      --min-shadow-hover: none;
      --min-float-shadow: none;
      --min-float-shadow-hover: none;
    }

    html[data-theme="dark"][data-min-style="paper"] {
      --min-accent: #f59e0b;
      --min-bg: #0b0f16;
      --min-surface: #0b0f16;
      --min-border: rgba(251, 191, 36, 0.18);
      --min-code-bg: rgba(251, 191, 36, 0.08);
    }

    html[data-theme="dark"][data-min-style="mono"] {
      --min-accent: #60a5fa;
      --min-bg: #0a0c10;
      --min-surface: #0a0c10;
      --min-border: rgba(226, 232, 240, 0.14);
      --min-code-bg: rgba(226, 232, 240, 0.07);
    }

    html[data-theme="dark"][data-min-style="soft"] {
      --min-accent: #c4b5fd;
      --min-bg: #0b0a16;
      --min-surface: #0b0a16;
      --min-border: rgba(196, 181, 253, 0.18);
      --min-code-bg: rgba(196, 181, 253, 0.09);
    }

    body {
      background: var(--min-bg) !important;
    }

    .markdown-section {
      color: var(--min-text) !important;
      font-family: var(--min-font);
      line-height: 1.72;
      font-size: 14px;
      letter-spacing: 0.008em;
    }

    .markdown-section h1,
    .markdown-section h2,
    .markdown-section h3 {
      letter-spacing: -0.02em;
    }

    .markdown-section blockquote {
      background: transparent !important;
      border-left-color: var(--min-border) !important;
      color: var(--min-subtext) !important;
    }

    .markdown-section a {
      color: var(--min-accent) !important;
      text-decoration-thickness: 1px;
      text-underline-offset: 3px;
    }

    .markdown-section a:hover {
      text-decoration: underline;
    }

    .markdown-section code {
      font-family: var(--min-mono);
      font-size: 0.92em;
      background: var(--min-code-bg);
      border: 1px solid var(--min-border);
      border-radius: 7px;
      padding: 0.12em 0.35em;
    }

    /* Draw.io å›¾è¡¨å®¹å™¨æ ·å¼ */
    .drawio-container {
      position: relative;
      margin: 1.5em 0;
      border: 1px solid var(--min-border);
      border-radius: 12px;
      background: var(--min-surface);
      overflow: hidden;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.03),
        0 14px 32px rgba(0, 0, 0, 0.10);
    }

    html[data-theme="dark"] .drawio-container {
      background: rgba(15, 23, 42, 0.88);
      border-color: rgba(255, 255, 255, 0.10);
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.22),
        0 20px 48px rgba(0, 0, 0, 0.45);
    }

    .drawio-diagram {
      padding: 20px;
      text-align: center;
    }

    .drawio-diagram svg {
      max-width: 100%;
      height: auto;
    }

    .drawio-edit-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 700;
      color: var(--min-text);
      background: rgba(255, 255, 255, 0.65);
      border: 1px solid var(--min-border);
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10;
    }

    html[data-theme="dark"] .drawio-edit-btn {
      color: rgba(226, 232, 240, 0.92);
      background: rgba(15, 23, 42, 0.35);
      border-color: rgba(255, 255, 255, 0.12);
    }

    .drawio-edit-btn:hover {
      background: rgba(255, 255, 255, 0.92);
      transform: translateY(-1px);
    }

    html[data-theme="dark"] .drawio-edit-btn:hover {
      background: rgba(15, 23, 42, 0.55);
    }

    .drawio-edit-btn::before {
      content: "ğŸ“ ";
      margin-right: 4px;
    }

    /* ä»£ç å—ï¼šmac çª—å£é£ï¼ˆé¡¶æ  + ä¸‰è‰²ç‚¹ + ä»£ç åŒºï¼‰ */
    pre[data-lang] {
      background: var(--min-surface) !important;
      border: 1px solid var(--min-border) !important;
      border-radius: 12px !important;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.03),
        0 14px 32px rgba(0, 0, 0, 0.10) !important;
      padding: 3.0em 0 0 !important; /* é¡¶éƒ¨ç•™å·¥å…·æ ï¼ˆä¸ç°æœ‰ JS å·¥å…·æ é«˜åº¦åŒ¹é…ï¼‰ */
      overflow: hidden;
    }

    html[data-theme="dark"] pre[data-lang] {
      background: rgba(15, 23, 42, 0.88) !important;
      border-color: rgba(255, 255, 255, 0.10) !important;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, 0.22),
        0 20px 48px rgba(0, 0, 0, 0.45) !important;
    }

    pre[data-lang] code {
      background: transparent;
      border: 0;
      padding: 0;
    }

    /* ä»£ç åŒºåŸŸæœ¬ä½“ï¼ˆå«è¡Œå· gutterï¼‰ */
    .fold-wrap {
      background: var(--min-code-bg) !important;
    }

    .fold-gutter {
      border-right-color: var(--min-border) !important;
    }

    /* æç®€ï¼šå»æ‰é˜´å½±/ä½ç§»/æ¨¡ç³Šï¼Œé™ä½é‡ç»˜ä¸åˆæˆå¼€é”€ */
    .markdown-section .docsify-tabs,
    .markdown-section .alert,
    .markdown-section #giscus .giscus-card,
    .toc-aside,
    .page-nav a {
      box-shadow: none !important;
      border-color: var(--min-border) !important;
      border-radius: var(--min-radius) !important;
    }

    .page-nav a:hover,
    html[data-theme="dark"] .page-nav a:hover {
      box-shadow: none !important;
      transform: none !important;
    }

    .code-tools {
      background: linear-gradient(180deg, rgba(250, 250, 250, 0.98), rgba(245, 245, 245, 0.92)) !important;
      border-bottom: 1px solid var(--min-border) !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }

    html[data-theme="dark"] .code-tools {
      background: linear-gradient(180deg, rgba(30, 41, 59, 0.96), rgba(30, 41, 59, 0.86)) !important;
      border-bottom-color: rgba(255, 255, 255, 0.08) !important;
    }

    .code-tools-left {
      color: var(--min-subtext) !important;
      font-weight: 800;
      letter-spacing: 0.7px;
      text-transform: uppercase;
    }

    /* macOS é£æ ¼ä¸‰è‰²ç‚¹ */
    .code-tools-left .dot {
      display: inline-block !important;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.10);
    }

    html[data-theme="dark"] .code-tools-left .dot {
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.35);
    }

    .code-tools-left .dot:nth-of-type(1) { background: #ff5f57 !important; }
    .code-tools-left .dot:nth-of-type(2) { background: #febc2e !important; }
    .code-tools-left .dot:nth-of-type(3) { background: #28c840 !important; }

    .tool-btn {
      color: var(--min-text);
      border: 1px solid var(--min-border);
      background: rgba(255, 255, 255, 0.65);
      border-radius: 999px;
      padding: 4px 10px;
      font-weight: 700;
      transition: none !important;
      transform: none !important;
    }

    html[data-theme="dark"] .tool-btn {
      color: rgba(226, 232, 240, 0.92);
      border-color: rgba(255, 255, 255, 0.12);
      background: rgba(15, 23, 42, 0.35);
    }

    .tool-btn:hover,
    .tool-btn:active {
      background: rgba(255, 255, 255, 0.92);
      transform: none !important;
    }

    html[data-theme="dark"] .tool-btn:hover,
    html[data-theme="dark"] .tool-btn:active {
      background: rgba(15, 23, 42, 0.55);
    }

    /* æ‚¬æµ®æŒ‰é’®ï¼šçº¯è‰²ã€æ— æ¨¡ç³Šã€æ— ä½ç§» */
    .style-toggle {
      position: fixed;
      right: 18px;
      bottom: 138px;
      z-index: 1002;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--min-border);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.4px;
    }

    @media (max-width: 900px) {
      .style-toggle {
        right: 12px;
        bottom: 124px;
      }
    }

    .style-toggle .style-icon {
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1;
    }

    .style-toggle .style-text {
      opacity: 0.9;
    }

    .theme-toggle,
    .search-toggle,
    .style-toggle {
      background: var(--min-surface) !important;
      border-color: var(--min-border) !important;
      color: var(--min-text) !important;
      box-shadow: none !important;
      transform: none !important;
      transition: none !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }

    .theme-toggle:hover,
    .search-toggle:hover,
    .style-toggle:hover,
    .theme-toggle:active,
    .search-toggle:active,
    .style-toggle:active {
      box-shadow: none !important;
      transform: none !important;
    }

    .theme-toggle .theme-icon,
    .style-toggle .style-icon {
      background: transparent !important;
    }
  </style>
</head>
<body>
  <div id="app">æ­£åœ¨åŠ è½½...</div>
  <button id="theme-toggle" class="theme-toggle" type="button" aria-label="åˆ‡æ¢ä¸»é¢˜" title="åˆ‡æ¢ä¸»é¢˜">
    <span class="theme-icon" aria-hidden="true">â­®</span>
    <span class="theme-text">è·Ÿéš</span>
  </button>

  <button id="style-toggle" class="style-toggle" type="button" aria-label="åˆ‡æ¢é£æ ¼" title="é£æ ¼ï¼šé»‘ç™½ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰">
    <span class="style-icon" aria-hidden="true">Aa</span>
    <span class="style-text">é»‘ç™½</span>
  </button>

  <button id="search-toggle" class="search-toggle" type="button" aria-label="å…¨æ–‡æœç´¢" title="å…¨æ–‡æœç´¢ï¼ˆCtrl/âŒ˜+Kï¼‰">
    <span class="search-icon" aria-hidden="true">
      <svg viewBox="0 0 24 24" focusable="false" aria-hidden="true">
        <path d="M10 18a8 8 0 1 1 5.3-14.1A8 8 0 0 1 10 18Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
        <path d="M21 21l-4.35-4.35" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
      </svg>
    </span>
    <span class="search-text">æœç´¢</span>
    <span class="search-hint">Ctrl/âŒ˜+K</span>
  </button>

  <script>
    /* ---------------- æç®€é£æ ¼ï¼šPaper / Mono / Softï¼ˆæŒä¹…åŒ–ï¼‰ ---------------- */
    (function () {
      const KEY = 'docsify:min-style';
      const STYLES = ['mono', 'paper', 'soft'];
      const LABELS = { soft: 'æŸ”å’Œ', mono: 'é»‘ç™½', paper: 'çº¸æ„Ÿ' };

      function getStyle() {
        try {
          return localStorage.getItem(KEY) || 'mono';
        } catch (e) {
          return 'mono';
        }
      }

      function normalize(style) {
        return STYLES.indexOf(style) >= 0 ? style : 'mono';
      }

      function render(style) {
        const btn = document.getElementById('style-toggle');
        if (!btn) return;
        const text = btn.querySelector('.style-text');
        btn.setAttribute('data-style', style);
        if (text) text.textContent = LABELS[style] || style;
        btn.title = 'é£æ ¼ï¼š' + (LABELS[style] || style) + 'ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰';
      }

      function apply(style, persist) {
        const s = normalize(style);
        document.documentElement.setAttribute('data-min-style', s);
        if (persist) {
          try {
            localStorage.setItem(KEY, s);
          } catch (e) {
            // ignore
          }
        }
        render(s);
      }

      function nextStyle(cur) {
        const idx = STYLES.indexOf(cur);
        return STYLES[(idx + 1 + STYLES.length) % STYLES.length] || 'mono';
      }

      // é¦–æ¬¡ï¼šå°½é‡æ—©ç‚¹åº”ç”¨ï¼Œå‡å°‘é—ªçƒ
      apply(getStyle(), false);

      document.addEventListener('click', function (e) {
        const btn = e && e.target && e.target.closest ? e.target.closest('#style-toggle') : null;
        if (!btn) return;
        e.preventDefault();
        const cur = btn.getAttribute('data-style') || getStyle();
        const next = nextStyle(cur);
        apply(next, true);
      }, true);

      window.__docsifyStyle = {
        get: getStyle,
        apply: function (style) { apply(style, true); },
        list: function () { return STYLES.slice(); }
      };
    })();

    /* ---------------- ä¸»é¢˜åˆ‡æ¢ï¼šè·Ÿéšç³»ç»Ÿ / æš—è‰² / äº®è‰²ï¼ˆæŒä¹…åŒ–ï¼‰ ---------------- */
    (function () {
      const KEY = 'docsify:theme-mode';
      const MODES = ['auto', 'dark', 'light'];
      const media = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)')) ? window.matchMedia('(prefers-color-scheme: dark)') : null;

      function getMode() {
        try {
          return localStorage.getItem(KEY) || 'auto';
        } catch (e) {
          return 'auto';
        }
      }

      function resolve(mode) {
        if (mode === 'dark' || mode === 'light') return mode;
        const isDark = media ? !!media.matches : false;
        return isDark ? 'dark' : 'light';
      }

      function renderButton(mode, resolved) {
        const btn = document.getElementById('theme-toggle');
        if (!btn) return;

        const icon = btn.querySelector('.theme-icon');
        const text = btn.querySelector('.theme-text');

        btn.setAttribute('data-mode', mode);

        if (mode === 'auto') {
          if (icon) icon.textContent = 'â­®';
          if (text) text.textContent = 'è·Ÿéš';
          btn.title = 'ä¸»é¢˜ï¼šè·Ÿéšç³»ç»Ÿï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰';
          return;
        }

        if (resolved === 'dark') {
          if (icon) icon.textContent = 'â˜¾';
          if (text) text.textContent = 'æš—è‰²';
          btn.title = 'ä¸»é¢˜ï¼šæš—è‰²ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰';
          return;
        }

        if (icon) icon.textContent = 'â˜€';
        if (text) text.textContent = 'äº®è‰²';
        btn.title = 'ä¸»é¢˜ï¼šäº®è‰²ï¼ˆç‚¹å‡»åˆ‡æ¢ï¼‰';
      }

      function dispatchChange(mode, resolved) {
        try {
          window.dispatchEvent(new CustomEvent('docsify-theme-change', {
            detail: { mode: mode, resolved: resolved }
          }));
        } catch (e) {
          // ignore
        }
      }

      function apply(mode, persist) {
        const resolved = resolve(mode);
        document.documentElement.setAttribute('data-theme', resolved);
        document.documentElement.setAttribute('data-theme-mode', mode);

        if (persist) {
          try {
            localStorage.setItem(KEY, mode);
          } catch (e) {
            // ignore
          }
        }

        renderButton(mode, resolved);
        dispatchChange(mode, resolved);
      }

      function nextMode(cur) {
        const idx = MODES.indexOf(cur);
        return MODES[(idx + 1 + MODES.length) % MODES.length] || 'auto';
      }

      // é¦–æ¬¡ï¼šå°½é‡æ—©ç‚¹åº”ç”¨ï¼Œå‡å°‘é—ªçƒ
      apply(getMode(), false);

      // è·Ÿéšç³»ç»Ÿï¼šç³»ç»Ÿä¸»é¢˜å˜åŒ–æ—¶è‡ªåŠ¨åˆ·æ–°
      if (media) {
        const handler = function () {
          if (getMode() === 'auto') apply('auto', false);
        };
        try {
          media.addEventListener('change', handler);
        } catch (e) {
          try { media.addListener(handler); } catch (err) { /* ignore */ }
        }
      }

      // ç‚¹å‡»æŒ‰é’®ï¼šä¸‰æ€å¾ªç¯
      document.addEventListener('click', function (e) {
        const btn = e && e.target && e.target.closest ? e.target.closest('#theme-toggle') : null;
        if (!btn) return;
        e.preventDefault();
        const cur = btn.getAttribute('data-mode') || getMode();
        const next = nextMode(cur);
        apply(next, true);
      }, true);

      // å¯¹å¤–æš´éœ²ï¼ˆå¿…è¦æ—¶å¯åœ¨æ§åˆ¶å°æ‰‹åŠ¨åˆ‡æ¢ï¼‰
      window.__docsifyTheme = {
        getMode: getMode,
        apply: function (mode) { apply(mode || 'auto', true); },
        resolve: resolve
      };
    })();

    window.$docsify = {
      name: 'LoveEleve',
      repo: 'https://github.com/LoveEleve/LoveEleve.github.io',
      loadSidebar: true,
      subMaxLevel: 3,
      sidebarDisplayLevel: 0,
      executeScript: true,
      requestHeaders: { 'cache-control': 'max-age=0' },
      auto2top: true,

      // ä»£ç å—é»˜è®¤è¯­è¨€ï¼šæ— æ ‡è®°/çº¯æ–‡æœ¬ â†’ Javaï¼ˆä¾¿äºé˜…è¯»ä¸é«˜äº®ï¼‰
      markdown: {
        renderer: {
          code: function (code, lang) {
            const raw = (lang == null ? '' : String(lang)).trim();
            const first = raw ? raw.split(/\s+/)[0] : '';
            const normalized = (first || '').toLowerCase();

            // Draw.io å›¾è¡¨æ”¯æŒ
            if (normalized === 'drawio') {
              if (window.drawioConverter) {
                console.log('drawio è½¬åŒ–ä¸­');
                return window.drawioConverter(code);
              } else {
                return `<div class='drawio-code'>${code}</div>`;
              }
            }

            // å¸¸è§"çº¯æ–‡æœ¬"æ ‡è®°ï¼šplain / text / plaintext / plain-text / plain&#x20;text
            const fallback = (!normalized || normalized === 'text' || normalized === 'plaintext' || normalized === 'plain-text' || normalized.indexOf('plain') === 0);
            const finalLang = fallback ? 'java' : normalized;

            return this.origin.code(code, finalLang);
          }
        }
      },

      tabs: {
        persist: true,
        sync: true,
        theme: 'material'
      },

      'flexible-alerts': {
        style: 'callout',
        note: { label: 'NOTE' },
        tip: { label: 'TIP' },
        warning: { label: 'WARNING' },
        danger: { label: 'DANGER' }
      },

      plugins: [
        function (hook, vm) {
          function escapeHtml(str) {
            return str
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
          }

          function safeHighlight(line, lang) {
            try {
              if (window.Prism && Prism.languages && Prism.languages[lang]) {
                return Prism.highlight(line, Prism.languages[lang], lang);
              }
            } catch (e) {
              // ignore
            }
            return escapeHtml(line);
          }

          function buildFoldBlocks(lines) {
            // è½»é‡æ‹¬å·åŒ¹é…ï¼šå°½é‡å¿½ç•¥å­—ç¬¦ä¸²/æ³¨é‡Šé‡Œçš„ { }
            const blocks = [];
            const stack = [];
            let inBlockComment = false;
            let inString = null; // ' or "
            let escape = false;

            function scanLine(line) {
              let openCount = 0;
              let closeCount = 0;
              for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                const next = i + 1 < line.length ? line[i + 1] : '';

                if (escape) {
                  escape = false;
                  continue;
                }

                if (inString) {
                  if (ch === '\\') {
                    escape = true;
                    continue;
                  }
                  if (ch === inString) {
                    inString = null;
                  }
                  continue;
                }

                if (inBlockComment) {
                  if (ch === '*' && next === '/') {
                    inBlockComment = false;
                    i++;
                  }
                  continue;
                }

                // è¡Œæ³¨é‡Š
                if (ch === '/' && next === '/') break;

                // å—æ³¨é‡Š
                if (ch === '/' && next === '*') {
                  inBlockComment = true;
                  i++;
                  continue;
                }

                // å­—ç¬¦ä¸²å¼€å§‹
                if (ch === '"' || ch === "'") {
                  inString = ch;
                  continue;
                }

                if (ch === '{') openCount++;
                if (ch === '}') closeCount++;
              }
              return { openCount, closeCount };
            }

            lines.forEach((line, idx) => {
              const { openCount, closeCount } = scanLine(line);

              for (let i = 0; i < openCount; i++) stack.push(idx);
              for (let i = 0; i < closeCount; i++) {
                if (stack.length === 0) continue;
                const start = stack.pop();
                const end = idx;
                // è‡³å°‘æŠ˜å  2 è¡Œä»¥ä¸Šæ‰æœ‰æ„ä¹‰
                if (end >= start + 2) blocks.push({ start, end, folded: false });
              }
            });

            blocks.sort((a, b) => (a.start - b.start) || (b.end - a.end));
            return blocks;
          }

          // æ€§èƒ½å…œåº•ï¼šè¶…é•¿ä»£ç å—ä¸è¦åš"é€è¡Œ DOM æŠ˜å "ï¼Œé¿å…é¡µé¢å¡é¡¿
          const INLINE_FOLD_MAX_LINES = 360;

          function initInlineFolding(pre) {
            const langRaw = (pre.getAttribute('data-lang') || '').toLowerCase();
            const lang = langRaw === 'plain' ? 'markup' : langRaw;

            const codeEl = pre.querySelector('code');
            if (!codeEl) return;

            // å–"çº¯æ–‡æœ¬ä»£ç "ï¼Œé¿å…æŠŠ token span å†æ¬¡è§£æ
            const raw = (codeEl.textContent || '').replace(/\n$/, '');
            const lines = raw.split('\n');

            // è¶…é•¿ä»£ç å—ï¼šä¿ç•™åŸç”Ÿ Prism æ¸²æŸ“ï¼ˆæ›´çœ DOMï¼‰ï¼Œåªä¿ç•™å¤åˆ¶/æ•´å—æ”¶èµ·
            if (lines.length > INLINE_FOLD_MAX_LINES) {
              pre.dataset.rawCode = raw;
              pre.dataset.inlineFoldSkipped = '1';
              return;
            }

            // ç”ŸæˆæŠ˜å ç»“æ„
            const blocks = buildFoldBlocks(lines);
            const blocksByStart = new Map();
            blocks.forEach((b) => {
              if (!blocksByStart.has(b.start)) blocksByStart.set(b.start, []);
              blocksByStart.get(b.start).push(b);
            });

            // æ¸…ç©ºåŸ code å†…å®¹ï¼Œæ”¹ä¸º"åŒä¸€ä¸ªä»£ç å—å†…"çš„è¡Œçº§ç»“æ„
            codeEl.innerHTML = '';

            const wrap = document.createElement('div');
            wrap.className = 'fold-wrap';

            const gutter = document.createElement('div');
            gutter.className = 'fold-gutter';

            const codeScroll = document.createElement('div');
            codeScroll.className = 'fold-code-scroll';

            wrap.appendChild(gutter);
            wrap.appendChild(codeScroll);
            codeEl.appendChild(wrap);

            const gutterRows = new Array(lines.length);
            const codeRows = new Array(lines.length);
            const ellipsisByStart = new Map();
            const toggleByStart = new Map();

            function makeChevron() {
              const span = document.createElement('span');
              span.className = 'fold-toggle';
              span.innerHTML = '<svg viewBox="0 0 16 16" aria-hidden="true"><path d="M4.5 6.5L8 10l3.5-3.5"/></svg>';
              return span;
            }

            for (let i = 0; i < lines.length; i++) {
              const gr = document.createElement('div');
              gr.className = 'fold-gutter-row';

              const startBlocks = blocksByStart.get(i);
              if (startBlocks && startBlocks.length) {
                const toggle = makeChevron();
                gr.appendChild(toggle);
                toggleByStart.set(i, toggle);
              } else {
                const spacer = document.createElement('span');
                spacer.style.width = '20px';
                spacer.style.display = 'inline-block';
                gr.appendChild(spacer);
              }

              gutter.appendChild(gr);
              gutterRows[i] = gr;

              const cr = document.createElement('div');
              cr.className = 'fold-code-row';

              const html = safeHighlight(lines[i], lang);
              cr.innerHTML = html || '&nbsp;';

              const ell = document.createElement('span');
              ell.className = 'fold-ellipsis';
              ell.textContent = 'â€¦';
              cr.appendChild(ell);
              ellipsisByStart.set(i, ell);

              codeScroll.appendChild(cr);
              codeRows[i] = cr;
            }

            function recompute() {
              const hidden = new Array(lines.length).fill(false);

              // reset
              for (let i = 0; i < lines.length; i++) {
                codeRows[i].classList.remove('is-fold-head');
                const ell = ellipsisByStart.get(i);
                if (ell) {
                  ell.style.display = 'none';
                  ell.textContent = 'â€¦';
                }
              }

              blocks.forEach((b) => {
                if (!b.folded) return;
                for (let i = b.start + 1; i <= b.end; i++) hidden[i] = true;

                // start è¡Œå±•ç¤º ellipsis
                codeRows[b.start].classList.add('is-fold-head');
                const ell = ellipsisByStart.get(b.start);
                if (ell) {
                  const count = b.end - b.start;
                  ell.style.display = 'inline-block';
                  ell.textContent = `â€¦ ${count} è¡Œ`;
                }
              });

              for (let i = 0; i < lines.length; i++) {
                const isHidden = hidden[i];
                gutterRows[i].style.display = isHidden ? 'none' : 'flex';
                codeRows[i].classList.toggle('is-hidden', isHidden);
              }

              // update toggle states
              toggleByStart.forEach((toggle, start) => {
                const startBlocks = blocksByStart.get(start) || [];
                const anyFolded = startBlocks.some((b) => b.folded);
                toggle.classList.toggle('is-folded', anyFolded);
              });
            }

            // bind toggle events
            toggleByStart.forEach((toggle, start) => {
              const startBlocks = blocksByStart.get(start) || [];

              // åŒä¸€è¡Œè‹¥æœ‰å¤šä¸ª blockï¼ˆæå°‘è§ï¼‰ï¼Œä¼˜å…ˆæŠ˜å "æœ€é•¿çš„"æ›´ç¬¦åˆç›´è§‰
              const pick = startBlocks.reduce((acc, cur) => {
                const accLen = acc.end - acc.start;
                const curLen = cur.end - cur.start;
                return curLen > accLen ? cur : acc;
              }, startBlocks[0]);

              toggle.onclick = (e) => {
                e.stopPropagation();
                pick.folded = !pick.folded;
                recompute();
              };

              const ell = ellipsisByStart.get(start);
              if (ell) {
                ell.onclick = (e) => {
                  e.stopPropagation();
                  pick.folded = false;
                  recompute();
                };
              }
            });

            // åˆå§‹å…¨å±•å¼€
            recompute();

            // ä¿ç•™åŸå§‹æ–‡æœ¬ç”¨äºå¤åˆ¶
            pre.dataset.rawCode = raw;
          }

          function initToolbar(pre) {
            if (pre.querySelector('.code-tools')) return;

            const lang = (pre.getAttribute('data-lang') || '').toUpperCase();

            const tools = document.createElement('div');
            tools.className = 'code-tools';
            tools.innerHTML = `
              <div class="code-tools-left">
                <span class="dot"></span>
                <span class="dot"></span>
                <span class="dot"></span>
                <span>${lang}</span>
              </div>
              <div class="code-tools-right">
                <span class="tool-btn btn-copy">å¤åˆ¶</span>
                <span class="tool-btn btn-toggle">æ”¶èµ·ä»£ç </span>
              </div>
            `;

            pre.insertBefore(tools, pre.firstChild);

            const copyBtn = tools.querySelector('.btn-copy');
            const toggleBtn = tools.querySelector('.btn-toggle');

            copyBtn.onclick = function (e) {
              e.stopPropagation();
              const text = pre.dataset.rawCode || '';
              navigator.clipboard.writeText(text).then(() => {
                copyBtn.textContent = 'å·²å¤åˆ¶';
                setTimeout(() => {
                  copyBtn.textContent = 'å¤åˆ¶';
                }, 1200);
              });
            };

            const handleToggle = function (e) {
              if (e) e.stopPropagation();
              const isCollapsed = pre.classList.toggle('is-collapsed');
              toggleBtn.textContent = isCollapsed ? 'å±•å¼€ä»£ç ' : 'æ”¶èµ·ä»£ç ';
            };

            toggleBtn.onclick = handleToggle;
            pre.onclick = function () {
              if (pre.classList.contains('is-collapsed')) handleToggle();
            };
          }

          /* ---------------- å›¾ç‰‡ç¼©æ”¾ï¼šmedium-zoomï¼ˆä»…ä½œç”¨äºæ­£æ–‡å›¾ç‰‡ï¼‰ ---------------- */
          let zoomInstance = null;
          let zoomBindTimer = null;
          let zoomBindTimer2 = null;
          let zoomDelegationInited = false;

          // äº‹ä»¶å§”æ‰˜ï¼šå“ªæ€•å›¾ç‰‡è¢«é“¾æ¥åŒ…ä½/DOM äºŒæ¬¡å˜æ›´ï¼Œä¹Ÿèƒ½ç‚¹å¼€
          function ensureImageZoomDelegation() {
            if (zoomDelegationInited) return;
            zoomDelegationInited = true;

            document.addEventListener('click', function (e) {
              if (!e || e.defaultPrevented) return;
              if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;

              // æœ‰äº›åœºæ™¯ click çš„ target ä¸æ˜¯ imgï¼ˆæ¯”å¦‚å¤–å±‚åŒ…äº†é“¾æ¥/æ’ä»¶æ’å…¥äº†åŒ…è£¹å±‚ï¼‰ï¼Œ
              // ç”¨ composedPath() æ›´ç¨³åœ°æ‰¾å‡ºçœŸæ­£çš„ IMG èŠ‚ç‚¹ã€‚
              const path = (typeof e.composedPath === 'function') ? e.composedPath() : null;
              let img = null;

              if (path && path.length) {
                for (let i = 0; i < path.length; i++) {
                  const el = path[i];
                  if (el && el.tagName === 'IMG') {
                    img = el;
                    break;
                  }
                }
              }

              if (!img) {
                const t = e.target;
                if (t && t.tagName === 'IMG') img = t;
              }

              if (!img) return;

              const section = img.closest('.markdown-section');
              if (!section) return;
              if (img.closest('#giscus') || img.closest('#page-meta')) return;
              if (img.hasAttribute('data-no-zoom')) return;

              if (!window.mediumZoom) return;

              // é˜»æ­¢å›¾ç‰‡å¤–å±‚é“¾æ¥çš„é»˜è®¤è·³è½¬
              e.preventDefault();
              e.stopPropagation();

              if (!zoomInstance) {
                zoomInstance = window.mediumZoom({
                  background: 'rgba(15, 23, 42, 0.72)',
                  margin: 24,
                  scrollOffset: 60
                });
              }

              try { zoomInstance.attach(img); } catch (err) { /* ignore */ }
              try { zoomInstance.open({ target: img }); } catch (err) { /* ignore */ }
            }, true);
          }

          function ensureImageZoom() {
            ensureImageZoomDelegation();

            const section = document.querySelector('.markdown-section');
            if (!section) return;
            if (!window.mediumZoom) return;

            if (!zoomInstance) {
              zoomInstance = window.mediumZoom({
                background: 'rgba(15, 23, 42, 0.72)',
                margin: 24,
                scrollOffset: 60
              });
            }

            const imgs = Array.from(section.querySelectorAll('img'))
              .filter((img) => !img.closest('#giscus') && !img.closest('#page-meta') && !img.hasAttribute('data-no-zoom'));

            // å…ˆå…¨éƒ¨è§£ç»‘ï¼Œå†ç»‘å®šå½“å‰é¡µå›¾ç‰‡ï¼ˆé¿å…è·¯ç”±åˆ‡æ¢åç»‘å®šæ³„æ¼ï¼‰
            try { zoomInstance.detach(); } catch (e) { /* ignore */ }
            try { zoomInstance.attach(imgs); } catch (e) { /* ignore */ }
          }

          // é‡è¦ï¼šéƒ¨åˆ†æ’ä»¶ï¼ˆå¦‚ tabs/alertsï¼‰å¯èƒ½åœ¨ doneEach åç»§ç»­æ”¹ DOMï¼Œ
          // æ‰€ä»¥è¿™é‡Œåš"å¤šæ¬¡å»¶è¿Ÿé‡ç»‘"ï¼Œæé«˜ç¨³å®šæ€§ã€‚
          function scheduleImageZoom() {
            if (zoomBindTimer) clearTimeout(zoomBindTimer);
            if (zoomBindTimer2) clearTimeout(zoomBindTimer2);

            // ç¬¬ä¸€è½®ï¼šç«‹å³ï¼ˆä¸‹ä¸€è½®äº‹ä»¶å¾ªç¯ï¼‰
            zoomBindTimer = setTimeout(() => {
              zoomBindTimer = null;
              ensureImageZoom();
            }, 0);

            // ç¬¬äºŒè½®ï¼šç¨åå†æ¥ä¸€æ¬¡ï¼ˆè¦†ç›–æ’ä»¶çš„å¼‚æ­¥ DOM å˜æ›´ï¼‰
            zoomBindTimer2 = setTimeout(() => {
              zoomBindTimer2 = null;
              ensureImageZoom();
            }, 180);
          }

          const GISCUS_CFG = {
            src: 'https://giscus.app/client.js',
            repo: 'LoveEleve/LoveEleve.github.io',
            repoId: 'R_kgDOQ7i-XQ',
            category: 'Announcements',
            categoryId: 'DIC_kwDOQ7i-Xc4C1Edj',
            mapping: 'specific',
            strict: '0',
            reactionsEnabled: '1',
            emitMetadata: '0',
            inputPosition: 'bottom',
            // è·Ÿéšå½“å‰ç«™ç‚¹ä¸»é¢˜ï¼ˆæš—è‰²/äº®è‰²ï¼‰
            theme: (document.documentElement.getAttribute('data-theme') === 'dark') ? 'dark' : 'light',
            lang: 'zh-CN'
          };

          function getGiscusTerm(vm) {
            // è®©æ¯ä¸ª Docsify è·¯ç”±å¯¹åº”ä¸€ä¸ª discussionï¼ˆé¿å…å…¨ç«™ä¸²æ¥¼ï¼‰
            let path = (vm && vm.route && vm.route.path) ? vm.route.path : '';
            if (!path) {
              path = (location.hash || '#/').replace(/^#/, '').split('?')[0];
            }
            if (!path || path === '/') path = '/README';
            try {
              path = decodeURIComponent(path);
            } catch (e) {
              // ignore
            }
            return 'docsify:' + path;
          }

          /* ---------------- æ–‡ç« å…ƒä¿¡æ¯ï¼šæ›´æ–°æ—¶é—´ / é˜…è¯»æ—¶é•¿ / å­—æ•° ---------------- */
          const META_CFG = {
            githubOwner: 'LoveEleve',
            githubRepo: 'LoveEleve.github.io',
            // GitHub API æœªç™»å½•é™æµè¾ƒç´§ï¼šåšæœ¬åœ°ç¼“å­˜é™ä½è¯·æ±‚é¢‘ç‡
            cacheTTLms: 6 * 60 * 60 * 1000,
            // é¡¶éƒ¨æç¤ºæ–‡æ¡ˆ
            tipHtml: 'æç¤ºï¼šå‘ç°é”™è¯¯æ¬¢è¿åœ¨è¯„è®ºåŒº <b>å‹˜è¯¯</b> / äº¤æµï½'
          };

          function getRouteFile(vm) {
            let file = (vm && vm.route && vm.route.file) ? vm.route.file : '';
            if (!file) {
              let p = (vm && vm.route && vm.route.path) ? vm.route.path : '';
              p = (p || '').split('?')[0];
              if (!p || p === '/') return 'README.md';
              if (p.endsWith('/')) p += 'README';
              if (!p.endsWith('.md')) p += '.md';
              file = p;
            }
            file = (file || '').replace(/^\//, '');
            return file || 'README.md';
          }

          function ensurePageMeta(section) {
            if (!section) return null;

            let meta = section.querySelector('#page-meta');
            if (!meta) {
              meta = document.createElement('div');
              meta.id = 'page-meta';
              meta.className = 'page-meta-card';
              meta.innerHTML = `
                <div class="page-meta-head">
                  <div class="page-meta-title">æœ¬æ–‡ä¿¡æ¯</div>
                </div>
                <div class="page-meta-body">
                  <span>æœ€åæ›´æ–°ï¼š<b id="meta-updated">åŠ è½½ä¸­â€¦</b></span>
                  <span class="page-meta-sep">Â·</span>
                  <span>é¢„è®¡é˜…è¯»ï¼š<b id="meta-read">-</b></span>
                  <span class="page-meta-sep">Â·</span>
                  <span>å­—æ•°ï¼š<b id="meta-words">-</b></span>
                </div>
                <div id="page-tip" class="page-tip"></div>
              `;
              section.insertBefore(meta, section.firstChild);
            }

            const tip = meta.querySelector('#page-tip');
            if (tip) tip.innerHTML = META_CFG.tipHtml;

            return meta;
          }

          function formatCount(n) {
            if (!Number.isFinite(n)) return '-';
            if (n >= 10000) return (n / 10000).toFixed(1).replace(/\.0$/, '') + 'w';
            if (n >= 1000) return (n / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
            return String(n);
          }

          function computeReadingStats(section) {
            try {
              const clone = section.cloneNode(true);
              clone.querySelectorAll('#page-meta, #giscus, pre, code, .code-tools').forEach((el) => el.remove());
              const text = (clone.textContent || '').replace(/\s+/g, ' ').trim();

              const cn = (text.match(/[\u4e00-\u9fff]/g) || []).length;
              const enWords = (text.replace(/[\u4e00-\u9fff]/g, ' ').match(/\b[\w'-]+\b/g) || []).length;

              const minutes = Math.max(1, Math.ceil(cn / 350 + enWords / 220));
              const total = cn + enWords;
              return { minutes, total };
            } catch (e) {
              return { minutes: 1, total: 0 };
            }
          }

          function formatUpdated(iso) {
            try {
              const d = new Date(iso);
              if (Number.isNaN(d.getTime())) return 'æœªçŸ¥';
              return new Intl.DateTimeFormat('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              }).format(d);
            } catch (e) {
              return 'æœªçŸ¥';
            }
          }

          async function fetchLastUpdatedISO(file) {
            const candidates = [
              `docs/${file}`,
              file
            ];

            for (const p of candidates) {
              const cacheKey = `pageLastUpdated:${p}`;
              try {
                const cached = JSON.parse(localStorage.getItem(cacheKey) || 'null');
                if (cached && cached.iso && cached.ts && (Date.now() - cached.ts < META_CFG.cacheTTLms)) {
                  return cached.iso;
                }
              } catch (e) {
                // ignore cache parse
              }

              const url = `https://api.github.com/repos/${META_CFG.githubOwner}/${META_CFG.githubRepo}/commits?path=${encodeURIComponent(p)}&page=1&per_page=1`;

              try {
                const controller = new AbortController();
                const t = setTimeout(() => controller.abort(), 5000);

                const resp = await fetch(url, {
                  headers: { 'Accept': 'application/vnd.github+json' },
                  signal: controller.signal
                });

                clearTimeout(t);

                if (!resp.ok) continue;
                const data = await resp.json();
                const iso = data && data[0] && data[0].commit && data[0].commit.committer && data[0].commit.committer.date;
                if (iso) {
                  try {
                    localStorage.setItem(cacheKey, JSON.stringify({ iso, ts: Date.now() }));
                  } catch (e) {
                    // ignore
                  }
                  return iso;
                }
              } catch (e) {
                // ignore
              }
            }

            return '';
          }

          async function renderPageMeta(vm) {
            const section = document.querySelector('.markdown-section');
            if (!section) return;

            const meta = ensurePageMeta(section);
            if (!meta) return;

            const { minutes, total } = computeReadingStats(section);
            const readEl = meta.querySelector('#meta-read');
            const wordsEl = meta.querySelector('#meta-words');
            if (readEl) readEl.textContent = `${minutes} åˆ†é’Ÿ`;
            if (wordsEl) wordsEl.textContent = `${formatCount(total)}`;

            const file = getRouteFile(vm);
            const updatedEl = meta.querySelector('#meta-updated');
            if (updatedEl) updatedEl.textContent = 'åŠ è½½ä¸­â€¦';

            const iso = await fetchLastUpdatedISO(file);
            if (updatedEl) updatedEl.textContent = iso ? formatUpdated(iso) : 'æœªçŸ¥';
          }

          /* ---------------- æ ‡é¢˜ï¼šå¤åˆ¶é“¾æ¥ï¼ˆä¸æ±¡æŸ“ TOC æ–‡æœ¬ï¼‰ ---------------- */
          let headingLinkDelegationInited = false;

          function buildHeadingUrlById(id) {
            const base = location.href.split('#')[0];
            const hashBase = (location.hash || '#/').split('?')[0] || '#/';
            return `${base}${hashBase}?id=${encodeURIComponent(id)}`;
          }

          function copyTextToClipboard(text) {
            if (!text) return Promise.resolve(false);

            if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
              return navigator.clipboard.writeText(text).then(() => true).catch(() => false);
            }

            // fallback
            try {
              const ta = document.createElement('textarea');
              ta.value = text;
              ta.setAttribute('readonly', 'readonly');
              ta.style.position = 'fixed';
              ta.style.left = '-9999px';
              ta.style.top = '-9999px';
              document.body.appendChild(ta);
              ta.select();
              const ok = document.execCommand('copy');
              document.body.removeChild(ta);
              return Promise.resolve(!!ok);
            } catch (e) {
              return Promise.resolve(false);
            }
          }

          function ensureHeadingLinkDelegation() {
            if (headingLinkDelegationInited) return;
            headingLinkDelegationInited = true;

            document.addEventListener('click', function (e) {
              const btn = e && e.target && e.target.closest ? e.target.closest('.heading-link-btn') : null;
              if (!btn) return;

              e.preventDefault();
              e.stopPropagation();

              const id = btn.getAttribute('data-heading-id') || '';
              if (!id) return;

              const url = buildHeadingUrlById(id);
              copyTextToClipboard(url).then((ok) => {
                btn.classList.toggle('is-copied', !!ok);
                const old = btn.textContent || '#';
                btn.textContent = ok ? 'âœ“' : '!';
                setTimeout(() => {
                  btn.classList.remove('is-copied');
                  btn.textContent = old;
                }, 900);
              });
            }, true);
          }

          // æŸäº›æƒ…å†µä¸‹ï¼ˆæ’ä»¶/ä¸»é¢˜/Markdown å†™æ³•ï¼‰æ ‡é¢˜å¯èƒ½æ²¡æœ‰ idï¼šè¿™é‡Œå…œåº•ç”Ÿæˆä¸€ä¸ªç¨³å®š idï¼Œä¿è¯ TOC/å¤åˆ¶é“¾æ¥å¯ç”¨
          function hashString(str) {
            let h = 5381;
            for (let i = 0; i < str.length; i++) {
              h = ((h << 5) + h) ^ str.charCodeAt(i);
            }
            return (h >>> 0).toString(16);
          }

          function ensureHeadingId(h) {
            if (!h || !h.getAttribute) return '';
            let id = h.getAttribute('id') || '';
            if (id) return id;

            // å°è¯•ä» docsify æ³¨å…¥çš„ anchor ä¸Šæå– id
            try {
              const a = h.querySelector ? (h.querySelector('a.anchor[data-id], a.anchor[href]') || null) : null;
              if (a) {
                const dataId = a.getAttribute('data-id') || '';
                if (dataId) id = dataId;
                if (!id) {
                  const href = a.getAttribute('href') || '';
                  const q = href.split('?')[1] || '';
                  const m = q.match(/(?:^|&)id=([^&]+)/);
                  if (m && m[1]) {
                    try { id = decodeURIComponent(m[1]); } catch (e) { id = m[1]; }
                  }
                }
              }
            } catch (e) {
              // ignore
            }

            if (!id) {
              const raw = (h.textContent || '').replace(/\s+/g, ' ').trim();
              id = raw ? ('h-' + hashString(raw).slice(0, 8)) : ('h-' + Math.random().toString(16).slice(2, 10));
            }

            // ä¿è¯å”¯ä¸€
            try {
              let cand = id;
              let i = 2;
              while (document.getElementById(cand)) {
                cand = `${id}-${i++}`;
              }
              id = cand;
              h.setAttribute('id', id);
            } catch (e) {
              // ignore
            }

            return id;
          }

          function renderHeadingLinks(vm) {
            ensureHeadingLinkDelegation();

            const section = document.querySelector('.markdown-section');
            if (!section) return;

            const headings = Array.from(section.querySelectorAll('h1, h2, h3, h4'));
            headings.forEach((h) => {
              if (!h || h.querySelector('.heading-link-btn')) return;

              const id = ensureHeadingId(h);
              if (!id) return;

              // ä¸ç»™ Meta/TOC è¿™ç±»éæ­£æ–‡åŒºåŸŸåŠ æŒ‰é’®
              if (h.closest('#page-meta') || h.closest('#toc-aside') || h.closest('#giscus')) return;

              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'heading-link-btn';
              btn.setAttribute('data-heading-id', id);
              btn.setAttribute('aria-label', 'å¤åˆ¶æ ‡é¢˜é“¾æ¥');
              btn.title = 'å¤åˆ¶æ ‡é¢˜é“¾æ¥';
              btn.textContent = '#';

              h.appendChild(btn);
            });
          }

          /* ---------------- å³ä¾§ TOCï¼šè‡ªåŠ¨ç”Ÿæˆ + å½“å‰å°èŠ‚é«˜äº® ---------------- */
          let tocObserver = null;
          let tocScrollBound = false;
          let tocScrollUpdate = null;

          // TOC æœ‰æ—¶ä¼šå› ä¸ºæ¸²æŸ“æ—¶æœºï¼ˆå›¾ç‰‡/æ’ä»¶äºŒæ¬¡æ¸²æŸ“/å¼‚æ­¥ DOM å˜åŒ–ï¼‰åœ¨ doneEach æ—¶è¿˜æ‹¿ä¸åˆ° heading
          // è¿™é‡Œå¢åŠ ï¼šå»¶è¿Ÿé‡ç®— + MutationObserverï¼Œè‡ªæ„ˆ"æŸæ¬¡è¯¯åˆ¤ items=[] å¯¼è‡´ç›®å½•æ°¸è¿œä¸å‡ºæ¥"çš„é—®é¢˜
          let tocRenderObserver = null;
          let tocRenderTtlTimer = null;
          let tocLastVm = null;
          let tocResizeBound = false;

          function stopTocRenderObserver() {
            if (tocRenderTtlTimer) {
              try { clearTimeout(tocRenderTtlTimer); } catch (e) { /* ignore */ }
              tocRenderTtlTimer = null;
            }
            if (tocRenderObserver) {
              try { tocRenderObserver.disconnect(); } catch (e) { /* ignore */ }
              tocRenderObserver = null;
            }
          }

          let tocMobileDelegationInited = false;
          let tocJumpStack = [];
          let tocLastRoutePath = '';

          function getScrollTop() {
            const doc = document.documentElement;
            return (doc && typeof doc.scrollTop === 'number') ? doc.scrollTop : (document.body ? (document.body.scrollTop || 0) : 0);
          }

          function scrollToY(y) {
            const top = Math.max(0, Math.floor(Number(y) || 0));
            try {
              window.scrollTo({ top: top, behavior: 'smooth' });
            } catch (e) {
              try { window.scrollTo(0, top); } catch (err) { /* ignore */ }
            }
          }

          function setTocBackState() {
            const toc = document.querySelector('#toc-aside');
            if (!toc) return;
            const btn = toc.querySelector('.toc-back');
            if (!btn) return;

            const canBack = tocJumpStack.length > 0;

            // ä¿æŒæŒ‰é’®å¯è§ï¼šæ— è¿”å›ç‚¹æ—¶ç½®ç°ï¼ˆæ›´ç¬¦åˆç”¨æˆ·é¢„æœŸï¼Œä¹Ÿæ–¹ä¾¿å‘ç°åŠŸèƒ½ï¼‰
            try { btn.classList.remove('is-hidden'); } catch (e) { /* ignore */ }
            btn.classList.toggle('is-disabled', !canBack);
            try { btn.setAttribute('aria-disabled', canBack ? 'false' : 'true'); } catch (e) { /* ignore */ }
          }

          function pushTocJumpPoint() {
            // åªè®°å½•"ç›®å½•è·³è½¬å‰"çš„é˜…è¯»ä½ç½®ï¼ˆæ”¯æŒå¤šæ¬¡è·³è½¬æ ˆå¼è¿”å›ï¼‰
            const y = getScrollTop();
            const max = 30;
            if (tocJumpStack.length >= max) tocJumpStack = tocJumpStack.slice(-Math.floor(max / 2));
            tocJumpStack.push({ y: y, ts: Date.now() });
            setTocBackState();
          }

          function ensureTocFab() {
            let btn = document.querySelector('#toc-fab');
            if (!btn) {
              btn = document.createElement('button');
              btn.id = 'toc-fab';
              btn.type = 'button';
              btn.className = 'toc-fab';
              btn.textContent = 'ç›®å½•';
              btn.setAttribute('aria-label', 'æ‰“å¼€ç›®å½•');
              btn.setAttribute('aria-disabled', 'true');
              document.body.appendChild(btn);
            }
            return btn;
          }

          function setTocFabState(hasItems) {
            const btn = ensureTocFab();
            try { btn.setAttribute('aria-disabled', hasItems ? 'false' : 'true'); } catch (e) { /* ignore */ }
            try { btn.classList.toggle('is-disabled', !hasItems); } catch (e) { /* ignore */ }
          }

          function ensureTocMobileDelegation() {
            if (tocMobileDelegationInited) return;
            tocMobileDelegationInited = true;

            document.addEventListener('click', function (e) {
              const t = e && e.target;
              const fab = t && t.closest ? t.closest('#toc-fab') : null;
              if (fab) {
                e.preventDefault();
                e.stopPropagation();

                const toc = ensureToc();
                const has = (toc && toc.dataset && toc.dataset.hasItems) === '1';

                if (!has) {
                  // å†å°è¯•é‡ç®—ä¸€æ¬¡ï¼šæœ‰äº›é¡µé¢æ ‡é¢˜æ¸²æŸ“æ›´æ™š
                  try { if (tocLastVm) scheduleTocRender(tocLastVm); } catch (err) { /* ignore */ }

                  setTimeout(() => {
                    const toc2 = ensureToc();
                    const has2 = (toc2 && toc2.dataset && toc2.dataset.hasItems) === '1';
                    if (!has2) {
                      const body = toc2.querySelector('#toc-body');
                      if (body && !(body.innerHTML || '').trim()) {
                        body.innerHTML = '<div style="padding:6px 8px;color:#57606a;line-height:1.6">å½“å‰é¡µæœªæ£€æµ‹åˆ°å¯ç”¨æ ‡é¢˜ï¼ˆå»ºè®®è‡³å°‘åŒ…å« <b>##</b> æˆ– <b>###</b>ï¼‰ã€‚</div>';
                      }
                    }
                    try { toc2.classList.add('is-open'); } catch (err) { /* ignore */ }
                  }, 120);

                  return;
                }

                try { toc.classList.add('is-open'); } catch (err) { /* ignore */ }
                return;
              }

              const topBtn = t && t.closest ? t.closest('#toc-aside .toc-top') : null;
              if (topBtn) {
                e.preventDefault();
                e.stopPropagation();
                scrollToY(0);
                return;
              }

              const backBtn = t && t.closest ? t.closest('#toc-aside .toc-back') : null;
              if (backBtn) {
                e.preventDefault();
                e.stopPropagation();
                const last = tocJumpStack.pop();
                setTocBackState();
                if (last && typeof last.y === 'number') scrollToY(last.y);
                return;
              }

              const toggleBtn = t && t.closest ? t.closest('#toc-aside .toc-group-toggle') : null;
              if (toggleBtn) {
                e.preventDefault();
                e.stopPropagation();

                const gid = (toggleBtn.getAttribute && toggleBtn.getAttribute('data-group-id')) ? (toggleBtn.getAttribute('data-group-id') || '') : '';
                if (!gid) return;

                const toc = ensureToc();
                const body = toc ? toc.querySelector('#toc-body') : null;
                const esc = (typeof CSS !== 'undefined' && CSS.escape) ? CSS.escape : (s) => String(s).replace(/[^a-zA-Z0-9_-]/g, (c) => `\\${c}`);
                const group = body ? body.querySelector(`.toc-group[data-group-id="${esc(gid)}"]`) : null;
                const children = group ? group.querySelector('.toc-children') : null;
                if (!group || !children || !children.children || !children.children.length) return;

                const willCollapse = !group.classList.contains('is-collapsed');
                if (willCollapse) {
                  group.classList.add('is-collapsed');
                } else {
                  // å±•å¼€å½“å‰ç« èŠ‚ï¼ŒåŒæ—¶æŠ˜å å…¶ä»–ç« èŠ‚
                  try {
                    body.querySelectorAll('.toc-group').forEach((el) => {
                      if (el !== group) {
                        const ch = el.querySelector('.toc-children');
                        if (ch && ch.children && ch.children.length) el.classList.add('is-collapsed');
                      }
                    });
                  } catch (e) { /* ignore */ }
                  group.classList.remove('is-collapsed');
                }

                // æŒä¹…åŒ–æŠ˜å çŠ¶æ€ï¼ˆæŒ‰é¡µé¢ routeKey è®°ï¼‰
                try {
                  const p = ((location.hash || '#/').split('?')[0] || '#/');
                  const routeKey = String(p || '').replace(/^#/, '').split('?')[0] || '/';
                  const key = `toc-tree:${routeKey}`;
                  const raw = localStorage.getItem(key);
                  const obj = raw ? JSON.parse(raw) : {};
                  const collapsed = (obj && obj.collapsed && typeof obj.collapsed === 'object') ? obj.collapsed : {};
                  if (group.classList.contains('is-collapsed')) collapsed[gid] = 1;
                  else delete collapsed[gid];

                  // å±•å¼€æ—¶è®°ä½ lastOpenï¼ˆç”¨äºä¸‹æ¬¡è¿›å…¥è¯¥é¡µé»˜è®¤å±•å¼€ï¼‰
                  const lastOpen = (!group.classList.contains('is-collapsed')) ? gid : ((obj && typeof obj.lastOpen === 'string') ? obj.lastOpen : '');
                  localStorage.setItem(key, JSON.stringify({ v: 1, collapsed: collapsed, lastOpen: lastOpen }));
                } catch (e) { /* ignore */ }

                return;
              }

              const closeBtn = t && t.closest ? t.closest('#toc-aside .toc-close') : null;
              if (closeBtn) {
                e.preventDefault();
                e.stopPropagation();
                const toc = ensureToc();
                try { toc.classList.remove('is-open'); } catch (err) { /* ignore */ }
                return;
              }

              // å°å±ç‚¹å‡»ç©ºç™½å…³é—­æµ®å±‚
              try {
                if (window.innerWidth <= 1023) {
                  const toc = document.querySelector('#toc-aside');
                  if (!toc || !toc.classList.contains('is-open')) return;
                  const inside = t && t.closest ? (t.closest('#toc-aside') || t.closest('#toc-fab')) : null;
                  if (!inside) toc.classList.remove('is-open');
                }
              } catch (err) {
                // ignore
              }
            }, true);
          }

          function scheduleTocRender(vm) {
            tocLastVm = vm;

            const tryOnce = () => {
              const ok = renderToc(vm);
              if (ok) stopTocRenderObserver();
              return ok;
            };

            // å…ˆå°½å¿«æ¸²æŸ“ä¸€æ¬¡
            if (tryOnce()) return;

            // å…œåº•ï¼šä¸¤å¸§å + å¤šä¸ªå»¶è¿Ÿç‚¹å†ç®—ä¸€æ¬¡ï¼ˆå¤„ç†å¼‚æ­¥æ¸²æŸ“/å›æµï¼‰
            try { requestAnimationFrame(() => requestAnimationFrame(tryOnce)); } catch (e) { /* ignore */ }
            setTimeout(tryOnce, 80);
            setTimeout(tryOnce, 260);
            setTimeout(tryOnce, 900);

            // ä»ç„¶æ²¡æ‹¿åˆ° heading æ—¶ï¼Œç›‘å¬æ­£æ–‡åŒºåŸŸ DOM å˜åŒ–ï¼Œç›´åˆ°æˆåŠŸæˆ–è¶…æ—¶
            stopTocRenderObserver();
            const section = document.querySelector('.markdown-section');
            if (!section || typeof MutationObserver !== 'function') return;

            tocRenderObserver = new MutationObserver(() => {
              if (tryOnce()) stopTocRenderObserver();
            });

            try {
              tocRenderObserver.observe(section, { childList: true, subtree: true });
            } catch (e) {
              stopTocRenderObserver();
              return;
            }

            tocRenderTtlTimer = setTimeout(stopTocRenderObserver, 2500);

            // çª—å£å°ºå¯¸å˜åŒ–å¯èƒ½æ”¹å˜ TOC æ˜¯å¦å¯è§ï¼ˆæ–­ç‚¹ï¼‰ï¼Œç»‘å®šä¸€æ¬¡å…¨å±€ resize åšå…œåº•é‡ç®—
            if (!tocResizeBound) {
              tocResizeBound = true;
              let t = null;
              window.addEventListener('resize', () => {
                if (t) {
                  try { clearTimeout(t); } catch (e) { /* ignore */ }
                }
                t = setTimeout(() => {
                  if (tocLastVm) scheduleTocRender(tocLastVm);
                }, 160);
              }, { passive: true });
            }
          }

          function ensureToc() {
            let toc = document.querySelector('#toc-aside');
            if (!toc) {
              toc = document.createElement('aside');
              toc.id = 'toc-aside';
              toc.className = 'toc-aside';
              try { toc.dataset.hasItems = '0'; } catch (e) { /* ignore */ }
              toc.innerHTML = `
                <div class="toc-head">
                  <div class="toc-title">ç›®å½•</div>
                  <div class="toc-actions">
                    <button type="button" class="toc-action toc-back is-disabled" aria-label="è¿”å›ä¸Šæ¬¡é˜…è¯»ä½ç½®" title="è¿”å›ä¸Šæ¬¡é˜…è¯»ä½ç½®">
                      <svg class="toc-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                        <path d="M9 14l-4-4 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                        <path d="M20 20v-6a4 4 0 0 0-4-4H5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                      </svg>
                    </button>
                    <button type="button" class="toc-action toc-top" aria-label="å›åˆ°é¡¶éƒ¨" title="å›åˆ°é¡¶éƒ¨">
                      <svg class="toc-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                        <path d="M12 19V5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                        <path d="M5 12l7-7 7 7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                      </svg>
                    </button>
                    <button type="button" class="toc-close" aria-label="å…³é—­ç›®å½•" title="å…³é—­">Ã—</button>
                  </div>
                </div>
                <div class="toc-body" id="toc-body"></div>
              `;
              document.body.appendChild(toc);
            }
            return toc;
          }

          function getHeadingPureText(h) {
            try {
              const clone = h.cloneNode(true);

              // æˆ‘ä»¬è‡ªå·±è¿½åŠ çš„"å¤åˆ¶é“¾æ¥"æŒ‰é’®ï¼Œä¸åº”è®¡å…¥æ ‡é¢˜æ–‡æœ¬
              clone.querySelectorAll('.heading-link-btn').forEach((el) => el.remove());

              // docsify / ä¸»é¢˜å¯èƒ½ä¼šæ³¨å…¥ a.anchorï¼š
              // - æœ‰çš„åªæ¸²æŸ“ä¸€ä¸ª "#" ç¬¦å·
              // - æœ‰çš„ä¼šæŠŠ"æ ‡é¢˜æ–‡å­—æœ¬èº«"åŒ…åœ¨ a.anchor é‡Œ
              // æ‰€ä»¥è¿™é‡Œä¸èƒ½ä¸€åˆ€åˆ‡ removeï¼Œå¦åˆ™å¯èƒ½æŠŠæ ‡é¢˜æ–‡å­—ä¹Ÿåˆ æ²¡äº†ã€‚
              clone.querySelectorAll('a.anchor').forEach((a) => {
                const t = (a.textContent || '').replace(/\s+/g, ' ').trim();

                // çº¯ç¬¦å·é”šç‚¹ï¼šç›´æ¥å‰”é™¤
                if (!t || t === '#' || t === 'Â¶' || t === 'Â§') {
                  a.remove();
                  return;
                }

                // å…¶ä»–æƒ…å†µï¼šè§£åŒ…ï¼ˆä¿ç•™æ–‡å­—/å­èŠ‚ç‚¹ï¼Œå»æ‰é“¾æ¥å±æ€§ï¼‰ï¼Œé¿å…æ±¡æŸ“ TOC æ–‡æœ¬
                const frag = document.createDocumentFragment();
                while (a.firstChild) frag.appendChild(a.firstChild);
                try {
                  a.parentNode && a.parentNode.replaceChild(frag, a);
                } catch (e) {
                  // ignore
                }
              });

              return (clone.textContent || '').replace(/\s+/g, ' ').trim();
            } catch (e) {
              return ((h && h.textContent) ? h.textContent : '').replace(/\s+/g, ' ').trim();
            }
          }

          function buildTocItems(section) {
            let headings = Array.from(section.querySelectorAll('h2, h3, h4'));
            // å…œåº•ï¼šæœ‰äº›é¡µé¢å¯èƒ½åªæœ‰ h1ï¼ˆæˆ–æ²¡æœ‰äºŒçº§æ ‡é¢˜ï¼‰ï¼Œæ­¤æ—¶ä¹Ÿç”Ÿæˆä¸€ä¸ªæœ€å°å¯ç”¨ç›®å½•
            if (!headings.length) headings = Array.from(section.querySelectorAll('h1'));
            return headings
              .map((h) => {
                const level = h.tagName.toLowerCase();
                const id = ensureHeadingId(h);
                const text = getHeadingPureText(h);
                if (!id || !text) return null;
                return { el: h, id, text, level };
              })
              .filter(Boolean);
          }

          const TOC_BODY_CLASS = 'has-toc-aside';

          function renderToc(vm) {
            const section = document.querySelector('.markdown-section');
            if (!section) return false;

            const toc = ensureToc();
            const body = toc.querySelector('#toc-body');
            if (!body) return;

            const items = buildTocItems(section);

            // æ²¡æœ‰å°æ ‡é¢˜å°±ä¸å±•ç¤º TOCï¼ˆé¿å…ç©ºå¡ç‰‡ï¼‰
            if (items.length < 1) {
              try { toc.dataset.hasItems = '0'; } catch (e) { /* ignore */ }
              try { toc.classList.remove('is-open'); } catch (e) { /* ignore */ }
              try { document.body.classList.remove(TOC_BODY_CLASS); } catch (e) { /* ignore */ }
              body.innerHTML = '';
              setTocFabState(false);
              tocScrollUpdate = null;
              if (tocObserver) {
                try { tocObserver.disconnect(); } catch (e) {}
                tocObserver = null;
              }
              return false;
            }

            try { toc.dataset.hasItems = '1'; } catch (e) { /* ignore */ }
            try { document.body.classList.add(TOC_BODY_CLASS); } catch (e) { /* ignore */ }
            ensureTocMobileDelegation();
            setTocFabState(true);
            try { setTocBackState(); } catch (e) { /* ignore */ }
            const routePath = (vm && vm.route && vm.route.path ? vm.route.path : '').replace(/^\//, '');
            const routeKey = (function () {
              try {
                const p = (vm && vm.route && vm.route.path) ? vm.route.path : ((location.hash || '#/').split('?')[0] || '#/');
                return String(p || '').replace(/^#/, '').split('?')[0] || '/';
              } catch (e) {
                return '/';
              }
            })();

            const treeState = (function () {
              try {
                const key = `toc-tree:${routeKey}`;
                const raw = localStorage.getItem(key);
                const obj = raw ? JSON.parse(raw) : null;
                const collapsed = (obj && obj.collapsed && typeof obj.collapsed === 'object') ? obj.collapsed : {};
                const lastOpen = (obj && typeof obj.lastOpen === 'string') ? obj.lastOpen : '';
                return { key, collapsed, lastOpen };
              } catch (e) {
                return { key: '', collapsed: {}, lastOpen: '' };
              }
            })();

            function persistTreeState(next) {
              try {
                if (!treeState.key) return;
                const payload = {
                  v: 1,
                  collapsed: next && next.collapsed ? next.collapsed : treeState.collapsed,
                  lastOpen: (next && typeof next.lastOpen === 'string') ? next.lastOpen : treeState.lastOpen
                };
                localStorage.setItem(treeState.key, JSON.stringify(payload));
              } catch (e) { /* ignore */ }
            }

            function setCollapsed(groupId, collapsed) {
              try {
                if (!groupId) return;
                if (collapsed) treeState.collapsed[groupId] = 1;
                else delete treeState.collapsed[groupId];
                persistTreeState({ collapsed: treeState.collapsed, lastOpen: treeState.lastOpen });
              } catch (e) { /* ignore */ }
            }

            function setLastOpen(groupId) {
              try {
                if (!groupId) return;
                treeState.lastOpen = groupId;
                persistTreeState({ collapsed: treeState.collapsed, lastOpen: treeState.lastOpen });
              } catch (e) { /* ignore */ }
            }

            // --- æ„å»ºç›®å½•æ ‘ï¼šæŒ‰ h2 åˆ†ç»„ï¼Œh3/h4 ä½œä¸ºå­é¡¹ ---
            const hasH2 = items.some((it) => it.level === 'h2');
            const groupLevel = hasH2 ? 'h2' : (items.some((it) => it.level === 'h1') ? 'h1' : (items[0] ? items[0].level : 'h2'));
            const groups = [];
            let cur = null;
            for (let i = 0; i < items.length; i++) {
              const it = items[i];
              if (it.level === groupLevel) {
                cur = { id: it.id, text: it.text, level: it.level, children: [] };
                groups.push(cur);
              } else {
                if (!cur) {
                  cur = { id: it.id, text: it.text, level: groupLevel, children: [] };
                  groups.push(cur);
                }
                // ä»…æŠŠ h3/h4 å½“ä½œå­é¡¹ï¼ˆé¿å…æŠŠ h2/h1 é‡å¤å¡è¿›å»ï¼‰
                if (it.level === 'h3' || it.level === 'h4') cur.children.push(it);
              }
            }

            const idToGroup = new Map();
            const groupIds = [];

            body.innerHTML = groups
              .map((g, idx) => {
                const gid = g.id || `tocg-${idx}`;
                groupIds.push(gid);
                idToGroup.set(g.id, gid);
                const collapsed = !!treeState.collapsed[gid];
                const groupCls = collapsed ? 'toc-group is-collapsed' : 'toc-group';
                const toggleHidden = g.children && g.children.length ? '' : ' is-hidden';

                const headCls = g.level === 'h1' ? 'toc-l1' : 'toc-l2';
                const headLink = `<a class="toc-group-link ${headCls}" href="#/${routePath}?id=${encodeURIComponent(g.id)}" data-target="${g.id}" data-group="${gid}">${escapeHtml(g.text)}</a>`;

                const childrenHtml = (g.children || [])
                  .map((c) => {
                    idToGroup.set(c.id, gid);
                    const cls = c.level === 'h3' ? 'toc-l3' : 'toc-l4';
                    return `<a class="toc-child ${cls}" href="#/${routePath}?id=${encodeURIComponent(c.id)}" data-target="${c.id}" data-group="${gid}">${escapeHtml(c.text)}</a>`;
                  })
                  .join('');

                return `
                  <div class="${groupCls}" data-group-id="${escapeHtml(gid)}">
                    <div class="toc-group-head">
                      <button type="button" class="toc-group-toggle${toggleHidden}" data-group-id="${escapeHtml(gid)}" aria-label="æŠ˜å /å±•å¼€ç« èŠ‚" title="æŠ˜å /å±•å¼€">
                        <svg class="toc-caret" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                          <path d="M6 9l6 6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                      </button>
                      ${headLink}
                    </div>
                    <div class="toc-children">${childrenHtml}</div>
                  </div>
                `;
              })
              .join('');

            const links = Array.from(body.querySelectorAll('a[data-target]'));

            function collapseAllExcept(groupId) {
              try {
                body.querySelectorAll('.toc-group').forEach((el) => {
                  const gid = el.getAttribute('data-group-id') || '';
                  if (!gid) return;
                  if (gid === groupId) el.classList.remove('is-collapsed');
                  else if (el.querySelector('.toc-children') && el.querySelector('.toc-children').children.length) el.classList.add('is-collapsed');
                });
              } catch (e) { /* ignore */ }
            }

            function syncTreeById(id, persist) {
              const gid = idToGroup.get(id);
              if (!gid) return;
              collapseAllExcept(gid);
              if (persist) {
                setLastOpen(gid);
                // å¦‚æœè¿™ä¸ªç« èŠ‚æ›¾è¢«æ‰‹åŠ¨æŠ˜å è¿‡ï¼Œè¿™é‡Œå±•å¼€ååŒæ­¥æ¸…æ‰æŠ˜å è®°å½•
                setCollapsed(gid, false);
              }
            }

            // åˆå§‹å±•å¼€ï¼šä¼˜å…ˆ URL é‡Œçš„ idï¼Œå…¶æ¬¡ç”¨ lastOpen
            try {
              const hash = location.hash || '';
              const q = hash.includes('?') ? hash.split('?')[1] : '';
              const id = q ? (new URLSearchParams(q).get('id') || '') : '';
              if (id && idToGroup.has(id)) syncTreeById(id, false);
              else if (treeState.lastOpen && groupIds.includes(treeState.lastOpen)) collapseAllExcept(treeState.lastOpen);
            } catch (e) { /* ignore */ }

            function setActive(id) {
              if (!id) return;
              links.forEach((a) => a.classList.toggle('is-active', a.getAttribute('data-target') === id));
            }

            function replaceUrlId(id) {
              try {
                history.replaceState(null, document.title, buildHeadingUrlById(id));
              } catch (e) {
                // ignore
              }
            }

            // ç‚¹å‡»ï¼šå¹³æ»‘æ»šåŠ¨åˆ° headingï¼ˆä¸ push æ–° historyï¼Œæ”¹ç”¨ replaceStateï¼‰
            links.forEach((a) => {
              a.onclick = (e) => {
                e.preventDefault();
                const id = a.getAttribute('data-target');
                const target = section.querySelector(`#${CSS.escape(id)}`);
                if (target) {
                  // è®°å½•"è·³è½¬å‰"çš„é˜…è¯»ä½ç½®ï¼Œä¾¿äºä¸€é”®è¿”å›
                  try { pushTocJumpPoint(); } catch (e) { /* ignore */ }

                  target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                  setActive(id);
                  try { syncTreeById(id, true); } catch (e) { /* ignore */ }
                  replaceUrlId(id);
                  try {
                    if (window.innerWidth <= 1023) toc.classList.remove('is-open');
                  } catch (err) { /* ignore */ }
                }
              };
            });

            // æ›´ç¨³çš„é«˜äº®ï¼šIntersectionObserver + æ»šåŠ¨å…œåº•
            if (tocObserver) {
              try { tocObserver.disconnect(); } catch (e) {}
              tocObserver = null;
            }

            let currentId = '';
            const visibleMap = new Map();

            function pickByScroll() {
              if (!items.length) return;

              const THRESHOLD = 120;
              let best = null;
              let bestAbove = null;

              for (let i = 0; i < items.length; i++) {
                const it = items[i];
                const top = it.el.getBoundingClientRect().top;

                // è§†å£ä¸Šæ–¹æœ€è¿‘çš„ä¸€ä¸ª headingï¼ˆå«é˜ˆå€¼ï¼‰
                if (top <= THRESHOLD) {
                  if (!bestAbove || top > bestAbove.top) bestAbove = { id: it.id, top: top };
                }

                // è§†å£å†…æœ€è¿‘çš„ä¸€ä¸ª heading
                if (top >= 0) {
                  if (!best || top < best.top) best = { id: it.id, top: top };
                }
              }

              const picked = bestAbove ? bestAbove.id : (best ? best.id : items[0].id);
              if (picked && picked !== currentId) {
                currentId = picked;
                setActive(picked);
                try { syncTreeById(picked, false); } catch (e) { /* ignore */ }
              }
            }

            tocObserver = new IntersectionObserver(
              (entries) => {
                entries.forEach((en) => {
                  const id = en.target && en.target.getAttribute ? (en.target.getAttribute('id') || '') : '';
                  if (!id) return;
                  if (en.isIntersecting) visibleMap.set(id, en.boundingClientRect.top);
                  else visibleMap.delete(id);
                });

                const visible = Array.from(visibleMap.entries())
                  .map(([id, top]) => ({ id, top }))
                  .sort((a, b) => a.top - b.top);

                if (visible.length) {
                  const id = visible[0].id;
                  if (id && id !== currentId) {
                    currentId = id;
                    setActive(id);
                    try { syncTreeById(id, false); } catch (e) { /* ignore */ }
                  }
                }
              },
              { root: null, rootMargin: '-18% 0px -72% 0px', threshold: [0, 1] }
            );

            items.forEach((it) => tocObserver.observe(it.el));

            // ç»‘å®šä¸€æ¬¡å…¨å±€æ»šåŠ¨å…œåº•ï¼ˆæ¯æ¬¡ renderToc åªæ›´æ–° tocScrollUpdate é—­åŒ…ï¼‰
            tocScrollUpdate = function () {
              pickByScroll();
            };

            if (!tocScrollBound) {
              tocScrollBound = true;
              let ticking = false;
              const onScroll = () => {
                if (ticking) return;
                ticking = true;
                requestAnimationFrame(() => {
                  ticking = false;
                  if (tocScrollUpdate) tocScrollUpdate();
                });
              };
              window.addEventListener('scroll', onScroll, { passive: true });
              window.addEventListener('resize', onScroll, { passive: true });
            }

            // åˆå§‹é«˜äº®ï¼šä¼˜å…ˆç”¨ URL çš„ id
            const urlId = new URLSearchParams(location.hash.split('?')[1] || '').get('id');
            if (urlId) {
              setActive(urlId);
              currentId = urlId;
            } else {
              pickByScroll();
            }

            // å›¾ç‰‡åŠ è½½åå¯èƒ½å¯¼è‡´ heading ä½ç½®å˜åŒ–ï¼Œè¡¥ä¸€æ¬¡é‡ç®—
            const imgs = Array.from(section.querySelectorAll('img'));
            const schedule = () => {
              requestAnimationFrame(() => {
                if (tocScrollUpdate) tocScrollUpdate();
              });
            };
            imgs.forEach((img) => {
              if (!img || img.complete) return;
              try { img.addEventListener('load', schedule, { once: true }); } catch (e) { /* ignore */ }
            });

            setTimeout(schedule, 120);
            setTimeout(schedule, 600);

            return true;
          }

          /* ---------------- é˜…è¯»ä½“éªŒå¢å¼ºï¼šè¿›åº¦æ¡ / é¢åŒ…å±‘ / ä¸Šä¸€ç¯‡ä¸‹ä¸€ç¯‡ ---------------- */
          let progressBound = false;
          let progressUpdate = null;

          function ensureProgressBar() {
            let bar = document.getElementById('read-progress');
            if (!bar) {
              bar = document.createElement('div');
              bar.id = 'read-progress';
              document.body.appendChild(bar);
            }

            function calcProgress() {
              const doc = document.documentElement;
              const scrollTop = doc.scrollTop || document.body.scrollTop || 0;
              const height = (doc.scrollHeight || 0) - (doc.clientHeight || 0);
              if (height <= 0) return 0;
              return Math.max(0, Math.min(1, scrollTop / height));
            }

            function update() {
              const pct = calcProgress();
              bar.style.width = `${(pct * 100).toFixed(2)}%`;
            }

            progressUpdate = update;

            if (!progressBound) {
              progressBound = true;
              let ticking = false;
              const onScroll = () => {
                if (ticking) return;
                ticking = true;
                requestAnimationFrame(() => {
                  ticking = false;
                  if (progressUpdate) progressUpdate();
                });
              };

              window.addEventListener('scroll', onScroll, { passive: true });
              window.addEventListener('resize', onScroll, { passive: true });
            }

            update();
          }

          function normalizePath(p) {
            if (!p) return '/';
            p = String(p).split('?')[0];
            if (!p.startsWith('/')) p = '/' + p;
            // docsify route path ä¸€èˆ¬ä¸ä»¥ / ç»“å°¾ï¼ˆæ ¹è·¯å¾„é™¤å¤–ï¼‰
            if (p.length > 1) p = p.replace(/\/+$/, '');
            return p || '/';
          }

          function normalizeHrefToPath(href) {
            if (!href) return '';
            const h = String(href);
            if (!h.startsWith('#')) return '';
            const afterHash = h.slice(1);
            return normalizePath(afterHash);
          }

          function getSidebarLinks() {
            const nav = document.querySelector('.sidebar-nav');
            if (!nav) return [];

            const anchors = Array.from(nav.querySelectorAll('a[href]'));
            const seen = new Set();
            const list = [];

            anchors.forEach((a) => {
              const href = a.getAttribute('href') || '';
              if (!href.startsWith('#/')) return;
              if (href === '#') return;

              const path = normalizeHrefToPath(href);
              if (!path) return;

              // è¿‡æ»¤æ‰åªç”¨äºç›®å½•çš„ hash é“¾æ¥ï¼ˆæ¯”å¦‚ #/xxx?id=...ï¼‰ï¼Œæˆ‘ä»¬åªçœ‹ path
              const key = path;
              if (seen.has(key)) return;
              seen.add(key);

              const text = (a.textContent || '').trim();
              if (!text) return;

              list.push({ href, path, text, el: a });
            });

            return list;
          }

          function ensureBreadcrumb(section) {
            let bc = section.querySelector('#page-breadcrumb');
            if (!bc) {
              bc = document.createElement('div');
              bc.id = 'page-breadcrumb';
              bc.className = 'page-breadcrumb';
              const meta = section.querySelector('#page-meta');
              if (meta) meta.insertAdjacentElement('afterend', bc);
              else section.insertBefore(bc, section.firstChild);
            }
            return bc;
          }

          function renderBreadcrumbAndNav(vm) {
            const section = document.querySelector('.markdown-section');
            if (!section) return;

            const currentPath = normalizePath(vm && vm.route && vm.route.path ? vm.route.path : '/');
            const links = getSidebarLinks();

            // Sidebar å¯èƒ½ç¨åæ‰æ¸²æŸ“å¥½ï¼Œåšä¸€æ¬¡è½»é‡é‡è¯•
            if (!links.length) {
              setTimeout(() => {
                const again = getSidebarLinks();
                if (again.length) renderBreadcrumbAndNav(vm);
              }, 250);
              return;
            }

            const idx = links.findIndex((it) => it.path === currentPath);

            // é¢åŒ…å±‘ï¼šä» sidebar DOM å‘ä¸Šæ‰¾çˆ¶çº§ li çš„æ ‡é¢˜
            const bc = ensureBreadcrumb(section);
            let crumbHtml = '';

            function getLiLabel(li) {
              const a = li.querySelector(':scope > a');
              if (a) return (a.textContent || '').trim();
              const p = li.querySelector(':scope > p');
              if (p) return (p.textContent || '').trim();
              const span = li.querySelector(':scope > span');
              if (span) return (span.textContent || '').trim();
              const first = li.childNodes && li.childNodes[0] ? (li.childNodes[0].textContent || '') : '';
              return String(first).trim();
            }

            let currentEl = null;
            if (idx >= 0) currentEl = links[idx].el;
            else {
              // fallbackï¼šæŒ‰ href å‰ç¼€åŒ¹é…
              const cand = links.find((it) => it.href && normalizeHrefToPath(it.href) === currentPath);
              currentEl = cand ? cand.el : null;
            }

            const crumbs = [{ text: 'é¦–é¡µ', href: '#/' }];

            if (currentEl) {
              let li = currentEl.closest('li');
              const chain = [];
              while (li) {
                const label = getLiLabel(li);
                const a = li.querySelector(':scope > a');
                const href = a ? a.getAttribute('href') : '';
                if (label) chain.push({ text: label, href: href && href.startsWith('#/') ? href : '' });
                li = li.parentElement ? li.parentElement.closest('li') : null;
              }
              chain.reverse();
              chain.forEach((c, i) => {
                // æœ€åä¸€é¡¹æ˜¯å½“å‰é¡µï¼Œä¸ç”¨åšé“¾æ¥
                if (i === chain.length - 1) crumbs.push({ text: c.text, href: '' });
                else crumbs.push(c);
              });
            }

            crumbHtml = crumbs
              .map((c, i) => {
                const sep = i === 0 ? '' : '<span class="crumb-sep">/</span>';
                const text = escapeHtml(c.text);
                const node = c.href ? `<a href="${c.href}">${text}</a>` : `<span>${text}</span>`;
                return `${sep}${node}`;
              })
              .join(' ');

            bc.innerHTML = crumbHtml;

            // ä¸Šä¸€ç¯‡ / ä¸‹ä¸€ç¯‡
            let nav = section.querySelector('#page-nav');
            if (!nav) {
              nav = document.createElement('div');
              nav.id = 'page-nav';
              nav.className = 'page-nav';
              const g = section.querySelector('#giscus');
              if (g) section.insertBefore(nav, g);
              else section.appendChild(nav);
            }

            const prev = idx > 0 ? links[idx - 1] : null;
            const next = idx >= 0 && idx < links.length - 1 ? links[idx + 1] : null;

            nav.innerHTML = `
              <a class="${prev ? '' : 'is-disabled'}" href="${prev ? prev.href : '#'}" aria-disabled="${prev ? 'false' : 'true'}">
                <div class="nav-kicker">â† ä¸Šä¸€ç¯‡</div>
                <div class="nav-title">${prev ? escapeHtml(prev.text) : 'æ²¡æœ‰äº†'}</div>
              </a>
              <a class="${next ? '' : 'is-disabled'}" href="${next ? next.href : '#'}" aria-disabled="${next ? 'false' : 'true'}">
                <div class="nav-kicker">ä¸‹ä¸€ç¯‡ â†’</div>
                <div class="nav-title">${next ? escapeHtml(next.text) : 'æ²¡æœ‰äº†'}</div>
              </a>
            `;
          }

          /* ---------------- å…¨æ–‡æœç´¢ï¼ˆCtrl/âŒ˜+Kï¼‰ï¼šè·¨é¡µé¢ç´¢å¼• + ç»“æœé«˜äº® + è·³è½¬å®šä½ ---------------- */
          let ftsBound = false;
          let ftsIndexBuilding = false;
          let ftsIndex = null; // { v, key, linksHash, pages: [{path, href, title, text}] }
          let ftsPendingJump = null; // { path, query, ts }

          function getBaseDir() {
            try {
              const p = location.pathname || '/';
              const siteDir = p.endsWith('/') ? p : p.replace(/\/[^\/]*$/, '/');
              const bp = window.$docsify && window.$docsify.basePath;
              if (bp) {
                let b = String(bp);
                // æ”¯æŒ "docs/" è¿™ç±»ç›¸å¯¹è·¯å¾„ï¼›ä¹Ÿæ”¯æŒ "/docs/" è¿™ç±»ç»å¯¹è·¯å¾„
                if (!b.startsWith('/')) b = siteDir + b;
                // è§„èŒƒåŒ–å¤šä½™çš„ / å¹¶ç¡®ä¿ä»¥ / ç»“å°¾
                b = b.replace(/\/+/g, '/');
                if (!b.endsWith('/')) b += '/';
                return b;
              }
              return siteDir;
            } catch (e) {
              return '/';
            }
          }

          function getFtsStorageKey() {
            const base = getBaseDir();
            return `fts-index:${base}`;
          }

          function debounce(fn, wait) {
            let t = null;
            return function () {
              const args = arguments;
              if (t) {
                try { clearTimeout(t); } catch (e) { /* ignore */ }
              }
              t = setTimeout(() => {
                t = null;
                fn.apply(null, args);
              }, wait);
            };
          }

          function safeJsonParse(str) {
            try { return JSON.parse(str); } catch (e) { return null; }
          }

          function stripMarkdown(md) {
            const s = String(md || '');
            return s
              .replace(/```[\s\S]*?```/g, ' ')
              .replace(/`[^`]*`/g, ' ')
              .replace(/!\[[^\]]*\]\([^\)]*\)/g, ' ')
              .replace(/\[[^\]]*\]\([^\)]*\)/g, function (m) {
                const t = m.replace(/^\[|\].*$/g, '');
                return t || ' ';
              })
              .replace(/^\s{0,3}#{1,6}\s+/gm, '')
              .replace(/^\s{0,3}>\s?/gm, '')
              .replace(/\*\*([^*]+)\*\*/g, '$1')
              .replace(/\*([^*]+)\*/g, '$1')
              .replace(/__([^_]+)__/g, '$1')
              .replace(/_([^_]+)_/g, '$1')
              .replace(/<[^>]+>/g, ' ')
              .replace(/\r?\n/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
          }

          function pathToMdUrl(path) {
            const p = normalizePath(path);
            let md = '';
            if (p === '/' || p === '/README') md = 'README.md';
            else md = p.replace(/^\//, '') + '.md';
            return getBaseDir() + md;
          }

          function getLinksHash(links) {
            try {
              return links.map((x) => x.path).join('|');
            } catch (e) {
              return '';
            }
          }

          function ensureFtsModal() {
            let modal = document.getElementById('fts-modal');
            if (modal) return modal;

            modal = document.createElement('div');
            modal.id = 'fts-modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-label', 'å…¨æ–‡æœç´¢');
            modal.innerHTML = `
              <div class="fts-backdrop" data-fts-action="close"></div>
              <div class="fts-panel" role="document">
                <div class="fts-head">
                  <input class="fts-input" id="fts-input" type="search" placeholder="å…¨æ–‡æœç´¢â€¦" autocomplete="off" spellcheck="false" />
                  <button type="button" class="fts-close" data-fts-action="close" aria-label="å…³é—­" title="å…³é—­">Ã—</button>
                </div>
                <div class="fts-meta">
                  <div class="fts-meta-left" id="fts-meta-left">è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</div>
                  <div class="fts-meta-right">
                    <a class="fts-link" href="#" data-fts-action="rebuild">é‡å»ºç´¢å¼•</a>
                    <span class="fts-hint">Esc å…³é—­</span>
                  </div>
                </div>
                <div class="fts-results" id="fts-results" role="list"></div>
              </div>
            `;
            document.body.appendChild(modal);
            return modal;
          }

          function isTypingTarget(el) {
            if (!el) return false;
            const tag = (el.tagName || '').toUpperCase();
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || el.isContentEditable;
          }

          function openFts() {
            const modal = ensureFtsModal();
            modal.classList.add('is-open');
            try {
              const input = modal.querySelector('#fts-input');
              if (input) {
                input.focus();
                input.select();
              }
            } catch (e) { /* ignore */ }

            // å»¶è¿Ÿè§¦å‘ä¸€æ¬¡ç´¢å¼•æ„å»ºï¼ˆæ‡’åŠ è½½ï¼Œé¿å…é¦–å±é˜»å¡ï¼‰
            setTimeout(() => {
              try { ensureFtsIndex(false); } catch (e) { /* ignore */ }
            }, 0);
          }

          function closeFts() {
            const modal = document.getElementById('fts-modal');
            if (!modal) return;
            modal.classList.remove('is-open');
          }

          function setFtsMeta(text) {
            const el = document.getElementById('fts-meta-left');
            if (el) el.textContent = text || '';
          }

          function escapeForRegExp(s) {
            return String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          }

          function highlightHtml(text, terms) {
            const safe = escapeHtml(String(text || ''));
            const list = (terms || []).filter(Boolean);
            if (!list.length) return safe;
            const re = new RegExp('(' + list.map(escapeForRegExp).join('|') + ')', 'ig');
            return safe.replace(re, '<mark>$1</mark>');
          }

          function buildSnippet(text, q) {
            const t = String(text || '');
            const needle = String(q || '').trim();
            if (!needle) return '';
            const lowerT = t.toLowerCase();
            const lowerN = needle.toLowerCase();
            const idx = lowerT.indexOf(lowerN);
            if (idx < 0) return t.slice(0, 120);
            const start = Math.max(0, idx - 48);
            const end = Math.min(t.length, idx + lowerN.length + 72);
            const prefix = start > 0 ? 'â€¦' : '';
            const suffix = end < t.length ? 'â€¦' : '';
            return prefix + t.slice(start, end) + suffix;
          }

          function scorePage(page, q, terms) {
            const title = (page.title || '').toLowerCase();
            const body = (page.text || '').toLowerCase();
            const qq = String(q || '').toLowerCase();
            let score = 0;
            if (qq && title.includes(qq)) score += 30;
            if (qq && body.includes(qq)) score += 8;

            if (terms && terms.length) {
              let hitAll = true;
              terms.forEach((term) => {
                const tt = String(term || '').toLowerCase();
                if (!tt) return;
                if (title.includes(tt)) score += 12;
                if (body.includes(tt)) score += 3;
                if (!title.includes(tt) && !body.includes(tt)) hitAll = false;
              });
              if (hitAll) score += 10;
            }
            return score;
          }

          function searchInIndex(q) {
            const query = String(q || '').trim();
            if (!query) return [];
            if (!ftsIndex || !ftsIndex.pages || !ftsIndex.pages.length) return [];

            const isCjk = /[\u3400-\u9FFF]/.test(query);
            const terms = isCjk ? [query] : query.split(/\s+/).filter(Boolean).slice(0, 6);

            const scored = [];
            for (let i = 0; i < ftsIndex.pages.length; i++) {
              const p = ftsIndex.pages[i];
              const s = scorePage(p, query, terms);
              if (s > 0) scored.push({ page: p, score: s });
            }

            scored.sort((a, b) => b.score - a.score);
            return scored.slice(0, 24);
          }

          function renderFtsResults(q) {
            const modal = ensureFtsModal();
            const resultsEl = modal.querySelector('#fts-results');
            if (!resultsEl) return;

            const query = String(q || '').trim();
            if (!query) {
              resultsEl.innerHTML = '';
              setFtsMeta('è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢');
              return;
            }

            if (ftsIndexBuilding) {
              setFtsMeta('æ­£åœ¨å»ºç«‹ç´¢å¼•â€¦ï¼ˆé¦–æ¬¡ä¼šç¨æ…¢ï¼Œä¹‹åä¼šç¼“å­˜ï¼‰');
            }

            const hits = searchInIndex(query);
            const isCjk = /[\u3400-\u9FFF]/.test(query);
            const terms = isCjk ? [query] : query.split(/\s+/).filter(Boolean).slice(0, 6);

            setFtsMeta(hits.length ? `æ‰¾åˆ° ${hits.length} æ¡ç»“æœ` : 'æœªæ‰¾åˆ°ç»“æœ');

            resultsEl.innerHTML = hits.map((h) => {
              const p = h.page;
              const titleHtml = highlightHtml(p.title || p.path, terms);
              const snippet = buildSnippet(p.text || '', query);
              const snippetHtml = highlightHtml(snippet, terms);
              return `
                <a class="fts-item" href="${escapeHtml(p.href || ('#' + p.path))}" data-fts-path="${escapeHtml(p.path)}" data-fts-query="${escapeHtml(query)}" role="listitem">
                  <div class="fts-title">${titleHtml}</div>
                  <div class="fts-snippet">${snippetHtml}</div>
                </a>
              `;
            }).join('');
          }

          const onFtsInput = debounce(function (val) {
            renderFtsResults(val);
          }, 120);

          function loadCachedIndex(linksHash) {
            try {
              const key = getFtsStorageKey();
              const raw = localStorage.getItem(key);
              const obj = raw ? safeJsonParse(raw) : null;
              if (!obj || obj.v !== 1) return null;
              if (obj.linksHash !== linksHash) return null;
              if (!obj.pages || !Array.isArray(obj.pages)) return null;
              return obj;
            } catch (e) {
              return null;
            }
          }

          function saveCachedIndex(obj) {
            try {
              const key = getFtsStorageKey();
              localStorage.setItem(key, JSON.stringify(obj));
            } catch (e) {
              // ignore
            }
          }

          async function buildIndex(links, linksHash) {
            const pages = [];
            for (let i = 0; i < links.length; i++) {
              const it = links[i];
              const path = normalizePath(it.path);
              const href = it.href;
              const mdUrl = pathToMdUrl(path);
              try {
                const res = await fetch(mdUrl, { cache: 'no-store' });
                const md = await res.text();
                const text = stripMarkdown(md);
                pages.push({ path, href, title: it.text || path, text });
              } catch (e) {
                pages.push({ path, href, title: it.text || path, text: '' });
              }
              setFtsMeta(`æ­£åœ¨å»ºç«‹ç´¢å¼•â€¦ ${i + 1}/${links.length}`);
            }
            return { v: 1, key: getFtsStorageKey(), linksHash, pages, ts: Date.now() };
          }

          function ensureFtsIndex(forceRebuild) {
            if (ftsIndexBuilding) return;

            const links = getSidebarLinks();
            const linksHash = getLinksHash(links);
            if (!forceRebuild) {
              const cached = loadCachedIndex(linksHash);
              if (cached) {
                ftsIndex = cached;
                return;
              }
            }

            // æ²¡æ‹¿åˆ° sidebar é“¾æ¥æ—¶ï¼šç¨åå†è¯•ï¼ˆé¿å…ç™½å±æœŸè¯¯åˆ¤ï¼‰
            if (!links.length) {
              setTimeout(() => {
                try { ensureFtsIndex(forceRebuild); } catch (e) { /* ignore */ }
              }, 260);
              return;
            }

            ftsIndexBuilding = true;
            setFtsMeta('æ­£åœ¨å»ºç«‹ç´¢å¼•â€¦');

            buildIndex(links, linksHash).then((obj) => {
              ftsIndex = obj;
              saveCachedIndex(obj);
              ftsIndexBuilding = false;
              // å¦‚æœæ­¤æ—¶è¾“å…¥æ¡†é‡Œå·²æœ‰å†…å®¹ï¼Œåˆ·æ–°ä¸€æ¬¡ç»“æœ
              try {
                const input = document.getElementById('fts-input');
                if (input && input.value) renderFtsResults(input.value);
              } catch (e) { /* ignore */ }
            }).catch(() => {
              ftsIndexBuilding = false;
            });
          }

          function clearPageHighlights() {
            try {
              document.querySelectorAll('.fts-mark').forEach((el) => {
                const parent = el.parentNode;
                if (!parent) return;
                parent.replaceChild(document.createTextNode(el.textContent || ''), el);
                parent.normalize();
              });
            } catch (e) { /* ignore */ }
          }

          function highlightInPageExact(query) {
            const q = String(query || '').trim();
            if (!q) return false;

            const section = document.querySelector('.markdown-section');
            if (!section) return false;

            clearPageHighlights();

            const walker = document.createTreeWalker(section, NodeFilter.SHOW_TEXT, {
              acceptNode: function (node) {
                if (!node || !node.parentElement) return NodeFilter.FILTER_REJECT;
                const text = (node.nodeValue || '').trim();
                if (!text) return NodeFilter.FILTER_REJECT;

                const p = node.parentElement;
                if (p.closest('pre, code, #toc-aside, #page-meta, #giscus')) return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
              }
            });

            const hits = [];
            const lowerQ = q.toLowerCase();
            while (walker.nextNode()) {
              const node = walker.currentNode;
              const v = node.nodeValue || '';
              const idx = v.toLowerCase().indexOf(lowerQ);
              if (idx < 0) continue;
              hits.push({ node, idx });
              if (hits.length >= 30) break;
            }

            hits.forEach((h) => {
              const node = h.node;
              const v = node.nodeValue || '';
              const before = v.slice(0, h.idx);
              const mid = v.slice(h.idx, h.idx + q.length);
              const after = v.slice(h.idx + q.length);

              const frag = document.createDocumentFragment();
              if (before) frag.appendChild(document.createTextNode(before));
              const mark = document.createElement('mark');
              mark.className = 'fts-mark';
              mark.textContent = mid;
              frag.appendChild(mark);
              if (after) frag.appendChild(document.createTextNode(after));

              try {
                node.parentNode.replaceChild(frag, node);
              } catch (e) { /* ignore */ }
            });

            const first = document.querySelector('.fts-mark');
            if (first && first.scrollIntoView) {
              try { first.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { /* ignore */ }
              return true;
            }
            return false;
          }

          function ensureFullTextSearch(vm) {
            if (ftsBound) return;
            ftsBound = true;

            ensureFtsModal();

            document.addEventListener('click', function (e) {
              const t = e && e.target;
              const toggle = t && t.closest ? t.closest('#search-toggle') : null;
              if (toggle) {
                e.preventDefault();
                openFts();
                return;
              }

              const action = t && t.getAttribute ? (t.getAttribute('data-fts-action') || '') : '';
              if (action === 'close') {
                e.preventDefault();
                closeFts();
                return;
              }
              if (action === 'rebuild') {
                e.preventDefault();
                try {
                  ftsIndex = null;
                  ensureFtsIndex(true);
                } catch (err) { /* ignore */ }
                return;
              }

              const item = t && t.closest ? t.closest('#fts-modal .fts-item') : null;
              if (item) {
                const path = item.getAttribute('data-fts-path') || '';
                const q = item.getAttribute('data-fts-query') || '';
                ftsPendingJump = { path: normalizePath(path), query: q, ts: Date.now() };
                closeFts();
                // è®© docsify è‡ªå·±å¤„ç†è·¯ç”±
                return;
              }
            }, true);

            document.addEventListener('keydown', function (e) {
              const k = e && (e.key || '').toLowerCase();
              const isK = k === 'k';
              const isEsc = k === 'escape';

              // Esc å…³é—­
              if (isEsc) {
                const modal = document.getElementById('fts-modal');
                if (modal && modal.classList.contains('is-open')) {
                  e.preventDefault();
                  closeFts();
                  return;
                }
              }

              // Ctrl/âŒ˜+K æ‰“å¼€
              if (isK && (e.metaKey || e.ctrlKey)) {
                // é¿å…å½±å“è¾“å…¥æ¡†å†…å¿«æ·é”®
                if (isTypingTarget(e.target)) return;
                e.preventDefault();
                openFts();
                return;
              }
            }, true);

            const modal = document.getElementById('fts-modal');
            if (modal) {
              const input = modal.querySelector('#fts-input');
              if (input) {
                input.addEventListener('input', function () {
                  onFtsInput(input.value);
                });
                input.addEventListener('keydown', function (e) {
                  const k = (e.key || '').toLowerCase();
                  if (k === 'enter') {
                    const first = modal.querySelector('.fts-item');
                    if (first) {
                      e.preventDefault();
                      first.click();
                    }
                  }
                });
              }
            }

            // é¦–æ¬¡æå‰å°è¯•è¯»ç¼“å­˜ï¼ˆä¸å¼ºåˆ¶ rebuildï¼‰
            try { ensureFtsIndex(false); } catch (e) { /* ignore */ }
          }

          function maybeApplyPendingHighlight(vm) {
            if (!ftsPendingJump) return;
            const now = Date.now();
            if (now - (ftsPendingJump.ts || 0) > 15 * 1000) {
              ftsPendingJump = null;
              return;
            }

            const cur = normalizePath(vm && vm.route && vm.route.path ? vm.route.path : '/');
            if (cur !== normalizePath(ftsPendingJump.path)) return;

            const q = ftsPendingJump.query;
            ftsPendingJump = null;

            // è·³è½¬åï¼šåœ¨é¡µé¢å†…åšä¸€æ¬¡"ç²¾ç¡®ä¸²"é«˜äº®å¹¶æ»šåˆ°é¦–ä¸ªå‘½ä¸­
            try { highlightInPageExact(q); } catch (e) { /* ignore */ }
          }

          function ensureGiscusHost() {
            const section = document.querySelector('.markdown-section');
            if (!section) return null;

            let host = section.querySelector('#giscus');
            if (!host) {
              host = document.createElement('div');
              host.id = 'giscus';
              host.innerHTML = `
                <div class="giscus-card">
                  <div class="giscus-head">
                    <div class="giscus-head-left">
                      <div class="giscus-title">è¯„è®º</div>
                      <div class="giscus-meta">GitHub Discussions</div>
                    </div>
                    <a class="giscus-badge" href="https://github.com/LoveEleve/LoveEleve.github.io/discussions" target="_blank" rel="noopener noreferrer">æ‰“å¼€è®¨è®ºåŒº</a>
                  </div>
                  <div class="giscus-body"></div>
                </div>
              `;
              section.appendChild(host);
            }

            // å…¼å®¹æ—§ç»“æ„å…œåº•
            if (!host.querySelector('.giscus-body')) {
              const body = document.createElement('div');
              body.className = 'giscus-body';
              host.appendChild(body);
            }

            return host;
          }

          function renderOrUpdateGiscus(term) {
            const host = ensureGiscusHost();
            if (!host) return;

            const mount = host.querySelector('.giscus-body') || host;

            // å·²ç»æœ‰ iframeï¼šç”¨ postMessage åˆ‡æ¢åˆ°æ–°çš„ term
            const iframe = mount.querySelector('iframe.giscus-frame');
            if (iframe && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({
                  giscus: {
                    setConfig: {
                      term: term
                    }
                  }
                }, 'https://giscus.app');
                return;
              } catch (e) {
                // fallback to re-render
              }
            }

            // é¦–æ¬¡æ¸²æŸ“ / å…œåº•é‡æ¸²æŸ“
            mount.innerHTML = '';
            const s = document.createElement('script');
            s.src = GISCUS_CFG.src;
            s.async = true;
            s.crossOrigin = 'anonymous';
            s.setAttribute('data-repo', GISCUS_CFG.repo);
            s.setAttribute('data-repo-id', GISCUS_CFG.repoId);
            s.setAttribute('data-category', GISCUS_CFG.category);
            s.setAttribute('data-category-id', GISCUS_CFG.categoryId);
            s.setAttribute('data-mapping', GISCUS_CFG.mapping);
            s.setAttribute('data-term', term);
            s.setAttribute('data-strict', GISCUS_CFG.strict);
            s.setAttribute('data-reactions-enabled', GISCUS_CFG.reactionsEnabled);
            s.setAttribute('data-emit-metadata', GISCUS_CFG.emitMetadata);
            s.setAttribute('data-input-position', GISCUS_CFG.inputPosition);
            s.setAttribute('data-theme', GISCUS_CFG.theme);
            s.setAttribute('data-lang', GISCUS_CFG.lang);
            host.appendChild(s);
          }

          let giscusThemeBound = false;

          function rerenderGiscus(term) {
            const host = ensureGiscusHost();
            if (!host) return;

            const mount = host.querySelector('.giscus-body') || host;

            // æ¸…ç† iframe/scriptï¼Œå¼ºåˆ¶é‡æ–°åˆå§‹åŒ–ï¼ˆä¸»é¢˜åˆ‡æ¢éœ€è¦é‡æ¸²æŸ“ï¼‰
            try {
              host.querySelectorAll('iframe.giscus-frame').forEach((el) => el.remove());
              host.querySelectorAll('script[src*="giscus.app/client.js"]').forEach((el) => el.remove());
            } catch (e) {
              // ignore
            }

            mount.innerHTML = '';
            renderOrUpdateGiscus(term);
          }

          function bindThemeChangeForGiscus() {
            if (giscusThemeBound) return;
            giscusThemeBound = true;

            window.addEventListener('docsify-theme-change', function (ev) {
              const resolved = (ev && ev.detail && ev.detail.resolved) ? ev.detail.resolved : (document.documentElement.getAttribute('data-theme') || 'light');
              const want = resolved === 'dark' ? 'dark' : 'light';
              if (GISCUS_CFG.theme === want) return;

              GISCUS_CFG.theme = want;
              rerenderGiscus(getGiscusTerm(vm));
            });
          }

          bindThemeChangeForGiscus();

          hook.doneEach(function () {
            document.querySelectorAll('pre[data-lang]').forEach(function (pre) {
              // é¿å…é‡å¤åˆå§‹åŒ–
              if (pre.dataset.inlineFoldInited === '1') return;
              pre.dataset.inlineFoldInited = '1';

              // å…ˆåˆå§‹åŒ–æŠ˜å ï¼ˆä¼šä¿å­˜ rawCodeï¼‰ï¼Œå†åŠ å·¥å…·æ 
              initInlineFolding(pre);
              initToolbar(pre);

              // å¤§ä»£ç å—ï¼ˆè·³è¿‡é€è¡ŒæŠ˜å ï¼‰ï¼šä¿æŒåŸæ ·ï¼ˆä¸å±•ç¤ºè¡Œå·ï¼‰
            });

            // æ–‡ç« å…ƒä¿¡æ¯ï¼šéšè·¯ç”±åˆ‡æ¢åˆ·æ–°ï¼ˆæ›´æ–°æ—¶é—´/é˜…è¯»æ—¶é•¿/å­—æ•°ï¼‰
            renderPageMeta(vm);

            // æ ‡é¢˜ï¼šå¤åˆ¶é“¾æ¥æŒ‰é’®
            renderHeadingLinks(vm);

            // ç›®å½•ï¼ˆå°å±/å…œåº•å…¥å£ï¼‰ï¼šå…ˆç¡®ä¿æŒ‰é’®ä¸ç‚¹å‡»ç»‘å®šä¸€å®šå­˜åœ¨ï¼Œå†è§¦å‘é‡ç®—
            try { ensureTocMobileDelegation(); } catch (e) { /* ignore */ }
            try { setTocFabState(false); } catch (e) { /* ignore */ }

            // ç›®å½•è·³è½¬è¿”å›æ ˆï¼šä»…åœ¨çœŸæ­£æ¢é¡µé¢ï¼ˆpath å˜åŒ–ï¼‰æ—¶æ¸…ç©ºï¼Œé¿å…åŒé¡µæ›´æ–°å¯¼è‡´"è¿”å›ç‚¹"ä¸¢å¤±
            try {
              const p = (vm && vm.route && vm.route.path) ? vm.route.path : ((location.hash || '#/').split('?')[0] || '#/');
              const norm = String(p || '').split('?')[0];
              if (!tocLastRoutePath || norm !== tocLastRoutePath) {
                tocJumpStack = [];
                tocLastRoutePath = norm;
              }
            } catch (e) { /* ignore */ }
            try { setTocBackState(); } catch (e) { /* ignore */ }

            // å³ä¾§ç›®å½•ï¼šè‡ªåŠ¨ç”Ÿæˆ + å½“å‰å°èŠ‚é«˜äº®
            scheduleTocRender(vm);

            // é˜…è¯»ä½“éªŒï¼šè¿›åº¦æ¡ / é¢åŒ…å±‘ / ä¸Šä¸€ç¯‡ä¸‹ä¸€ç¯‡
            ensureProgressBar();
            renderBreadcrumbAndNav(vm);

            // å…¨æ–‡æœç´¢ï¼ˆCtrl/âŒ˜+Kï¼‰ï¼šç»‘å®šå¿«æ·é”® + æ‡’åŠ è½½ç´¢å¼•
            ensureFullTextSearch(vm);
            maybeApplyPendingHighlight(vm);

            // å›¾ç‰‡ç¼©æ”¾ï¼šéšè·¯ç”±åˆ‡æ¢é‡æ–°ç»‘å®šï¼ˆåªç»‘å®šæ­£æ–‡å›¾ç‰‡ï¼‰
            scheduleImageZoom();

            // è¯„è®ºåŒºï¼šä¸»é¢˜è·Ÿéš + éšè·¯ç”±åˆ‡æ¢è‡ªåŠ¨åˆ·æ–°
            GISCUS_CFG.theme = (document.documentElement.getAttribute('data-theme') === 'dark') ? 'dark' : 'light';
            renderOrUpdateGiscus(getGiscusTerm(vm));
          });
        },

        // Draw.io åœ¨çº¿ç¼–è¾‘æŒ‰é’®å¢å¼º
        function (hook, vm) {
          // ä¸º draw.io å›¾è¡¨æ·»åŠ åœ¨çº¿ç¼–è¾‘æŒ‰é’®
          function enhanceDrawioElements() {
            const drawioElements = document.querySelectorAll('.drawio-diagram');
            
            drawioElements.forEach(function(element) {
              // é¿å…é‡å¤æ·»åŠ æŒ‰é’®
              if (element.parentElement.querySelector('.drawio-edit-btn')) return;
              
              // æŸ¥æ‰¾å¯¹åº”çš„åŸå§‹ XML æ•°æ®
              let xmlData = '';
              const container = element.closest('.drawio-container') || element.parentElement;
              
              // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„ä½ç½®è·å– XML æ•°æ®
              const codeElement = container.querySelector('code, .drawio-code');
              if (codeElement) {
                xmlData = codeElement.textContent || codeElement.innerText || '';
              }
              
              // å¦‚æœæ²¡æœ‰æ‰¾åˆ° XML æ•°æ®ï¼Œå°è¯•ä» data å±æ€§è·å–
              if (!xmlData) {
                xmlData = element.getAttribute('data-drawio-xml') || '';
              }
              
              if (xmlData.trim()) {
                // åˆ›å»ºç¼–è¾‘æŒ‰é’®
                const editBtn = document.createElement('button');
                editBtn.className = 'drawio-edit-btn';
                editBtn.textContent = 'ğŸ“ ç”¨ Draw.io æ‰“å¼€';
                editBtn.title = 'åœ¨ Draw.io åœ¨çº¿ç¼–è¾‘å™¨ä¸­æ‰“å¼€æ­¤å›¾è¡¨';
                
                editBtn.onclick = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  try {
                    // æ„é€  draw.io åœ¨çº¿ç¼–è¾‘å™¨ URLï¼ˆä¿®å¤ä¸ºå¯ç¼–è¾‘ç‰ˆæœ¬ï¼‰
                    const encodedXml = encodeURIComponent(xmlData.trim());
                    const editUrl = `https://app.diagrams.net/#G${encodedXml}`;
                    
                    // åœ¨æ–°çª—å£ä¸­æ‰“å¼€
                    window.open(editUrl, '_blank', 'noopener,noreferrer');
                  } catch (error) {
                    console.error('æ‰“å¼€ Draw.io ç¼–è¾‘å™¨å¤±è´¥:', error);
                    alert('æ— æ³•æ‰“å¼€ Draw.io ç¼–è¾‘å™¨ï¼Œè¯·æ£€æŸ¥å›¾è¡¨æ•°æ®æ ¼å¼');
                  }
                };
                
                // å°†æŒ‰é’®æ·»åŠ åˆ°å®¹å™¨ä¸­
                const wrapper = container.classList.contains('drawio-container') ? container : element.parentElement;
                if (wrapper && !wrapper.querySelector('.drawio-edit-btn')) {
                  // åˆ›å»ºæŒ‰é’®å®¹å™¨
                  const btnContainer = document.createElement('div');
                  btnContainer.style.cssText = 'text-align: center; margin: 10px 0; padding: 5px;';
                  btnContainer.appendChild(editBtn);
                  
                  // å°†æŒ‰é’®å®¹å™¨æ·»åŠ åˆ°å›¾è¡¨åé¢
                  wrapper.appendChild(btnContainer);
                }
              }
            });
          }
          
          // åœ¨æ¯æ¬¡é¡µé¢æ¸²æŸ“åå¢å¼º draw.io å…ƒç´ 
          hook.doneEach(function() {
            setTimeout(enhanceDrawioElements, 500); // å¢åŠ å»¶è¿Ÿç¡®ä¿ draw.io æ’ä»¶å·²å®Œå…¨æ¸²æŸ“
          });
          
          // ä¹Ÿåœ¨åˆå§‹åŠ è½½æ—¶è¿è¡Œ
          hook.ready(function() {
            setTimeout(enhanceDrawioElements, 1000);
          });
        }
      ]
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="https://unpkg.com/docsify-tabs/dist/docsify-tabs.min.js"></script>
  <script src="https://unpkg.com/docsify-plugin-flexible-alerts"></script>
  
  <!-- Draw.io æ”¯æŒ -->
  <script src="https://cdn.jsdelivr.net/npm/docsify-drawio/viewer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docsify-drawio/drawio.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/docsify@4/lib/docsify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/js/docsify-themeable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-markup.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-java.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-go.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>

</body>
</html>
